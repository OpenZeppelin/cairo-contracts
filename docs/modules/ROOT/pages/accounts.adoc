:test-signers: https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.6.1/tests/signers.py
:snip-5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md
:snip-6: https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md

= Accounts

Unlike Ethereum where accounts are directly derived from a private key, there's no native Externally Owned Account (EOA) concept on Starknet.

Instead, the L2 features native account abstraction, and signature validation has to be done at the contract level. To relieve smart contract applications such as ERC20 tokens or exchanges from this responsibility, we make use of Account contracts to deal with transaction authentication.

For a general overview of the account abstraction, see StarkWare's https://medium.com/starkware/starknet-alpha-0-10-0-923007290470[StarkNet Alpha 0.10].
A more detailed discussion on the topic can be found in https://community.starknet.io/t/starknet-account-abstraction-model-part-1/781[StarkNet Account Abstraction Part 1].

TIP: For detailed information on the usage and implementation check the xref:/api/account.adoc[API Reference] section.

== Table of Contents

* <<basic_account,Basic Account>>
** <<account_entrypoints,Account entrypoints>>
** <<interface,Interface>>
* <<standard_account_interface,Standard Account Interface>>
** <<isrc6_interface,ISRC6 Interface>>
** <<isrc5_interface,ISRC5 Interface>>
* <<deploying_an_account,Deploying an Account>>

== Basic Account

As we mentioned, Accounts in Starknet are smart contracts, and so they can be deployed and interacted with like any other contract, and can be extended to implement any custom logic. However, the Account is a special type of contract that is used to validate and execute transactions, and there are a set of entrypoints that must be implemented for enabling these features.


=== Account entrypoints

The first two following methods are protocol-level enforced functions that must be implemented by any Account contract. The third one is optional and can be used for enabling declarations.

1. `\\__validate__` verifies the validity of the transaction to be executed. This is usually used to validate signatures, but following the account abstraction design, the entrypoint implementation can be customized to feature any validation mechanism.

2. `\\__execute__` executes the transaction if the validation is successful.

3. `\\__validate_declare__` Optional entrypoint similar to `\\__validate__` but for transactions meant to declare other contracts.


NOTE: Even when this entrypoints can be called directly at contract level, they are not designed for that, but to be called by the Starknet OS in the transaction execution flow.

=== Interface

Notice that we haven't mentioned the parameters or the return values of these entrypoints. This is because function selectors in Starknet are computed from the function name, without including the rest of the signature. This means that the entrypoints can be implemented with any signature, and the protocol will be able to call them as long as the function name is correct.

In the following interface, we are using the `Array<Call>` for enabling multicall transactions. Note that we don't need signature related parameters, because they are part of the transaction information that is accesible using the global context (ex: `starknet::get_tx_info()`).

[,javascript]
----
/// Represents a call to a target contract function.
struct Call {
    to: ContractAddress,
    selector: felt252,
    calldata: Array<felt252>
}

trait BaseAccount {
    /// Executes a transaction through the account.
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;

    /// Asserts whether the transaction is valid to be executed.
    fn __validate__(calls: Array<Call>) -> felt252;

    // (Optional) Asserts whether the transaction is valid to be declared.
    fn __validate_declare__(class_hash: felt252) -> felt252;
}
----

== Standard Account Interface

In the previous section we've presented the minimal interface a contract must implement to act as an Account by propagating transactions through the network. However, this interface lacks some features required for supporting interoperability among accounts and DApps in the ecosystem. For example, there is no mechanism for recognizing on-chain whether a contract is an Account or not.

To address this issue, we have the {snip-6}[SNIP-6] proposal, which defines a standard interface for Account contracts.

=== ISRC6 Interface

[,javascript]
----
/// Standard Account Interface
trait ISRC6 {
    /// Executes a transaction through the account.
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;

    /// Asserts whether the transaction is valid to be executed.
    fn __validate__(calls: Array<Call>) -> felt252;

    /// Asserts whether a given signature for a given hash is valid.
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;
}
----

The {snip-6}[SNIP-6] adds the `is_valid_signature` method. This method is not used by the protocol, but it's useful for DApps to verify the validity of signatures, supporting features like Sign In with Starknet.

The SNIP-6 also defines that compliant Accounts must implement the SRC5 interface following {snip-5}[SNIP-5], as a mechanism for detecting whether a contract is an Account or not through introspection.

=== ISRC5 Interface

[,javascript]
----
/// Standard Interface Detection
trait ISRC5 {
    /// Queries if a contract implements a given interface.
    fn supports_interface(interface_id: felt252) -> bool;
}
----

{snip-6}[SNIP-6] compliant Accounts must return `true` when queried for the ISRC6 interface Id.

Even though these interfaces are not enforced by the protocol, it's recommended to implement them for enabling interoperability with the ecosystem.

== Deploying an Account

In Starknet, there are two different ways for deploying smart contracts: the regular deployment using the `deploy_syscall` and the counterfactual deployment. The xref:udc.adoc[Universal Deployer Contract (UDC)] provides an interface for deploying arbitrary contracts through account calls (leveraging the first way through the `deploy_syscall`), but if you are deploying your first Account, you will probably want to use the counterfactual deployment, from the fact that you don't have an Account for calling the UDC in the first place.

For using counterfactual deployments, you need to implement another protocol-level entrypoint named `\\__validate_deploy__`. You can check the xref:/guides/deployment.adoc[Counterfactual Deployments] guide for getting into the specifics.
