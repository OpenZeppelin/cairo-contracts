:contract_class: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-classes/[Contract Class]
:class_hash: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash/[class hash]
:replace_class_syscall: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#replace_class[replace_class]
:upgradeable: https://github.com/OpenZeppelin/cairo-contracts/blob/cairo-2/src/upgrades/upgradeable.cairo[Upgradeable]
:ownable: xref:access.adoc#ownership_and_ownable[Ownable]

= Upgradeability

Smart contracts are immutable by design, by default preventing any update after the contract is deployed.
This supports decentralization and trustlessness, but in certain cases can be an drawback for example
by removing the ability of fixing bugs or vulnerabilities.

Multiple patterns have been developed for making a contract upgradeable including the widely adopted proxy pattern.

Starknet has native upgradeability through a syscall that updates the contract source code, removing the need for proxies.

== Replacing Contract Classes

To better comprehend how upgradeability works in Starknet, it's important to understand the difference between a contract and its contract class.

Contract classes represent the source code of a program. All contracts are associated to a class, and many contracts can be instances of the same one. Classes are usually represented by a hash also known as "class hash", and before a contract of a certain class can be deployed the hash needs to be declared.

=== `replace_class_syscall`

As mentioned, this class hash determines the contract source code, which is designed to be immutable.
However, since sometimes it is necessary to update the contract source code, the `{replace_class_syscall}` syscall
was introduced. This syscall allows developers to replace the class hash of an already deployed contract.


[,javascript]
----
/// Upgrades the contract source code to the new contract class.
fn _upgrade(new_class_hash: ClassHash) {
    assert(!new_class_hash.is_zero(), 'Class hash cannot be zero');
    starknet::replace_class_syscall(new_class_hash).unwrap();
}
----

NOTE: If a contract is deployed without this mechanism, the source code is effectively immutable.

== `Upgradeable` module

OpenZeppelin Contracts for Cairo provides {upgradeable} to add upgradeability support to your contracts.

=== Usage

Integrating this module into a contract first requires supporting some access control logic, in order to
avoid unauthorized upgrades. The {ownable} module is used for this example.

[,javascript]
----
#[starknet::contract]
mod UpgradeableContract {
    use openzeppelin::access::ownable::Ownable;
    use openzeppelin::upgrades::Upgradeable;
    use openzeppelin::upgrades::interface::IUpgradeable;
    use starknet::ClassHash;
    use starknet::ContractAddress;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(self: @ContractState, owner: ContractAddress) {
        let mut unsafe_state = Ownable::unsafe_new_contract_state();
        Ownable::InternalImpl::initializer(ref unsafe_state, owner);
    }

    #[external(v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            // This function can only be called by the owner
            let ownable_state = Ownable::unsafe_new_contract_state();
            Ownable::InternalImpl::assert_only_owner(@ownable_state);

            // Replace the class hash upgrading the contract
            let mut upgradeable_state = Upgradeable::unsafe_new_contract_state();
            Upgradeable::InternalImpl::upgrade(ref upgradeable_state, new_class_hash);
        }
    }

    (...)
}
----

=== Interface

Implementing this interface to support upgradeability, supports interoperability by for example allowing DAOs
and plugins to connect to contracts and upgrade them.

[,javascript]
----
trait IUpgradeable {
    fn upgrade(new_class_hash: ClassHash);
}
----

== Proxies and Starknet

A proxy contract is a contract that delegates function calls to another contract.
This type of pattern decouples state and logic.
Proxy contracts store the state and redirect function calls to an implementation contract that handles the logic,
usually catching these calls with a fallback mechanism.
This allows for different patterns such as upgrades, where implementation contracts can change but the proxy contract (and thus the state) does not;
as well as deploying multiple proxy instances pointing to the same implementation.
This can be useful to deploy many contracts with identical logic but unique initialization data.

In the case of contract upgrades, it is achieved by simply changing the proxy's reference to the class hash of the declared implementation.
This allows developers to add features, update logic, and fix bugs without touching the state or the contract address to interact with the application.

In Starknet, implementing a proxy pattern has an important limitation: there is no fallback mechanism to be used
for redirecting every potential function call to the implementation contract. This means a generic proxy contract
can't be implemented. Instead, a proxy contract must be implemented with each specific function that is going to be redirected.
This can still be useful for example with upgrading the logic of some functions.
