= Universal Deployer Contract

Account contracts are very critical components of the StarkNet ecosystem, since a bug in any implementation—let alone a widespread one—could prove disastrous.
Therefore, maximal caution is in order. In this spirit trimming account responsibilities should be considered to simplify implementations, minimizing their bug/attack surface.

To allow accounts to deploy contracts without compromising security, this standard proposes to move that functionality to an external, specialized deployer contract.
And since it makes no sense to deploy a new deployer contract for each account, this should be a singleton Universal Deployer Contract (UDC).



== Table of Contents
* <<quickstart, Quickstart>>
* <<deploying_the_udc,Deploying the UDC>>
* <<usage,Usage>>
 ** <<reserved_address_space_for_deployer,Reserved Address Space for Deployer>>
 ** <<reproducible_deployments,Reproducible Deployments>>
* <<calculating_counterfactual_addresses,Calculating Counterfactual Addresses>>
* <<universal_deployer_contract_api,Universal Deployer Contract API>>

== Quickstart

Account contracts need to first declare the contract and then send a `deployContract` transaction to the Universal Deployer Contract address.
Here's an example implementation in Python:

[,python]
----
signer = MockSigner(PRIVATE_KEY)

async def deploy_contract():
    # Declare the contract and get the class hash before deployment
    class_hash, _ = await signer.declare_class(account, "Ownable")

    # Set up deployment parameters
    salt = 123456  # random number
    unique = FALSE
    calldata = [account.contract_address]
    params = [class_hash, salt, unique, len(calldata), *calldata]

    # Send a "deployContract" transaction to the deployer contract
    await account.send_transaction(
        account,
        deployer_address,
        "deployContract",
        params
    )
----

TIP: The UDC address is `0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf`.
Note that this address may change in the future.

=== Deploying the UDC

Though, the Universal Deployer Contract has already been deployed, this documentation does not take its deployment for granted.
The deployment of the UDC requires a contract (probably an account) to call StarkWare's `deploy` syscall.
The whole point of the UDC lies in separating this responsibility from accounts; however, we need to deploy the UDC before relinquishing the deployment responsibility from accounts.

The UDC deployment should also set `deploy_from_zero=TRUE` in the `deploy` syscall.
In so doing, this creates a deterministic address that can be used across all instances of StarkNet.

== Usage

The Universal Deployer Contract offers two deployment types: reserving the address space for the deployer and reproducible deployments.
The `unique` boolean parameter ultimately determines the type of deployment.

CAUTION: When deploying a contract that uses `get_caller_address` in the constructor calldata, remember that the UDC (and not the account) deploys that contract.
Therefore, querying `get_caller_address` in a contract's constructor will return the UDC's address and *not* the account's address.


=== Reserved Address Space for Deployer

Reserving the address space for the deployer deploys a contract unique to the deployer.
This prevents squatting on addresses.

Achieving this type of deployment necessitates that the deployer sets `unique` to `TRUE` in the `deployContract` call.
Under the hood, the function call leverages the deployer's address and creates a hashchain by hashing the deployer's address with the given salt.

To deploy a unique contract address:

[,python]
----
signer = MockSigner(PRIVATE_KEY)

async def deploy_contract():
    # Declare the contract and get the class hash before deployment
    class_hash, _ = await signer.declare_class(account, "Ownable")

    # Set up deployment parameters
    salt = 123456  # random number
    unique = TRUE
    calldata = [account.contract_address]
    params = [class_hash, salt, unique, len(calldata), *calldata]

    # Send a "deployContract" transaction to the deployer contract
    await account.send_transaction(
        account,
        deployer_address,
        "deployContract",
        params
    )
----


=== Reproducible Deployments

Reproducible deployments create contract addresses independent of the deployer and the UDC instance.
Instead, only the class hash, salt, and constructor arguments determine the address.
This type of deployment enables redeployments of accounts and known systems across multiple networks.
To deploy a reproducible deployment, set `unique` to `FALSE`.

[,python]
----
signer = MockSigner(PRIVATE_KEY)

async def deploy_contract():
    # Declare the contract and get the class hash before deployment
    class_hash, _ = await signer.declare_class(account, "Ownable")

    # Set up deployment parameters
    salt = 123456  # random number
    unique = FALSE
    calldata = [account.contract_address]
    params = [class_hash, salt, unique, len(calldata), *calldata]

    # Send a "deployContract" transaction to the deployer contract
    await account.send_transaction(
        account,
        deployer_address,
        "deployContract",
        params
    )
----

== Calculating Counterfactual Addresses

Counterfactual addresses are contract addresses that haven't been deployed yet.
A strong use-case for calculating a contract's counterfactual address lies in deploying account contracts.
See xref:accounts.adoc#counterfactual_deployments[Counterfactual Deployments].

To predict the counterfactual address, use the StarkWare library's `calculate_contract_address_from_hash` and pass the same arguments that will be used for the actual deployment.
For example:

[,python]
----
from starkware.starknet.core.os.contract_address.contract_address import (
    calculate_contract_address_from_hash,
)

expected_address = calculate_contract_address_from_hash(
    salt=salt,
    class_hash=class_hash,
    constructor_calldata=calldata,
    deployer_address=deployer_address
)
----

== Universal Deployer Contract API

=== Methods

[,cairo]
----
func deployContract(
    classHash: felt,
    salt: felt,
    unique: felt,
    calldata_len: felt,
    calldata: felt*
) -> (address: felt) {
}

----

==== deployContract

Deploy a contract through the Universal Deploy Contract.

Parameters:

[,cairo]
----
classHash: felt
salt: felt
unique: felt
calldata_len: felt
calldata: felt*
----

Returns:

[,cairo]
----
address: felt
----

=== Events

[,cairo]
----
func ContractDeployed(
    address: felt,
    deployer: felt,
    unique: felt,
    classHash: felt,
    calldata_len: felt,
    calldata: felt*,
    salt: felt
) {
}
----

==== `ContractDeployed`

Emitted when `deployer` deploys a contract through the Universal Deployer Contract.

Parameters:

[,cairo]
----
address: felt,
deployer: felt,
unique: felt,
classHash: felt,
calldata_len: felt,
calldata: felt*,
salt: felt
----
