= ERC721

The ERC721 token standard is a specification for https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[non-fungible tokens], or more colloquially: NFTs.
The `erc721.cairo` contract implements an approximation of https://eips.ethereum.org/EIPS/eip-721[EIP-721] in Cairo for StarkNet.

== Table of Contents

* <<ierc721,IERC721>>
* <<erc721_compatibility,ERC721 Compatibility>>
* <<usage,Usage>>
 ** <<token_transfers,Token Transfers>>
 ** <<interpreting_erc721_uris,Interpreting ERC721 URIs>>
 ** <<erc721received,ERC721Received>>
  *** <<ierc721receiver,IERC721Receiver>>
 ** <<supporting_interfaces,Supporting Interfaces>>
 ** <<ready_to_use_presets,Ready_to_Use Presets>>
* <<extensibility,Extensibility>>
* <<presets,Presets>>
 ** <<erc721mintableburnable,ERC721MintableBurnable>>
 ** <<erc721mintablepausable,ERC721MintablePausable>>
 ** <<erc721enumerablemintableburnable,ERC721EnumerableMintableBurnable>>
  *** <<ierc721enumerable,IERC721Enumerable>>
 ** <<erc721metadata,ERC721Metadata>>
  *** <<ierc721metadata,IERC721Metadata>>
* <<utilities,Utilities>>
 ** <<erc721_holder,ERC721Holder>>
* <<api_specification,API Specification>>
 ** <<ierc721_api,`IERC721`>>
  *** <<balanceof,`balanceOf`>>
  *** <<ownerof,`ownerOf`>>
  *** <<safetransferfrom,`safeTransferFrom`>>
  *** <<transferfrom,`transferFrom`>>
  *** <<approve,`approve`>>
  *** <<setapprovalforall,`setApprovalForAll`>>
  *** <<getapproved,`getApproved`>>
  *** <<isapprovedforall,`isApprovedForAll`>>
 ** <<events,Events>>
  *** <<approval_event,`Approval (event)`>>
  *** <<approvalforall_event,`ApprovalForAll (event)`>>
  *** <<transfer_event,`Transfer (event)`>>
 ** <<ierc721metadata,`IERC721Metadata`>>
  *** <<name,`name`>>
  *** <<symbol,`symbol`>>
  *** <<tokenuri,`tokenURI`>>
 ** <<ierc721enumerable,`IERC721Enumerable`>>
  *** <<totalsupply,`totalSupply`>>
  *** <<tokenbyindex,`tokenByIndex`>>
  *** <<tokenofownerbyindex,`tokenOfOwnerByIndex`>>
 ** <<ierc721receiver_api,`IERC721Receiver`>>
  *** <<onerc721received,`onERC721Received`>>

== IERC721

[,rust]
----
#[starknet::interface]
trait IERC721<TState> {
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn owner_of(self: @TState, token_id: u256) -> ContractAddress;
    fn transfer_from(
        ref self: TState,
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256
    );
    fn safe_transfer_from(
        ref self: TState,
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    );
    fn approve(ref self: TState, to: ContractAddress, token_id: u256);
    fn set_approval_for_all(
        ref self: TState,
        operator: ContractAddress,
        approved: bool
    );
    fn get_approved(self: @TState, token_id: u256) -> ContractAddress;
    fn is_approved_for_all(
        self: @TState, owner: ContractAddress, operator: ContractAddress
    ) -> bool;
}

#[starknet::interface]
trait ISRC5<TState> {
    fn supports_interface(self: @TState, interface_id: felt252) -> bool;
}
----

=== ERC721 Compatibility

Although StarkNet is not EVM compatible, this implementation aims to be as close as possible to the ERC721 standard in the following ways:

* It uses Cairo's `u256` instead of `felt252`.
* It returns `true` as success.
* It makes use of Cairo's short strings to simulate `name` and `symbol`.

But some differences can still be found, such as:

* `token_uri` returns a felt252 representation of the queried token's URI.
The EIP721 standard, however, states that the return value should be of type string.
If a token's URI is not set, the returned value is `0`.
Note that URIs cannot exceed 31 characters at this time.
See <<interpreting_erc721_uris,Interpreting ERC721 URIs>>.
* ``interface_id``s are hardcoded and initialized by the constructor.
The hardcoded values derive from Solidity's selector calculations.
See <<supporting_interfaces,Supporting Interfaces>>.
* `safeTransferFrom` can only be expressed as a single function in Cairo as opposed to the two functions declared in EIP721.
The difference between both functions consists of accepting `data` as an argument.
Because function overloading is currently not possible in Cairo, `safeTransferFrom` by default accepts the `data` argument.
If `data` is not used, simply insert `0`.
* `safeTransferFrom` is specified such that the optional `data` argument should be of type bytes.
In Solidity, this means a dynamically-sized array.
To be as close as possible to the standard, it accepts a dynamic array of felts.
In Cairo, arrays are expressed with the array length preceding the actual array;
hence, the method accepts `data_len` and `data` respectively as types `felt` and `felt*`.
* `ERC165.register_interface` allows contracts to set and communicate which interfaces they support.
This follows OpenZeppelin's https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v0.6.1/contracts/utils/introspection/ERC165Storage.sol[ERC165Storage].
* `IERC721Receiver` compliant contracts (`ERC721Holder`) return a hardcoded selector id according to EVM selectors, since selectors are calculated differently in Cairo.
This is in line with the ERC165 interfaces design choice towards EVM compatibility.
See the xref:introspection.adoc[Introspection docs] for more info.
* `IERC721Receiver` compliant contracts (`ERC721Holder`) must support ERC165 by registering the `IERC721Receiver` selector id in its constructor and exposing the `supportsInterface` method.
In doing so, recipient contracts (both accounts and non-accounts) can be verified that they support ERC721 transfers.
* `ERC721Enumerable` tracks the total number of tokens with the `all_tokens` and `all_tokens_len` storage variables mimicking the array of the Solidity implementation.

== Usage

TODO

=== Token Transfers

This library includes `transfer_from` and `safe_transfer_from` to transfer NFTs.
If using `transfer_from`, *the caller is responsible to confirm that the recipient is capable of receiving NFTs or else they may be permanently lost.*

The `safe_transfer_from` method incorporates the following conditional logic:

. If the calling address is an account contract, the token transfer will behave as if `transfer_from` was called.
. If the calling address is not an account contract, the safe function will check that the contract supports ERC721 tokens.

The current implementation of `safe_transfer_from` checks for `on_erc721_received` and requires that the recipient contract supports SRC5 and exposes the `supports_interface` method.
See <<erc721received,ERC721Received>>.

## Fix me^

=== Interpreting ERC721 URIs

Token URIs in Cairo are stored as single field elements.
Each field element equates to 252-bits (or 31.5 bytes) which means that a token's URI can be no longer than 31 characters.

NOTE: Storing the URI as an array of felts was considered to accommodate larger strings.
While this approach is more flexible regarding URIs, a returned array further deviates from the standard set in https://eips.ethereum.org/EIPS/eip-721[EIP721].
Therefore, this library's ERC721 implementation sets URIs as a single field element.

=== ERC721Received

In order to be sure a contract can safely accept ERC721 tokens, said contract must implement the `IERC721Receiver` interface (as expressed in the EIP721 specification).
Methods such as `safe_transfer_from` and `safe_mint` call the recipient contract's `on_erc721_received` method.
If the contract fails to return the correct magic value, the transaction fails.

Starknet contracts that support safe transfers, however, must also support xref:introspection.adoc#src5[SRC5] and include `supports_interface` as proposed (originally as ERC165) in https://github.com/OpenZeppelin/cairo-contracts/discussions/100[#100].
`safe_transfer_from` requires a means of differentiating between account and non-account contracts.
`on_erc721_received` will call `supports_interface` with the SRC6 magic value (INSERT ME) on the recipient address.
SRC6-compliant account contracts will return `true` thus communicating that the recipient is an account contract.
Non-account contracts, however, _must_ register support for ERC721 safe transfers.
Otherwise, the safe transfer will fail.

Currently, Starknet does not support error handling from the contract level;
therefore, the current ERC721 implementation requires that all contracts that support safe ERC721 transfers (both accounts and non-accounts) include the `supportsInterface` method.
Further, `supportsInterface` should return `TRUE` if the recipient contract supports the `IERC721Receiver` magic value `0x150b7a02` (which invokes `onERC721Received`).
If the recipient contract supports the `IAccount` magic value `0x50b70dcb`, `supportsInterface` should return `TRUE`.
Otherwise, `safeTransferFrom` should fail.

==== IERC721Receiver

Interface for any contract that wants to support safe transfers from ERC721 asset contracts.

[,rust]
----
#[starknet::interface]
trait IERC721Receiver<TState> {
    fn on_erc721_received(
        self: @TState,
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    ) -> felt252;
}
----

=== Supporting Interfaces

TODO

=== Ready-to-Use Presets

ERC721 presets have been created to allow for quick deployments as-is whic are a great option for testing and prototyping.
See <<presets,Presets>>.

== Extensibility

TODO

== Presets

TODO

=== ERC721Metadata

The `ERC721Metadata` extension allows your smart contract to be interrogated for its name and for details about the assets which your NFTs represent.

We follow OpenZeppelin's Solidity approach of integrating the Metadata methods `name`, `symbol`, and `tokenURI` into all ERC721 implementations.
If preferred, a contract can be created that does not import the Metadata methods from the `ERC721` library.
Note that the `IERC721Metadata` interface id should be removed from the constructor as well.

==== IERC721Metadata

[,rust]
----
#[starknet::interface]
trait IERC721Metadata<TState> {
    fn name(self: @TState) -> felt252;
    fn symbol(self: @TState) -> felt252;
    fn token_uri(self: @TState, token_id: u256) -> felt252;
}
----

== API Specification

=== IERC721 API

[,rust]
----
fn balance_of(self: @ContractState, account: ContractAddress) -> u256;
fn owner_of(self: @ContractState, token_id: u256) -> ContractAddress;
fn transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256);
fn safe_transfer_from(
    ref self: ContractState,
    from: ContractAddress,
    to: ContractAddress,
    token_id: u256,
    data: Span<felt252>
);
fn approve(ref self: ContractState, to: ContractAddress, token_id: u256);
fn set_approval_for_all(ref self: ContractState, operator: ContractAddress, approved: bool);
fn get_approved(self: @ContractState, token_id: u256) -> ContractAddress;
fn is_approved_for_all(
    self: @ContractState, owner: ContractAddress, operator: ContractAddress
) -> bool;
----

==== `balance_of`

[.contract-item]
[[balance_of]]
==== `[.contract-item-name]#++balance_of++#++(self: @ContractState, account: ContractAddress) → u256++`

Returns the number of NFTs owned by `account`.

===== Arguments

- `*account*`
+
The account balance to query.

===== Returns

- `*u256*`
+
Token balance of `account`.

==== `owner_of`

[.contract-item]
[[owner_of]]
==== `[.contract-item-name]#++owner_of++#++(self: @ContractState, token_id: u256) → ContractAddress++`

Returns the owner address of `token_id`.

===== Arguments

- `*token_id*`
+
The token to query.

===== Returns

- `*ContractAddress*`
+
Owner address of `token_id`.

==== `transfer_from`

[.contract-item]
[[transfer_from]]
==== `[.contract-item-name]#++transfer_from++#++(self: @ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)++`

Transfer ownership of `token_id` from `from` to `to`.
    
Note that the caller is responsible to confirm that the recipient is
capable of receiving ERC721 transfers or else they may be permanently lost.
Usage of <<safe_transfer_from,safe_transfer_from>> prevents loss, though
the caller must understand this adds an external call which potentially
creates a reentrancy vulnerability.
    
Emits a <<Transfer,Transfer>> event.

===== Arguments

- `*from*`
+
The current owner of the NFT.
- `*to*`
+
The new owner.
- `*token_id*`
+
The NFT to transfer.

==== `safe_transfer_from`

[.contract-item]
[[safe_transfer_from]]
==== `[.contract-item-name]#++safe_transfer_from++#++(self: @ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++`

Safely transfer ownership of `token_id` from `from` to `to`, checking first
that `to` is aware of the ERC721 protocol to prevent tokens being locked
forever. For information regarding how contracts communicate their
awareness of the ERC721 protocol, see <<ERC721Receiver,ERC721Receiver>>(TODO!).
    
Emits a <<Transfer,Transfer>> event.

===== Arguments

- `*from*`
+
The current owner of the NFT.
- `*to*`
+
The new owner.
- `*token_id*`
+
The NFT to transfer.
- `*data*`
+
Additional data with no specified format, sent in call to `to`.

==== `approve`

[.contract-item]
[[approve]]
==== `[.contract-item-name]#++approve++#++(self: @ContractState, to: ContractAddress, token_id: u256)++`

Change or reaffirm the approved address for an NFT.

===== Arguments

- `*to*`
+
The new approved NFT controller.
- `*token_id*`
+
The NFT to approve.

    fn set_approval_for_all(ref self: TState, operator: ContractAddress, approved: bool);

==== `set_approval_for_all`

[.contract-item]
[[set_approval_for_all]]
==== `[.contract-item-name]#++set_approval_for_all++#++(self: @ContractState, operator: ContractAddress, approved: bool)++`

Enable or disable approval for `operator` to manage all of the
caller's assets.

Emits an <<Approval,Approval>> event.

===== Arguments

- `*operator*`
+
Address to add to the set of authorized operators.
- `*approved*`
+
`true` if operator is approved, `false` to revoke approval.

==== `get_approved`

[.contract-item]
[[get_approved]]
==== `[.contract-item-name]#++get_approved++#++(self: @ContractState, token_id: u256) -> ContractAddress++`

Returns the address approved for `token_id`.

===== Arguments

- `*token_id*`
+
The token ID to query.

===== Returns

- `*ContractAddress*`
+
Approved address for the `token_id` NFT, or `0` if there is none.

==== `is_approved_for_all`

[.contract-item]
[[is_approved_for_all]]
==== `[.contract-item-name]#++is_approved_for_all++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++`

Query if `operator` is an authorized operator for `owner`.

===== Arguments

- `*owner*`
+
The address that owns the NFT.
- `*operator*`
+
The address that acts on behalf of the `owner`.

===== Returns

- `*bool*`
+
`true` if `operator` is an authorized operator for `owner`.

=== Events

[,rust]
----
#[event]
#[derive(Drop, starknet::Event)]
enum Event {
    Transfer: Transfer,
    Approval: Approval,
    ApprovalForAll: ApprovalForAll
}

#[derive(Drop, starknet::Event)]
struct Approval {
    owner: ContractAddress,
    approved: ContractAddress,
    token_id: u256
}

#[derive(Drop, starknet::Event)]
struct ApprovalForAll {
    owner: ContractAddress,
    operator: ContractAddress,
    approved: bool
}

#[derive(Drop, starknet::Event)]
struct Transfer {
    from: ContractAddress,
    to: ContractAddress,
    token_id: u256
}
----

==== `Approval`

[.contract-item]
[[Approval]]
==== `[.contract-item-name]#++Approval++#++(owner: ContractAddress, approved: ContractAddress, token_id: u256)++`

Emitted when `owner` enables `approved` to manage the `token_id` token.

===== Arguments

- `*owner*`
+
The owner of the NFT.
- `*approved*`
+
The new approved NFT controller.
- `*token_id*`
+
The NFT to approve.

==== `ApprovalForAll`

[.contract-item]
[[ApprovalForAll]]
==== `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++`

Emitted when `owner` enables or disables (approved) `operator` to manage all of its assets.

===== Arguments

- `*owner*`
+
The owner of the NFT.
- `*operator*`
+
Address to add to the set of authorized operators.
- `*approved*`
+
`true` if the operator is approved, `false` to revoke approval.

==== `Transfer`

[.contract-item]
[[Transfer]]
==== `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++`

Emitted when `token_id` token is transferred from `from` to `to`.

===== Arguments

- `*from*`
+
The current owner of the NFT.
- `*to*`
+
The new owner of the NFT.
- `*token_id*`
+
The NFT to transfer.

=== IERC721Metadata API

[,rust]
----
#[starknet::interface]
trait IERC721Metadata<TState> {
    fn name(self: @TState) -> felt252;
    fn symbol(self: @TState) -> felt252;
    fn token_uri(self: @TState, token_id: u256) -> felt252;
}
----

==== `name`

[.contract-item]
[[name]]
==== `[.contract-item-name]#++name++#++(self: @ContractState)++`

Returns the NFT name.

===== Returns

- `*felt252*`
+
The NFT name.

==== `symbol`

[.contract-item]
[[symbol]]
==== `[.contract-item-name]#++symbol++#++(self: @ContractState)++`

Returns the NFT ticker symbol.

===== Returns

- `*felt252*`
+
The NFT symbol.

==== `token_uri`

[.contract-item]
[[token_uri]]
==== `[.contract-item-name]#++token_uri++#++(self: @ContractState, token_id: u256)++`

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If the URI is not set for the `token_id`, the return value will be `0`.

===== Arguments

- `*token_id*`
+
The NFT symbol.

===== Returns

- `*felt252*`
+
The URI of `token_id`.

=== IERC721Receiver API

[,cairo]
----
func onERC721Received(
    operator: felt, from_: felt, tokenId: Uint256, data_len: felt252data: felt*
) -> (selector: felt) {
}
----

==== `onERC721Received`

Whenever an IERC721 `tokenId` token is transferred to this non-account contract via `safeTransferFrom` by `operator` from `from_`, this function is called.

Parameters:

[,cairo]
----
operator: felt
from_: felt
tokenId: Uint256
data_len: felt
data: felt*
----

Returns:

[,cairo]
----
selector: felt
----
