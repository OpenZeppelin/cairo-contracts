:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:CallScheduled: xref:ITimelock-CallScheduled[CallScheduled]
:CallExecuted: xref:ITimelock-CallExecuted[CallExecuted]
:CallSalt: xref:ITimelock-CallSalt[CallSalt]
:CallCancelled: xref:ITimelock-CallCancelled[CallCancelled]
:MinDelayChanged: xref:ITimelock-MinDelayChanged[MinDelayChanged]
:RoleGranted: xref:api/access.adoc#IAccessControl-RoleGranted[IAccessControl::RoleGranted]
:DelegateChanged: xref:VotesComponent-DelegateChanged[DelegateChanged]
:DelegateVotesChanged: xref:VotesComponent-DelegateVotesChanged[DelegateVotesChanged]
:VotingUnitsTrait: xref:VotingUnitsTrait[VotingUnitsTrait]
:VotesComponent: xref:VotesComponent[VotesComponent]
:IVotes: xref:IVotes[IVotes]

= Governance

This crate includes primitives for on-chain governance.

== Multisig

A Multisig module enhances security and decentralization by requiring multiple signers to 
approve and execute transactions. Features include configurable quorum, signer management, 
and self-administration, ensuring collective decision-making and transparency for critical 
operations.

[.contract]
[[IMultisig]]
=== `++IMultisig++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.20.0/packages/governance/src/multisig/interface.cairo[{github-icon},role=heading-link]

:IMultisig-CallSalt: xref:IMultisig-CallSalt[CallSalt]
:IMultisig-SignerAdded: xref:IMultisig-SignerAdded[SignerAdded]
:IMultisig-SignerRemoved: xref:IMultisig-SignerRemoved[SignerRemoved]
:IMultisig-QuorumUpdated: xref:IMultisig-QuorumUpdated[QuorumUpdated]
:IMultisig-TransactionSubmitted: xref:IMultisig-TransactionSubmitted[TransactionSubmitted]
:IMultisig-TransactionConfirmed: xref:IMultisig-TransactionConfirmed[TransactionConfirmed]
:IMultisig-ConfirmationRevoked: xref:IMultisig-ConfirmationRevoked[ConfirmationRevoked]
:IMultisig-TransactionExecuted: xref:IMultisig-TransactionExecuted[TransactionExecuted]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::multisig::interface::IMultisig;
```

Interface of a multisig contract.

[.contract-index]
.Functions
--
* xref:#IMultisig-get_quorum[`++get_quorum()++`]
* xref:#IMultisig-is_signer[`++is_signer(signer)++`]
* xref:#IMultisig-get_signers[`++get_signers()++`]
* xref:#IMultisig-is_confirmed[`++is_confirmed(id)++`]
* xref:#IMultisig-is_confirmed_by[`++is_confirmed_by(id, signer)++`]
* xref:#IMultisig-is_executed[`++is_executed(id)++`]
* xref:#IMultisig-get_submitted_block[`++get_submitted_block(id)++`]
* xref:#IMultisig-get_transaction_state[`++get_transaction_state(id)++`]
* xref:#IMultisig-get_transaction_confirmations[`++get_transaction_confirmations(id)++`]
* xref:#IMultisig-hash_transaction[`++hash_transaction(to, selector, calldata, salt)++`]
* xref:#IMultisig-hash_transaction_batch[`++hash_transaction_batch(calls, salt)++`]
* xref:#IMultisig-add_signers[`++add_signers(new_quorum, signers_to_add)++`]
* xref:#IMultisig-remove_signers[`++remove_signers(new_quorum, signers_to_remove)++`]
* xref:#IMultisig-replace_signer[`++replace_signer(signer_to_remove, signer_to_add)++`]
* xref:#IMultisig-change_quorum[`++change_quorum(new_quorum)++`]
* xref:#IMultisig-submit_transaction[`++submit_transaction(to, selector, calldata, salt)++`]
* xref:#IMultisig-submit_transaction_batch[`++submit_transaction_batch(calls, salt)++`]
* xref:#IMultisig-confirm_transaction[`++confirm_transaction(id)++`]
* xref:#IMultisig-revoke_confirmation[`++revoke_confirmation(id)++`]
* xref:#IMultisig-execute_transaction[`++execute_transaction(to, selector, calldata, salt)++`]
* xref:#IMultisig-execute_transaction_batch[`++execute_transaction_batch(calls, salt)++`]
--

[.contract-index]
.Events
--
* xref:#IMultisig-SignerAdded[`++SignerAdded(signer)++`]
* xref:#IMultisig-SignerRemoved[`++SignerRemoved(signer)++`]
* xref:#IMultisig-QuorumUpdated[`++QuorumUpdated(old_quorum, new_quorum)++`]
* xref:#IMultisig-TransactionSubmitted[`++TransactionSubmitted(id, signer)++`]
* xref:#IMultisig-TransactionConfirmed[`++TransactionConfirmed(id, signer)++`]
* xref:#IMultisig-ConfirmationRevoked[`++ConfirmationRevoked(id, signer)++`]
* xref:#IMultisig-TransactionExecuted[`++TransactionExecuted(id)++`]
* xref:#IMultisig-CallSalt[`++CallSalt(id, salt)++`]
--

[#IMultisig-Functions]
==== Functions

[.contract-item]
[[IMultisig-get_quorum]]
==== `[.contract-item-name]#++get_quorum++#++() → u32++` [.item-kind]#external#

Returns the current quorum value. The quorum is the minimum number of confirmations required to approve a transaction.

[.contract-item]
[[IMultisig-is_signer]]
==== `[.contract-item-name]#++is_signer++#++(signer: ContractAddress) → bool++` [.item-kind]#external#

Returns whether the given `signer` is registered. Only registered signers can submit, confirm, or execute transactions.

[.contract-item]
[[IMultisig-get_signers]]
==== `[.contract-item-name]#++get_signers++#++() → Span<ContractAddress>++` [.item-kind]#external#

Returns the list of all current signers.

[.contract-item]
[[IMultisig-is_confirmed]]
==== `[.contract-item-name]#++is_confirmed++#++(id: TransactionID) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been confirmed.

[.contract-item]
[[IMultisig-is_confirmed_by]]
==== `[.contract-item-name]#++is_confirmed_by++#++(id: TransactionID, signer: ContractAddress) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

[.contract-item]
[[IMultisig-is_executed]]
==== `[.contract-item-name]#++is_executed++#++(id: TransactionID) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been executed.

[.contract-item]
[[IMultisig-get_submitted_block]]
==== `[.contract-item-name]#++get_submitted_block++#++(id: TransactionID) → u64++` [.item-kind]#external#

Returns the block number when the transaction with the given `id` was submitted.

[.contract-item]
[[IMultisig-get_transaction_state]]
==== `[.contract-item-name]#++get_transaction_state++#++(id: TransactionID) → TransactionState++` [.item-kind]#external#

Returns the current state of the transaction with the given `id`.

[.contract-item]
[[IMultisig-get_transaction_confirmations]]
==== `[.contract-item-name]#++get_transaction_confirmations++#++(id: TransactionID) → u32++` [.item-kind]#external#

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

[.contract-item]
[[IMultisig-hash_transaction]]
==== `[.contract-item-name]#++hash_transaction++#++(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID++` [.item-kind]#external#

Returns the computed identifier of a transaction containing a single call.

[.contract-item]
[[IMultisig-hash_transaction_batch]]
==== `[.contract-item-name]#++hash_transaction_batch++#++(calls: Span<Call>, salt: felt252) → TransactionID++` [.item-kind]#external#

Returns the computed identifier of a transaction containing a batch of calls.

[.contract-item]
[[IMultisig-add_signers]]
==== `[.contract-item-name]#++add_signers++#++(new_quorum: u32, signers_to_add: Span<ContractAddress>)++` [.item-kind]#external#

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after addition.

Emits a {IMultisig-SignerAdded} event for each signer added.

Emits a {IMultisig-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[IMultisig-remove_signers]]
==== `[.contract-item-name]#++remove_signers++#++(new_quorum: u32, signers_to_remove: Span<ContractAddress>)++` [.item-kind]#external#

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after removal.

Emits a {IMultisig-SignerRemoved} event for each signer removed.

Emits a {IMultisig-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[IMultisig-replace_signer]]
==== `[.contract-item-name]#++replace_signer++#++(signer_to_remove: ContractAddress, signer_to_add: ContractAddress)++` [.item-kind]#external#

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.
- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.

Emits a {IMultisig-SignerRemoved} event for the removed signer.

Emits a {IMultisig-SignerAdded} event for the new signer.

[.contract-item]
[[IMultisig-change_quorum]]
==== `[.contract-item-name]#++change_quorum++#++(new_quorum: u32)++` [.item-kind]#external#

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a {IMultisig-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[IMultisig-submit_transaction]]
==== `[.contract-item-name]#++submit_transaction++#++(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID++` [.item-kind]#external#

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a {IMultisig-TransactionSubmitted} event.

Emits a {IMultisig-CallSalt} event if `salt` is not zero.

[.contract-item]
[[IMultisig-submit_transaction_batch]]
==== `[.contract-item-name]#++submit_transaction_batch++#++(calls: Span<Call>, salt: felt252) → TransactionID++` [.item-kind]#external#

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a {IMultisig-TransactionSubmitted} event.

Emits a {IMultisig-CallSalt} event if `salt` is not zero.

[.contract-item]
[[IMultisig-confirm_transaction]]
==== `[.contract-item-name]#++confirm_transaction++#++(id: TransactionID)++` [.item-kind]#external#

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.
- The transaction must exist and not be executed.
- The caller must not have already confirmed the transaction.

Emits a {IMultisig-TransactionConfirmed} event.

[.contract-item]
[[IMultisig-revoke_confirmation]]
==== `[.contract-item-name]#++revoke_confirmation++#++(id: TransactionID)++` [.item-kind]#external#

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.
- The caller must have previously confirmed the transaction.

Emits a {IMultisig-ConfirmationRevoked} event.

[.contract-item]
[[IMultisig-execute_transaction]]
==== `[.contract-item-name]#++execute_transaction++#++(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#external#

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a {IMultisig-TransactionExecuted} event.

[.contract-item]
[[IMultisig-execute_transaction_batch]]
==== `[.contract-item-name]#++execute_transaction_batch++#++(calls: Span<Call>, salt: felt252)++` [.item-kind]#external#

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a {IMultisig-TransactionExecuted} event.

[#IMultisig-Events]
==== Events

[.contract-item]
[[IMultisig-SignerAdded]]
==== `[.contract-item-name]#++SignerAdded++#++(signer: ContractAddress)++` [.item-kind]#event#

Emitted when a new `signer` is added.

[.contract-item]
[[IMultisig-SignerRemoved]]
==== `[.contract-item-name]#++SignerRemoved++#++(signer: ContractAddress)++` [.item-kind]#event#

Emitted when a `signer` is removed.

[.contract-item]
[[IMultisig-QuorumUpdated]]
==== `[.contract-item-name]#++QuorumUpdated++#++(old_quorum: u32, new_quorum: u32)++` [.item-kind]#event#

Emitted when the `quorum` value is updated.

[.contract-item]
[[IMultisig-TransactionSubmitted]]
==== `[.contract-item-name]#++TransactionSubmitted++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a new transaction is submitted by a `signer`.

[.contract-item]
[[IMultisig-TransactionConfirmed]]
==== `[.contract-item-name]#++TransactionConfirmed++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a transaction is confirmed by a `signer`.

[.contract-item]
[[IMultisig-ConfirmationRevoked]]
==== `[.contract-item-name]#++ConfirmationRevoked++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a `signer` revokes his confirmation.

[.contract-item]
[[IMultisig-TransactionExecuted]]
==== `[.contract-item-name]#++TransactionExecuted++#++(id: TransactionID)++` [.item-kind]#event#

Emitted when a transaction is executed.

[.contract-item]
[[IMultisig-CallSalt]]
==== `[.contract-item-name]#++CallSalt++#++(id: felt252, salt: felt252)++` [.item-kind]#event#

Emitted when a new transaction is submitted with non-zero salt.

[.contract]
[[MultisigComponent]]
=== `++MultisigComponent++`

:MultisigComponent-CallSalt: xref:MultisigComponent-CallSalt[CallSalt]
:MultisigComponent-SignerAdded: xref:MultisigComponent-SignerAdded[SignerAdded]
:MultisigComponent-SignerRemoved: xref:MultisigComponent-SignerRemoved[SignerRemoved]
:MultisigComponent-QuorumUpdated: xref:MultisigComponent-QuorumUpdated[QuorumUpdated]
:MultisigComponent-TransactionSubmitted: xref:MultisigComponent-TransactionSubmitted[TransactionSubmitted]
:MultisigComponent-TransactionConfirmed: xref:MultisigComponent-TransactionConfirmed[TransactionConfirmed]
:MultisigComponent-ConfirmationRevoked: xref:MultisigComponent-ConfirmationRevoked[ConfirmationRevoked]
:MultisigComponent-TransactionExecuted: xref:MultisigComponent-TransactionExecuted[TransactionExecuted]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::multisig::MultisigComponent;
```

Component that implements <<IMultisig, IMultisig>> and provides functionality for multisignature wallets, 
including transaction management, quorum handling, and signer operations.

[.contract-index]
.Embeddable Implementations
--
.MultisigImpl

* xref:#MultisigComponent-get_quorum[`++get_quorum(self)++`]
* xref:#MultisigComponent-is_signer[`++is_signer(self, signer)++`]
* xref:#MultisigComponent-get_signers[`++get_signers(self)++`]
* xref:#MultisigComponent-is_confirmed[`++is_confirmed(self, id)++`]
* xref:#MultisigComponent-is_confirmed_by[`++is_confirmed_by(self, id, signer)++`]
* xref:#MultisigComponent-is_executed[`++is_executed(self, id)++`]
* xref:#MultisigComponent-get_submitted_block[`++get_submitted_block(self, id)++`]
* xref:#MultisigComponent-get_transaction_state[`++get_transaction_state(self, id)++`]
* xref:#MultisigComponent-get_transaction_confirmations[`++get_transaction_confirmations(self, id)++`]
* xref:#MultisigComponent-hash_transaction[`++hash_transaction(self, to, selector, calldata, salt)++`]
* xref:#MultisigComponent-hash_transaction_batch[`++hash_transaction_batch(self, calls, salt)++`]
* xref:#MultisigComponent-add_signers[`++add_signers(ref self, new_quorum, signers_to_add)++`]
* xref:#MultisigComponent-remove_signers[`++remove_signers(ref self, new_quorum, signers_to_remove)++`]
* xref:#MultisigComponent-replace_signer[`++replace_signer(ref self, signer_to_remove, signer_to_add)++`]
* xref:#MultisigComponent-change_quorum[`++change_quorum(ref self, new_quorum)++`]
* xref:#MultisigComponent-submit_transaction[`++submit_transaction(ref self, to, selector, calldata, salt)++`]
* xref:#MultisigComponent-submit_transaction_batch[`++submit_transaction_batch(ref self, calls, salt)++`]
* xref:#MultisigComponent-confirm_transaction[`++confirm_transaction(ref self, id)++`]
* xref:#MultisigComponent-revoke_confirmation[`++revoke_confirmation(ref self, id)++`]
* xref:#MultisigComponent-execute_transaction[`++execute_transaction(ref self, to, selector, calldata, salt)++`]
* xref:#MultisigComponent-execute_transaction_batch[`++execute_transaction_batch(ref self, calls, salt)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#MultisigComponent-initializer[`++initializer(ref self, quorum, signers)++`]
* xref:#MultisigComponent-resolve_tx_state[`++resolve_tx_state(self, id)++`]
* xref:#MultisigComponent-assert_one_of_signers[`++assert_one_of_signers(self, caller)++`]
* xref:#MultisigComponent-assert_tx_exists[`++assert_tx_exists(self, id)++`]
* xref:#MultisigComponent-assert_only_self[`++assert_only_self(self)++`]
* xref:#MultisigComponent-_add_signers[`++_add_signers(ref self, new_quorum, signers_to_add)++`]
* xref:#MultisigComponent-_remove_signers[`++_remove_signers(ref self, new_quorum, signers_to_remove)++`]
* xref:#MultisigComponent-_replace_signer[`++_replace_signer(ref self, signer_to_remove, signer_to_add)++`]
* xref:#MultisigComponent-_change_quorum[`++_change_quorum(ref self, new_quorum)++`]
--

[.contract-index]
.Events
--
* xref:#MultisigComponent-SignerAdded[`++SignerAdded(signer)++`]
* xref:#MultisigComponent-SignerRemoved[`++SignerRemoved(signer)++`]
* xref:#MultisigComponent-QuorumUpdated[`++QuorumUpdated(old_quorum, new_quorum)++`]
* xref:#MultisigComponent-TransactionSubmitted[`++TransactionSubmitted(id, signer)++`]
* xref:#MultisigComponent-TransactionConfirmed[`++TransactionConfirmed(id, signer)++`]
* xref:#MultisigComponent-ConfirmationRevoked[`++ConfirmationRevoked(id, signer)++`]
* xref:#MultisigComponent-TransactionExecuted[`++TransactionExecuted(id)++`]
* xref:#MultisigComponent-CallSalt[`++CallSalt(id, salt)++`]
--

[#MultisigComponent-Functions]
==== Embeddable functions

[.contract-item]
[[MultisigComponent-get_quorum]]
==== `[.contract-item-name]#++get_quorum++#++(self: @ContractState) → u32++` [.item-kind]#external#

Returns the current quorum value.

[.contract-item]
[[MultisigComponent-is_signer]]
==== `[.contract-item-name]#++is_signer++#++(self: @ContractState, signer: ContractAddress) → bool++` [.item-kind]#external#

Checks if a given `signer` is registered.

[.contract-item]
[[MultisigComponent-get_signers]]
==== `[.contract-item-name]#++get_signers++#++(self: @ContractState) → Span<ContractAddress>++` [.item-kind]#external#

Returns a list of all current signers.

[.contract-item]
[[MultisigComponent-is_confirmed]]
==== `[.contract-item-name]#++is_confirmed++#++(self: @ContractState, id: TransactionID) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been confirmed. A confirmed transaction has received the required number of confirmations (quorum).

[.contract-item]
[[MultisigComponent-is_confirmed_by]]
==== `[.contract-item-name]#++is_confirmed_by++#++(self: @ContractState, id: TransactionID, signer: ContractAddress) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

[.contract-item]
[[MultisigComponent-is_executed]]
==== `[.contract-item-name]#++is_executed++#++(self: @ContractState, id: TransactionID) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been executed.

[.contract-item]
[[MultisigComponent-get_submitted_block]]
==== `[.contract-item-name]#++get_submitted_block++#++(self: @ContractState, id: TransactionID) → u64++` [.item-kind]#external#

Returns the block number when the transaction with the given `id` was submitted.

[.contract-item]
[[MultisigComponent-get_transaction_state]]
==== `[.contract-item-name]#++get_transaction_state++#++(self: @ContractState, id: TransactionID) → TransactionState++` [.item-kind]#external#

Returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.
- `Pending`: the transaction exists but hasn't reached the required confirmations.
- `Confirmed`: the transaction has reached the required confirmations but hasn't been executed.
- `Executed`: the transaction has been executed.

[.contract-item]
[[MultisigComponent-get_transaction_confirmations]]
==== `[.contract-item-name]#++get_transaction_confirmations++#++(self: @ContractState, id: TransactionID) → u32++` [.item-kind]#external#

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

[.contract-item]
[[MultisigComponent-hash_transaction]]
==== `[.contract-item-name]#++hash_transaction++#++(self: @ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#external#

Returns the computed identifier of a transaction containing a single call.

[.contract-item]
[[MultisigComponent-hash_transaction_batch]]
==== `[.contract-item-name]#++hash_transaction_batch++#++(self: @ContractState, calls: Span<Call>, salt: felt252)++` [.item-kind]#external#

Returns the computed identifier of a transaction containing a batch of calls.

[.contract-item]
[[MultisigComponent-add_signers]]
==== `[.contract-item-name]#++add_signers++#++(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)++` [.item-kind]#external#

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after addition.

Emits a {MultisigComponent-SignerAdded} event for each signer added.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-remove_signers]]
==== `[.contract-item-name]#++remove_signers++#++(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)++` [.item-kind]#external#

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after removal.

Emits a {MultisigComponent-SignerRemoved} event for each signer removed.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-replace_signer]]
==== `[.contract-item-name]#++replace_signer++#++(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)++` [.item-kind]#external#

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.
- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.

Emits a {MultisigComponent-SignerRemoved} event for the removed signer.

Emits a {MultisigComponent-SignerAdded} event for the new signer.

[.contract-item]
[[MultisigComponent-change_quorum]]
==== `[.contract-item-name]#++change_quorum++#++(ref self: ContractState, new_quorum: u32)++` [.item-kind]#external#

Updates the quorum value to `new_quorum`.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-submit_transaction]]
==== `[.contract-item-name]#++submit_transaction++#++(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#external#

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a {MultisigComponent-TransactionSubmitted} event.

Emits a {MultisigComponent-CallSalt} event if `salt` is not zero.

[.contract-item]
[[MultisigComponent-submit_transaction_batch]]
==== `[.contract-item-name]#++submit_transaction_batch++#++(ref self: ContractState, calls: Span<Call>, salt: felt252)++` [.item-kind]#external#

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a {MultisigComponent-TransactionSubmitted} event.

Emits a {MultisigComponent-CallSalt} event if `salt` is not zero.

[.contract-item]
[[MultisigComponent-confirm_transaction]]
==== `[.contract-item-name]#++confirm_transaction++#++(ref self: ContractState, id: TransactionID)++` [.item-kind]#external#

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.
- The transaction must exist and not be executed.
- The caller must not have already confirmed the transaction.

Emits a {MultisigComponent-TransactionConfirmed} event.

[.contract-item]
[[MultisigComponent-revoke_confirmation]]
==== `[.contract-item-name]#++revoke_confirmation++#++(ref self: ContractState, id: TransactionID)++` [.item-kind]#external#

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.
- The caller must have previously confirmed the transaction.

Emits a {MultisigComponent-ConfirmationRevoked} event.

[.contract-item]
[[MultisigComponent-execute_transaction]]
==== `[.contract-item-name]#++execute_transaction++#++(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#external#

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a {MultisigComponent-TransactionExecuted} event.

[.contract-item]
[[MultisigComponent-execute_transaction_batch]]
==== `[.contract-item-name]#++execute_transaction_batch++#++(ref self: ContractState, calls: Span<Call>, salt: felt252)++` [.item-kind]#external#

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a {MultisigComponent-TransactionExecuted} event.

[#MultisigComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[MultisigComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, quorum: u32, signers: Span<ContractAddress>)++` [.item-kind]#internal#

Initializes the Multisig component with the initial `quorum` and `signers`.
This function must be called during contract initialization to set up the initial state.

Requirements:

- `quorum` must be non-zero and less than or equal to the number of `signers`.

Emits a {MultisigComponent-SignerAdded} event for each signer added.

Emits a {MultisigComponent-QuorumUpdated} event.

[.contract-item]
[[MultisigComponent-resolve_tx_state]]
==== `[.contract-item-name]#++resolve_tx_state++#++(self: @ContractState, id: TransactionID) → TransactionState++` [.item-kind]#internal#

Resolves and returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.
- `Pending`: the transaction exists but hasn't reached the required confirmations.
- `Confirmed`: the transaction has reached the required confirmations but hasn't been executed.
- `Executed`: the transaction has been executed.

[.contract-item]
[[MultisigComponent-assert_one_of_signers]]
==== `[.contract-item-name]#++assert_one_of_signers++#++(self: @ContractState, caller: ContractAddress)++` [.item-kind]#internal#

Asserts that the `caller` is one of the registered signers.

Requirements:

- The `caller` must be a registered signer.

[.contract-item]
[[MultisigComponent-assert_tx_exists]]
==== `[.contract-item-name]#++assert_tx_exists++#++(self: @ContractState, id: TransactionID)++` [.item-kind]#internal#

Asserts that a transaction with the given `id` exists.

Requirements:

- The transaction with the given `id` must have been submitted.

[.contract-item]
[[MultisigComponent-assert_only_self]]
==== `[.contract-item-name]#++assert_only_self++#++(self: @ContractState)++` [.item-kind]#internal#

Asserts that the caller is the contract itself.

Requirements:

- The caller must be the contract's own address.

[.contract-item]
[[MultisigComponent-_add_signers]]
==== `[.contract-item-name]#++_add_signers++#++(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)++` [.item-kind]#internal#

Adds new signers and updates the quorum.

Requirements:

- Each signer address must be non-zero.
- `new_quorum` must be non-zero and less than or equal to the total number of signers after addition.

Emits a {MultisigComponent-SignerAdded} event for each new signer added.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-_remove_signers]]
==== `[.contract-item-name]#++_remove_signers++#++(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)++` [.item-kind]#internal#

Removes existing signers and updates the quorum.

Requirements:

- `new_quorum` must be non-zero and less than or equal to the total number of signers
after removal.

Emits a {MultisigComponent-SignerRemoved} event for each signer removed.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-_replace_signer]]
==== `[.contract-item-name]#++_replace_signer++#++(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)++` [.item-kind]#internal#

Replaces an existing signer with a new signer.

Requirements:

- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.
- `signer_to_add` must be a non-zero address.

Emits a {MultisigComponent-SignerRemoved} event for the removed signer.

Emits a {MultisigComponent-SignerAdded} event for the new signer.

[.contract-item]
[[MultisigComponent-_change_quorum]]
==== `[.contract-item-name]#++_change_quorum++#++(ref self: ContractState, new_quorum: u32)++` [.item-kind]#internal#

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[#MultisigComponent-Events]
==== Events

[.contract-item]
[[MultisigComponent-SignerAdded]]
==== `[.contract-item-name]#++SignerAdded++#++(signer: ContractAddress)++` [.item-kind]#event#

Emitted when a new `signer` is added.

[.contract-item]
[[MultisigComponent-SignerRemoved]]
==== `[.contract-item-name]#++SignerRemoved++#++(signer: ContractAddress)++` [.item-kind]#event#

Emitted when a `signer` is removed.

[.contract-item]
[[MultisigComponent-QuorumUpdated]]
==== `[.contract-item-name]#++QuorumUpdated++#++(old_quorum: u32, new_quorum: u32)++` [.item-kind]#event#

Emitted when the `quorum` value is updated.

[.contract-item]
[[MultisigComponent-TransactionSubmitted]]
==== `[.contract-item-name]#++TransactionSubmitted++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a new transaction is submitted by a `signer`.

[.contract-item]
[[MultisigComponent-TransactionConfirmed]]
==== `[.contract-item-name]#++TransactionConfirmed++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a transaction is confirmed by a `signer`.

[.contract-item]
[[MultisigComponent-ConfirmationRevoked]]
==== `[.contract-item-name]#++ConfirmationRevoked++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a `signer` revokes his confirmation.

[.contract-item]
[[MultisigComponent-TransactionExecuted]]
==== `[.contract-item-name]#++TransactionExecuted++#++(id: TransactionID)++` [.item-kind]#event#

Emitted when a transaction is executed.

[.contract-item]
[[MultisigComponent-CallSalt]]
==== `[.contract-item-name]#++CallSalt++#++(id: felt252, salt: felt252)++` [.item-kind]#event#

Emitted when a new transaction is submitted with non-zero salt.

== Timelock

In a governance system, `TimelockControllerComponent` is in charge of introducing a delay between a proposal and its execution.

[.contract]
[[ITimelock]]
=== `++ITimelock++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.19.0/packages/governance/src/timelock/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::timelock::interface::ITimelock;
```

Interface of a timelock contract.

[.contract-index]
.Functions
--
* xref:#ITimelock-is_operation[`++is_operation(id)++`]
* xref:#ITimelock-is_operation_pending[`++is_operation_pending(id)++`]
* xref:#ITimelock-is_operation_ready[`++is_operation_ready(id)++`]
* xref:#ITimelock-is_operation_done[`++is_operation_done(id)++`]
* xref:#ITimelock-get_timestamp[`++get_timestamp(id)++`]
* xref:#ITimelock-get_operation_state[`++get_operation_state(id)++`]
* xref:#ITimelock-get_min_delay[`++get_min_delay()++`]
* xref:#ITimelock-hash_operation[`++hash_operation(call, predecessor, salt)++`]
* xref:#ITimelock-hash_operation_batch[`++hash_operation_batch(calls, predecessor, salt)++`]
* xref:#ITimelock-schedule[`++schedule(call, predecessor, salt, delay)++`]
* xref:#ITimelock-schedule_batch[`++schedule_batch(calls, predecessor, salt, delay)++`]
* xref:#ITimelock-cancel[`++cancel(id)++`]
* xref:#ITimelock-execute[`++execute(call, predecessor, salt)++`]
* xref:#ITimelock-execute_batch[`++execute_batch(calls, predecessor, salt)++`]
* xref:#ITimelock-update_delay[`++update_delay(new_delay)++`]
--

[.contract-index]
.Events
--
* xref:#ITimelock-CallScheduled[`++CallScheduled(id, index, call, predecessor, delay)++`]
* xref:#ITimelock-CallExecuted[`++CallExecuted(id, index, call)++`]
* xref:#ITimelock-CallSalt[`++CallSalt(id, salt)++`]
* xref:#ITimelock-CallCancelled[`++CallCancelled(id)++`]
* xref:#ITimelock-MinDelayChanged[`++MinDelayChanged(old_duration, new_duration)++`]
--

[#ITimelock-Functions]
==== Functions

[.contract-item]
[[ITimelock-is_operation]]
==== `[.contract-item-name]#++is_operation++#++(id: felt252) → bool++` [.item-kind]#external#

Returns whether `id` corresponds to a registered operation.
This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

[.contract-item]
[[ITimelock-is_operation_pending]]
==== `[.contract-item-name]#++is_operation_pending++#++(id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is pending or not.
Note that a pending operation may be either `Waiting` or `Ready`.

[.contract-item]
[[ITimelock-is_operation_ready]]
==== `[.contract-item-name]#++is_operation_ready++#++(id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is `Ready` or not.

[.contract-item]
[[ITimelock-is_operation_done]]
==== `[.contract-item-name]#++is_operation_done++#++(id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is `Done` or not.

[.contract-item]
[[ITimelock-get_timestamp]]
==== `[.contract-item-name]#++get_timestamp++#++(id: felt252) → u64++` [.item-kind]#external#

Returns the timestamp at which `id` becomes `Ready`.

NOTE: `0` means the OperationState is `Unset` and `1` means the OperationState
is `Done`.

[.contract-item]
[[ITimelock-get_operation_state]]
==== `[.contract-item-name]#++get_operation_state++#++(id: felt252) → OperationState++` [.item-kind]#external#

Returns the OperationState for `id`.

[.contract-item]
[[ITimelock-get_min_delay]]
==== `[.contract-item-name]#++get_min_delay++#++() → u64++` [.item-kind]#external#

Returns the minimum delay in seconds for an operation to become valid.
This value can be changed by executing an operation that calls `update_delay`.

[.contract-item]
[[ITimelock-hash_operation]]
==== `[.contract-item-name]#++hash_operation++#++(call: Call, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Returns the identifier of an operation containing a single transaction.

[.contract-item]
[[ITimelock-hash_operation_batch]]
==== `[.contract-item-name]#++hash_operation_batch++#++(calls: Span<Call>, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Returns the identifier of an operation containing a batch of transactions.

[.contract-item]
[[ITimelock-schedule]]
==== `[.contract-item-name]#++schedule++#++(call: Call, predecessor: felt252, salt: felt252, delay: u64)++` [.item-kind]#external#

Schedule an operation containing a single transaction.

Requirements:

- the caller must have the `PROPOSER_ROLE` role.

Emits {CallScheduled} event.
If `salt` is not zero, emits {CallSalt} event.

[.contract-item]
[[ITimelock-schedule_batch]]
==== `[.contract-item-name]#++schedule_batch++#++(calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)++` [.item-kind]#external#

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

Emits one {CallScheduled} event for each transaction in the batch.
If `salt` is not zero, emits {CallSalt} event.

[.contract-item]
[[ITimelock-cancel]]
==== `[.contract-item-name]#++cancel++#++(id: felt252)++` [.item-kind]#external#

Cancel an operation.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.
- `id` must be an operation.

Emits a {CallCancelled} event.

[.contract-item]
[[ITimelock-execute]]
==== `[.contract-item-name]#++execute++#++(call: Call, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a {CallExecuted} event.

NOTE: This function can reenter, but it doesn't pose a risk because <<TimelockControllerComponent-_after_call>>
checks that the proposal is pending, thus any modifications to the operation during
reentrancy should be caught.

[.contract-item]
[[ITimelock-execute_batch]]
==== `[.contract-item-name]#++execute_batch++#++(calls: Span<Call>, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a {CallExecuted} event for each Call.

NOTE: This function can reenter, but it doesn't pose a risk because `_after_call`
checks that the proposal is pending, thus any modifications to the operation during
reentrancy should be caught.

[.contract-item]
[[ITimelock-update_delay]]
==== `[.contract-item-name]#++update_delay++#++(new_delay: u64)++` [.item-kind]#external#

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling
and later executing an operation where the timelock is the target and the data
is the serialized call to this function.

Emits a {MinDelayChanged} event.

[#ITimelock-Events]
==== Events

[.contract-item]
[[ITimelock-CallScheduled]]
==== `[.contract-item-name]#++CallScheduled++#++(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)++` [.item-kind]#event#

Emitted when `call` is scheduled as part of operation `id`.

[.contract-item]
[[ITimelock-CallExecuted]]
==== `[.contract-item-name]#++CallExecuted++#++(id: felt252, index: felt252, call: Call)++` [.item-kind]#event#

Emitted when `call` is performed as part of operation `id`.

[.contract-item]
[[ITimelock-CallSalt]]
==== `[.contract-item-name]#++CallSalt++#++(id: felt252, salt: felt252)++` [.item-kind]#event#

Emitted when a new proposal is scheduled with non-zero salt.

[.contract-item]
[[ITimelock-CallCancelled]]
==== `[.contract-item-name]#++CallCancelled++#++(id: felt252)++` [.item-kind]#event#

Emitted when operation `id` is cancelled.

[.contract-item]
[[ITimelock-MinDelayChanged]]
==== `[.contract-item-name]#++MinDelayChanged++#++(old_duration: u64, new_duration: u64)++` [.item-kind]#event#

Emitted when the minimum delay for future operations is modified.

[.contract]
[[TimelockControllerComponent]]
=== `++TimelockControllerComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.19.0/packages/governance/src/timelock/timelock_controller.cairo[{github-icon},role=heading-link]

include::../utils/_common.adoc[]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::timelock::TimelockControllerComponent;
```

Component that implements <<ITimelock, ITimelock>> and enables the implementing contract to act as a timelock controller.

[.contract-index#TimelockControllerComponent-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.TimelockMixinImpl

* xref:#TimelockControllerComponent-Embeddable-Impls-TimelockImpl[`++TimelockImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
* xref:api/access.adoc#AccessControlComponent-Embeddable-Impls[`++AccessControlImpl++`]
* xref:api/access.adoc#AccessControlComponent-Embeddable-Impls[`++AccessControlCamelImpl++`]
--

[.contract-index#TimelockControllerComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#TimelockControllerComponent-Embeddable-Impls-TimelockImpl]
.TimelockImpl

* xref:#TimelockControllerComponent-is_operation[`++is_operation(id)++`]
* xref:#TimelockControllerComponent-is_operation_pending[`++is_operation_pending(id)++`]
* xref:#TimelockControllerComponent-is_operation_ready[`++is_operation_ready(id)++`]
* xref:#TimelockControllerComponent-is_operation_done[`++is_operation_done(id)++`]
* xref:#TimelockControllerComponent-get_timestamp[`++get_timestamp(id)++`]
* xref:#TimelockControllerComponent-get_operation_state[`++get_operation_state(id)++`]
* xref:#TimelockControllerComponent-get_min_delay[`++get_min_delay()++`]
* xref:#TimelockControllerComponent-hash_operation[`++hash_operation(call, predecessor, salt)++`]
* xref:#TimelockControllerComponent-hash_operation_batch[`++hash_operation_batch(calls, predecessor, salt)++`]
* xref:#TimelockControllerComponent-schedule[`++schedule(call, predecessor, salt, delay)++`]
* xref:#TimelockControllerComponent-schedule_batch[`++schedule_batch(calls, predecessor, salt, delay)++`]
* xref:#TimelockControllerComponent-cancel[`++cancel(id)++`]
* xref:#TimelockControllerComponent-execute[`++execute(call, predecessor, salt)++`]
* xref:#TimelockControllerComponent-execute_batch[`++execute_batch(calls, predecessor, salt)++`]
* xref:#TimelockControllerComponent-update_delay[`++update_delay(new_delay)++`]

.SRC5Impl
* xref:api/introspection.adoc#ISRC5-supports_interface[`supports_interface(self, interface_id: felt252)`]

.AccessControlImpl
* xref:api/access.adoc#IAccessControl-has_role[`++has_role(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-get_role_admin[`++get_role_admin(self, role)++`]
* xref:api/access.adoc#IAccessControl-grant_role[`++grant_role(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-revoke_role[`++revoke_role(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-renounce_role[`++renounce_role(self, role, account)++`]

.AccessControlCamelImpl
* xref:api/access.adoc#IAccessControl-hasRole[`++hasRole(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-getRoleAdmin[`++getRoleAdmin(self, role)++`]
* xref:api/access.adoc#IAccessControl-grantRole[`++grantRole(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-revokeRole[`++revokeRole(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-renounceRole[`++renounceRole(self, role, account)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#TimelockControllerComponent-initializer[`++initializer(self, min_delay, proposers, executors, admin)++`]
* xref:#TimelockControllerComponent-assert_only_role[`++assert_only_role(self, role)++`]
* xref:#TimelockControllerComponent-assert_only_role_or_open_role[`++assert_only_role_or_open_role(self, role)++`]
* xref:#TimelockControllerComponent-assert_only_self[`++assert_only_self(self)++`]
* xref:#TimelockControllerComponent-_before_call[`++_before_call(self, id, predecessor)++`]
* xref:#TimelockControllerComponent-_after_call[`++_after_call(self, id)++`]
* xref:#TimelockControllerComponent-_schedule[`++_schedule(self, id, delay)++`]
* xref:#TimelockControllerComponent-_execute[`++_execute(self, call)++`]
--

[.contract-index]
.Events
--
* xref:#TimelockControllerComponent-CallScheduled[`++CallScheduled(id, index, call, predecessor, delay)++`]
* xref:#TimelockControllerComponent-CallExecuted[`++CallExecuted(id, index, call)++`]
* xref:#TimelockControllerComponent-CallSalt[`++CallSalt(id, salt)++`]
* xref:#TimelockControllerComponent-CallCancelled[`++CallCancelled(id)++`]
* xref:#TimelockControllerComponent-MinDelayChanged[`++MinDelayChanged(old_duration, new_duration)++`]
--

[#TimelockControllerComponent-Functions]
==== Functions

[.contract-item]
[[TimelockControllerComponent-is_operation]]
==== `[.contract-item-name]#++is_operation++#++(self: @ContractState, id: felt252) → bool++` [.item-kind]#external#

Returns whether `id` corresponds to a registered operation.
This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

[.contract-item]
[[TimelockControllerComponent-is_operation_pending]]
==== `[.contract-item-name]#++is_operation_pending++#++(self: @ContractState, id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is pending or not.
Note that a pending operation may be either `Waiting` or `Ready`.

[.contract-item]
[[TimelockControllerComponent-is_operation_ready]]
==== `[.contract-item-name]#++is_operation_ready++#++(self: @ContractState, id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is `Ready` or not.

[.contract-item]
[[TimelockControllerComponent-is_operation_done]]
==== `[.contract-item-name]#++is_operation_done++#++(self: @ContractState, id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is `Done` or not.

[.contract-item]
[[TimelockControllerComponent-get_timestamp]]
==== `[.contract-item-name]#++get_timestamp++#++(self: @ContractState, id: felt252) → u64++` [.item-kind]#external#

Returns the timestamp at which `id` becomes `Ready`.

NOTE: `0` means the OperationState is `Unset` and `1` means the OperationState
is `Done`.

[.contract-item]
[[TimelockControllerComponent-get_operation_state]]
==== `[.contract-item-name]#++get_operation_state++#++(self: @ContractState, id: felt252) → OperationState++` [.item-kind]#external#

Returns the OperationState for `id`.

[.contract-item]
[[TimelockControllerComponent-get_min_delay]]
==== `[.contract-item-name]#++get_min_delay++#++(self: @ContractState) → u64++` [.item-kind]#external#

Returns the minimum delay in seconds for an operation to become valid.
This value can be changed by executing an operation that calls `update_delay`.

[.contract-item]
[[TimelockControllerComponent-hash_operation]]
==== `[.contract-item-name]#++hash_operation++#++(self: @ContractState, call: Call, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Returns the identifier of an operation containing a single transaction.

[.contract-item]
[[TimelockControllerComponent-hash_operation_batch]]
==== `[.contract-item-name]#++hash_operation_batch++#++(self: @ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Returns the identifier of an operation containing a batch of transactions.

[.contract-item]
[[TimelockControllerComponent-schedule]]
==== `[.contract-item-name]#++schedule++#++(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252, delay: u64)++` [.item-kind]#external#

Schedule an operation containing a single transaction.

Requirements:

- the caller must have the `PROPOSER_ROLE` role.

Emits {CallScheduled} event.
If `salt` is not zero, emits {CallSalt} event.

[.contract-item]
[[TimelockControllerComponent-schedule_batch]]
==== `[.contract-item-name]#++schedule_batch++#++(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)++` [.item-kind]#external#

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

Emits one {CallScheduled} event for each transaction in the batch.
If `salt` is not zero, emits {CallSalt} event.

[.contract-item]
[[TimelockControllerComponent-cancel]]
==== `[.contract-item-name]#++cancel++#++(ref self: ContractState, id: felt252)++` [.item-kind]#external#

Cancel an operation.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.
- `id` must be an operation.

Emits a {CallCancelled} event.

[.contract-item]
[[TimelockControllerComponent-execute]]
==== `[.contract-item-name]#++execute++#++(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a {CallExecuted} event.

NOTE: This function can reenter, but it doesn't pose a risk because <<TimelockControllerComponent-_after_call>>
checks that the proposal is pending, thus any modifications to the operation during
reentrancy should be caught.

[.contract-item]
[[TimelockControllerComponent-execute_batch]]
==== `[.contract-item-name]#++execute_batch++#++(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a {CallExecuted} event for each Call.

NOTE: This function can reenter, but it doesn't pose a risk because `_after_call`
checks that the proposal is pending, thus any modifications to the operation during
reentrancy should be caught.

[.contract-item]
[[TimelockControllerComponent-update_delay]]
==== `[.contract-item-name]#++update_delay++#++(ref self: ContractState, new_delay: u64)++` [.item-kind]#external#

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling
and later executing an operation where the timelock is the target and the data
is the serialized call to this function.

Emits a {MinDelayChanged} event.

[#TimelockControllerComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[TimelockControllerComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, min_delay: u64, proposers: Span<ContractAddress>, executors: Span<ContractState>, admin: ContractAddress)++` [.item-kind]#internal#

Initializes the contract by registering support for SRC5 and AccessControl.

This function also configures the contract with the following parameters:

- `min_delay`: initial minimum delay in seconds for operations.
- `proposers`: accounts to be granted proposer and canceller roles.
- `executors`: accounts to be granted executor role.
- `admin`: optional account to be granted admin role; disable with zero address.

WARNING: The optional admin can aid with initial configuration of roles after deployment
without being subject to delay, but this role should be subsequently renounced in favor of
administration through timelocked proposals.

Emits two {RoleGranted} events for each account in `proposers` with `PROPOSER_ROLE` and
`CANCELLER_ROLE` roles.

Emits a {RoleGranted} event for each account in `executors` with `EXECUTOR_ROLE` role.

May emit a {RoleGranted} event for `admin` with `DEFAULT_ADMIN_ROLE` role (if `admin` is
not zero).

Emits {MinDelayChanged} event.

[.contract-item]
[[TimelockControllerComponent-assert_only_role]]
==== `[.contract-item-name]#++assert_only_role++#++(self: @ContractState, role: felt252)++` [.item-kind]#internal#

Validates that the caller has the given `role`.
Otherwise it panics.

[.contract-item]
[[TimelockControllerComponent-assert_only_role_or_open_role]]
==== `[.contract-item-name]#++assert_only_role_or_open_role++#++(self: @ContractState, role: felt252)++` [.item-kind]#internal#

Validates that the caller has the given `role`.
If `role` is granted to the zero address, then this is considered an open role which allows anyone to be the caller.

[.contract-item]
[[TimelockControllerComponent-assert_only_self]]
==== `[.contract-item-name]#++assert_only_self++#++(self: @ContractState)++` [.item-kind]#internal#

Validates that the caller is the timelock contract itself.
Otherwise it panics.

[.contract-item]
[[TimelockControllerComponent-_before_call]]
==== `[.contract-item-name]#++_before_call++#++(self: @ContractState, id: felt252, predecessor: felt252)++` [.item-kind]#internal#

Private function that checks before execution of an operation's calls.

Requirements:

- `id` must be in the `Ready` OperationState.
- `predecessor` must either be zero or be in the `Done` OperationState.

[.contract-item]
[[TimelockControllerComponent-_after_call]]
==== `[.contract-item-name]#++_after_call++#++(self: @ContractState, id: felt252)++` [.item-kind]#internal#

Private function that checks after execution of an operation's calls
and sets the OperationState of `id` to `Done`.

Requirements:

- `id` must be in the Ready OperationState.

[.contract-item]
[[TimelockControllerComponent-_schedule]]
==== `[.contract-item-name]#++_schedule++#++(ref self: ContractState, id: felt252, delay: u64)++` [.item-kind]#internal#

Private function that schedules an operation that is to become valid after a given `delay`.

[.contract-item]
[[TimelockControllerComponent-_execute]]
==== `[.contract-item-name]#++_execute++#++(ref self: ContractState, call: Call)++` [.item-kind]#internal#

Private function that executes an operation's calls.

[#TimelockControllerComponent-Events]
==== Events

[.contract-item]
[[TimelockControllerComponent-CallScheduled]]
==== `[.contract-item-name]#++CallScheduled++#++(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)++` [.item-kind]#event#

Emitted when `call` is scheduled as part of operation `id`.

[.contract-item]
[[TimelockControllerComponent-CallExecuted]]
==== `[.contract-item-name]#++CallExecuted++#++(id: felt252, index: felt252, call: Call)++` [.item-kind]#event#

Emitted when `call` is performed as part of operation `id`.

[.contract-item]
[[TimelockControllerComponent-CallSalt]]
==== `[.contract-item-name]#++CallSalt++#++(id: felt252, salt: felt252)++` [.item-kind]#event#

Emitted when a new proposal is scheduled with non-zero salt.

[.contract-item]
[[TimelockControllerComponent-CallCancelled]]
==== `[.contract-item-name]#++CallCancelled++#++(id: felt252)++` [.item-kind]#event#

Emitted when operation `id` is cancelled.

[.contract-item]
[[TimelockControllerComponent-MinDelayChanged]]
==== `[.contract-item-name]#++MinDelayChanged++#++(old_duration: u64, new_duration: u64)++` [.item-kind]#event#

Emitted when the minimum delay for future operations is modified.

== Votes

The `VotesComponent` provides a flexible system for tracking and delegating voting power. This system allows users to delegate their voting power to other addresses, enabling more active participation in governance.

[.contract]
[[IVotes]]
=== `++IVotes++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.19.0/packages/governance/src/votes/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::votes::interface::IVotes;
```

Common interface for Votes-enabled contracts.

[.contract-index]
.Functions
--
* xref:#IVotes-get_votes[`++get_votes(account)++`]
* xref:#IVotes-get_past_votes[`++get_past_votes(account, timepoint)++`]
* xref:#IVotes-get_past_total_supply[`++get_past_total_supply(timepoint)++`]
* xref:#IVotes-delegates[`++delegates(account)++`]
* xref:#IVotes-delegate[`++delegate(delegatee)++`]
* xref:#IVotes-delegate_by_sig[`++delegate_by_sig(delegator, delegatee, nonce, expiry, signature)++`]
--

[#IVotes-Functions]
==== Functions

[.contract-item]
[[IVotes-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(account: ContractAddress) → u256++` [.item-kind]#external#

Returns the current amount of votes that `account` has.

[.contract-item]
[[IVotes-get_past_votes]]
==== `[.contract-item-name]#++get_past_votes++#++(account: ContractAddress, timepoint: u64) → u256++` [.item-kind]#external#

Returns the amount of votes that `account` had at a specific moment in the past.

[.contract-item]
[[IVotes-get_past_total_supply]]
==== `[.contract-item-name]#++get_past_total_supply++#++(timepoint: u64) → u256++` [.item-kind]#external#

Returns the total supply of votes available at a specific moment in the past.

NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.
Votes that have not been delegated are still part of total supply, even though they would not participate in a
vote.

[.contract-item]
[[IVotes-delegates]]
==== `[.contract-item-name]#++delegates++#++(account: ContractAddress) → ContractAddress++` [.item-kind]#external#

Returns the delegate that `account` has chosen.

[.contract-item]
[[IVotes-delegate]]
==== `[.contract-item-name]#++delegate++#++(delegatee: ContractAddress)++` [.item-kind]#external#

Delegates votes from the sender to `delegatee`.

[.contract-item]
[[IVotes-delegate_by_sig]]
==== `[.contract-item-name]#++delegate_by_sig++#++(delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)++` [.item-kind]#external#

Delegates votes from `delegator` to `delegatee` through a SNIP12 message signature validation.

[.contract]
[[VotesComponent]]
=== `++VotesComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.19.0/packages/governance/src/votes/votes.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::votes::VotesComponent;
```
Component that implements the {IVotes} interface and provides a flexible system for tracking and delegating voting power.

By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.

NOTE: When using this module, your contract must implement the {VotingUnitsTrait}. For convenience, this is done automatically for `ERC20` and `ERC721` tokens.

[.contract-index]
.Voting Units Trait Implementations
--
.ERC20VotesImpl
* xref:#VotesComponent-ERC20VotesImpl-get_voting_units[`++get_voting_units(self, account)++`]

.ERC721VotesImpl
* xref:#VotesComponent-ERC721VotesImpl-get_voting_units[`++get_voting_units(self, account)++`]
--

[.contract-index#VotesComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#VotesComponent-Embeddable-Impls-VotesImpl]
.VotesImpl
* xref:#VotesComponent-get_votes[`++get_votes(self, account)++`]
* xref:#VotesComponent-get_past_votes[`++get_past_votes(self, account, timepoint)++`]
* xref:#VotesComponent-get_past_total_supply[`++get_past_total_supply(self, timepoint)++`]
* xref:#VotesComponent-delegates[`++delegates(self, account)++`]
* xref:#VotesComponent-delegate[`++delegate(self, delegatee)++`]
* xref:#VotesComponent-delegate_by_sig[`++delegate_by_sig(self, delegator, delegatee, nonce, expiry, signature)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl
* xref:#VotesComponent-get_total_supply[`++get_total_supply(self)++`]
* xref:#VotesComponent-move_delegate_votes[`++move_delegate_votes(self, from, to, amount)++`]
* xref:#VotesComponent-transfer_voting_units[`++transfer_voting_units(self, from, to, amount)++`]
* xref:#VotesComponent-num_checkpoints[`++num_checkpoints(self, account)++`]
* xref:#VotesComponent-checkpoints[`++checkpoints(self, account, pos)++`]
* xref:#VotesComponent-_delegate[`++_delegate(self, account, delegatee)++`]
--

[.contract-index]
.Events
--
* xref:#VotesComponent-DelegateChanged[`++DelegateChanged(delegator, from_delegate, to_delegate)++`]
* xref:#VotesComponent-DelegateVotesChanged[`++DelegateVotesChanged(delegate, previous_votes, new_votes)++`]
--

[#VotesComponent-ERC20VotesImpl]
==== ERC20VotesImpl

[.contract-item]
[[VotesComponent-ERC20VotesImpl-get_voting_units]]
==== `[.contract-item-name]#++get_voting_units++#++(self: @ComponentState<TContractState>, account: ContractAddress) → u256++` [.item-kind]#internal#

Returns the number of voting units for a given account.

This implementation is specific to ERC20 tokens, where the balance
of tokens directly represents the number of voting units.

NOTE: This implementation will work out of the box if the ERC20 component
is implemented in the final contract.

WARNING: This implementation assumes tokens map to voting units 1:1.
Any deviation from this formula when transferring voting units (e.g. by using hooks)
may compromise the internal vote accounting.

[#VotesComponent-ERC721VotesImpl]
==== ERC721VotesImpl

[.contract-item]
[[VotesComponent-ERC721VotesImpl-get_voting_units]]
==== `[.contract-item-name]#++get_voting_units++#++(self: @ComponentState<TContractState>, account: ContractAddress) → u256++` [.item-kind]#internal#

Returns the number of voting units for a given account.

This implementation is specific to ERC721 tokens, where each token
represents one voting unit. The function returns the balance of
ERC721 tokens for the specified account.

NOTE: This implementation will work out of the box if the ERC721 component
is implemented in the final contract.

WARNING: This implementation assumes tokens map to voting units 1:1.
Any deviation from this formula when transferring voting units (e.g. by using hooks)
may compromise the internal vote accounting.

[#VotesComponent-Functions]
==== Functions

[.contract-item]
[[VotesComponent-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(self: @ComponentState<TContractState>, account: ContractAddress) → u256++` [.item-kind]#external#

Returns the current amount of votes that `account` has.

[.contract-item]
[[VotesComponent-get_past_votes]]
==== `[.contract-item-name]#++get_past_votes++#++(self: @ComponentState<TContractState>, account: ContractAddress, timepoint: u64) → u256++` [.item-kind]#external#

Returns the amount of votes that `account` had at a specific moment in the past.

Requirements:

- `timepoint` must be in the past.

[.contract-item]
[[VotesComponent-get_past_total_supply]]
==== `[.contract-item-name]#++get_past_total_supply++#++(self: @ComponentState<TContractState>, timepoint: u64) → u256++` [.item-kind]#external#

Returns the total supply of votes available at a specific moment in the past.

NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.
Votes that have not been delegated are still part of total supply, even though they would not participate in a
vote.

Requirements:

- `timepoint` must be in the past.

[.contract-item]
[[VotesComponent-delegates]]
==== `[.contract-item-name]#++delegates++#++(self: @ComponentState<TContractState>, account: ContractAddress) → ContractAddress++` [.item-kind]#external#

Returns the delegate that `account` has chosen.

[.contract-item]
[[VotesComponent-delegate]]
==== `[.contract-item-name]#++delegate++#++(ref self: ComponentState<TContractState>, delegatee: ContractAddress)++` [.item-kind]#external#

Delegates votes from the sender to `delegatee`.

Emits a {DelegateChanged} event.

May emit one or two {DelegateVotesChanged} events.

[.contract-item]
[[VotesComponent-delegate_by_sig]]
==== `[.contract-item-name]#++delegate_by_sig++#++(ref self: ComponentState<TContractState>, delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)++` [.item-kind]#external#

Delegates votes from `delegator` to `delegatee` through a SNIP12 message signature validation.

Requirements:

- `expiry` must not be in the past.
- `nonce` must match the account's current nonce.
- `delegator` must implement `SRC6::is_valid_signature`.
- `signature` should be valid for the message hash.

Emits a {DelegateChanged} event.

May emit one or two {DelegateVotesChanged} events.

[#VotesComponent-Internal-functions]
==== Internal functions

[.contract-item]
[[VotesComponent-get_total_supply]]
==== `[.contract-item-name]#++get_total_supply++#++(self: @ComponentState<TContractState>) → u256++` [.item-kind]#internal#

Returns the current total supply of votes.

[.contract-item]
[[VotesComponent-move_delegate_votes]]
==== `[.contract-item-name]#++move_delegate_votes++#++(ref self: ComponentState<TContractState>, from: ContractAddress, to: ContractAddress, amount: u256)++` [.item-kind]#internal#

Moves delegated votes from one delegate to another.

May emit one or two {DelegateVotesChanged} events.

[.contract-item]
[[VotesComponent-transfer_voting_units]]
==== `[.contract-item-name]#++transfer_voting_units++#++(ref self: ComponentState<TContractState>, from: ContractAddress, to: ContractAddress, amount: u256)++` [.item-kind]#internal#

Transfers, mints, or burns voting units.

To register a mint, `from` should be zero. To register a burn, `to`
should be zero. Total supply of voting units will be adjusted with mints and burns.

WARNING: If voting units are based on an underlying transferable asset (like a token), you must call this function every time the asset is transferred to keep the internal voting power accounting in sync. For ERC20 and ERC721 tokens, this is typically handled using hooks.

May emit one or two {DelegateVotesChanged} events.

[.contract-item]
[[VotesComponent-num_checkpoints]]
==== `[.contract-item-name]#++num_checkpoints++#++(self: @ComponentState<TContractState>, account: ContractAddress) → u64++` [.item-kind]#internal#

Returns the number of checkpoints for `account`.

[.contract-item]
[[VotesComponent-checkpoints]]
==== `[.contract-item-name]#++checkpoints++#++(self: @ComponentState<TContractState>, account: ContractAddress, pos: u64) → Checkpoint++` [.item-kind]#internal#

Returns the `pos`-th checkpoint for `account`.

[.contract-item]
[[VotesComponent-_delegate]]
==== `[.contract-item-name]#++_delegate++#++(ref self: ComponentState<TContractState>, account: ContractAddress, delegatee: ContractAddress)++` [.item-kind]#internal#

Delegates all of ``account``'s voting units to `delegatee`.

Emits a {DelegateChanged} event.

May emit one or two {DelegateVotesChanged} events.

[#VotesComponent-Events]
==== Events

[.contract-item]
[[VotesComponent-DelegateChanged]]
==== `[.contract-item-name]#++DelegateChanged++#++(delegator: ContractAddress, from_delegate: ContractAddress, to_delegate: ContractAddress)++` [.item-kind]#event#

Emitted when an account changes their delegate.

[.contract-item]
[[VotesComponent-DelegateVotesChanged]]
==== `[.contract-item-name]#++DelegateVotesChanged++#++(delegate: ContractAddress, previous_votes: u256, new_votes: u256)++` [.item-kind]#event#

Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.

[.contract]
[[VotingUnitsTrait]]
=== `++VotingUnitsTrait++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.19.0/packages/governance/src/votes/votes.cairo[{github-icon},role=heading-link]

```cairo
pub trait VotingUnitsTrait<TState> {
    fn get_voting_units(self: @TState, account: ContractAddress) -> u256;
}
```

A trait that must be implemented when integrating {VotesComponent} into a contract. It offers a mechanism to retrieve the number of voting units for a given account at the current time.

[.contract-index]
.Functions
--
* xref:#VotingUnitsTrait-get_voting_units[`++get_voting_units(self, account)++`]
--

[#VotingUnitsTrait-Functions]
==== Functions

[.contract-item]
[[VotingUnitsTrait-get_voting_units]]
==== `[.contract-item-name]#++get_voting_units++#++(self: @TState, account: ContractAddress) → u256++` [.item-kind]#external#

Returns the number of voting units for a given account. For ERC20, this is typically the token balance. For ERC721, this is typically the number of tokens owned.

WARNING: While any formula can be used as a measure of voting units, the internal vote accounting of the contract may be
compromised if voting units are transferred in any external flow by following a different formula. +
For example, when implementing the hook for ERC20, the number of voting units transferred should match the formula given by the
`get_voting_units` implementation.