= Usage

The following documentation provides reasoning and examples on how to use Contracts for Cairo components.

== Components

:shamans-post: https://community.starknet.io/t/cairo-components/101136#components-1[Starknet Shamans post]

Starknet components are separate modules that contain storage, events, and implementations that can be integrated into a contract.
Components themselves cannot be declared or deployed.
Another way to think of components is that they are abstract modules that must be instantiated.

TIP: For more information on the construction and design of Starknet components, see the {shamans-post}.

== Building a contract

:initializable-component: xref:/security.adoc#initializable[InitializableComponent]

The contract should first import the component and declare it with the `component!` macro:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    // Import the component
    use openzeppelin::security::InitializableComponent;

    // Declare the component
    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);
}
----

The `path` argument should be the imported component itself (in this case, {initializable-component}).
Notice that the `storage` and `event` arguments are representations set within the macro.
In other words, the `initializable` and `InitializableEvent` names follow this library's convention, but they can be renamed.

=== Component storage and events

The component's storage and events must be added to the contract's `Storage` struct and `Event` enum respectively.
If the component doesn't define any events, the compiler will still create an empty event enum inside the component module.

[,javascript]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin::security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }

    (...)
}
----

The `#[substorage(v0)]` attribute must be included for each component in the `Storage` trait.
This allows the contract to have indirect access to the component's storage.

The `#[flat]` attribute for events in the `Event` enum, however, is not required.
Component events are not flattened in the component itself because it would remove the event ID from the event log.
Note that if contracts do not flatten component events, the first key in the event log will be the component ID.
By flattening the component event in the contract, the first key will be the event ID.

=== Integrating implementations

:accessing-storage: xref:/usage.adoc#accessing_component_storage[Accessing component storage]

Components come with granular implementations of different interfaces.
This allows contracts to integrate only the implementations that they'll use and avoid unnecessary bloat.
Integrating an implementation looks like this:

[,javascript]
----
mod MyContract {
    use openzeppelin::security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    // Gives the contract access to the implementation methods
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
----

Defining an `impl` gives the contract access to the methods within the implementation from the component.
For example, `is_initialized` is defined in the `InitializableImpl`.
A function on the contract level can expose it like this:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin::security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;

    #[external(v0)]
    fn is_initialized(ref self: ContractState) -> bool {
        self.initializable.is_initialized()
    }
}
----

Notice that the function must pass the state (`self`) and the component's storage (`initializable`) before finally accessing the implementation method.

NOTE: Contracts can also (indirectly) access a component's storage. See {accessing-storage}.

=== Embedding implementations

While there's nothing wrong with manually exposing methods like in the previous example, this process can be tedious for implementations with many methods.
Fortunately, a contract can embed implementations into the ABI which will expose the methods of the implementation.
To embed an implementation, add the `#[abi(embed_v0)]` attribute above the `impl`:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    (...)

    // This attribute exposes the methods of the `impl`
    #[abi(embed_v0)]
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
----

`InitializableImpl` defines the `is_initialized` method in the component.
By adding the embed attribute, `is_initialized` becomes a contract entrypoint for `MyContract`.

=== Using component initializers

WARNING: Failing to use a component's `initializer` can result in irreparable contract deployments.
Always read the API documentation for each integrated component.

Some components require some sort of setup upon construction.
Usually, this would be a job for a constructor; however, components themselves cannot provide constructors.
Components instead offer ``initializer``s within their `InterlImpl` which enables a contract to create a constructor and invoke the component's `initializer`.
Let's look at how a contract would integrate `OwnableComponent`:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin::access::ownable::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        // Invoke ownable's `initializer`
        self.ownable.initializer(owner);
    }
}
----

== Custom implementations

:erc20-component: xref:/api/erc20.adoc#ERC20Component[ERC20Component]
:decimals: xref:/api/erc20.adoc#IERC20Metadata-decimals[decimals]
:ierc20metadata: xref:/api/erc20.adoc#IERC20Metadata[IERC20Metadata]
:custom-decimals: xref:/erc20.adoc#customizing_decimals[Customizing decimals]

There may be instances where a contract requires different behavior in a component implementation.
In {erc20-component}, for example, the `ERC20MetadataImpl` provides a static {decimals} method which returns`18`.
If a contract wanted to make the `decimals` method dynamic, the `impl` can no longer be embedded.
Rather, the contract would have to create its own `impl` of the {ierc20metadata} interface and expose it in the contract.

TIP: {custom-decimals} provides a guide for this exact scenario.

== Accessing component storage

WARNING: Writing to component storage can easily corrupt the state, bypass security checks, and undermine the component logic.
*Exercise extreme caution*.

Just as contracts can access methods within a component implementation, contracts can also access component storage.
Storage members are accessible to the contract by instantiating the component's `InternalImpl` like this:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    (...)

    impl InternalImpl = InitializableComponent::InternalImpl<ContractState>;

    fn write_to_comp_storage(self: @ContractState) -> bool {
        self.initializable.Initializable_initialized.write(true);
    }

    fn read_from_comp_storage(self: @ContractState) -> bool {
        self.initializable.Initializable_initialized.read()
    }
}
----

== Component dependencies

:access-component: xref:/api/access.adoc#AccessControlComponent[AccessControlComponent]
:src5-component: xref:/api/introspection.adoc#SRC5Component[SRC5Component]

Some components include dependencies of other components.
Contracts that integrate components with dependencies must also include the component dependency.
For instance, {access-component} depends on {src5-component}.
Creating a contract with `AccessControlComponent` should look like this:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin::access::accesscontrol::AccessControlComponent;
    use openzeppelin::introspection::src5::SRC5Component;

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    #[abi(embed_v0)]
    impl AccessControlCamelImpl =
        AccessControlComponent::AccessControlCamelImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    (...)
}
----
