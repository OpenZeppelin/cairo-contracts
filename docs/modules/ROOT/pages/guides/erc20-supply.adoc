= Creating ERC20 Supply

:eip-20: https://eips.ethereum.org/EIPS/eip-20[EIP20]

The standard interface implemented by tokens built on Starknet comes from the popular token standard on Ethereum called ERC20.
{eip-20}, from which ERC20 contracts are derived, does not specify how tokens are created.
This guide will go over strategies for creating both a fixed and dynamic token supply.

== Fixed Supply

Let's say we want to create a token named `MyToken` with a fixed token supply.
We can achieve this by setting the token supply in the constructor which will execute upon deployment.

[,javascript]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin::token::erc20::ERC20 as erc20_component;
    use starknet::ContractAddress;

    component!(path: erc20_component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl ERC20Impl = erc20_component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = erc20_component::ERC20MetadataImpl<ContractState>;
    impl InternalImpl = erc20_component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: erc20_component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        ERC20Event: erc20_component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        let name = 'MyToken';
        let symbol = 'MTK';

        self.erc20.initializer(name, symbol);
        self.erc20._mint(recipient, initial_supply);
    }
}
----

In the constructor, we're first calling the ERC20 initializer to set the token name and symbol.
Next, we're calling the internal `_mint` function which creates `initial_supply` of tokens and allocates them to `recipient`.
Since the internal `_mint` is not exposed in our contract, it will not be possible to create any more tokens.
In other words, we've implemented a fixed token supply!

== Dynamic Supply

:access-control: xref:/access.adoc[Access Control]

ERC20 contracts with a dynamic supply include a mechanism for creating or destroying tokens.
Let's make a few changes to the almighty `MyToken` contract and create a minting mechanism.

[,javascript]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin::token::erc20::ERC20 as erc20_component;
    use starknet::ContractAddress;

    component!(path: erc20_component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl ERC20Impl = erc20_component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = erc20_component::ERC20MetadataImpl<ContractState>;
    impl InternalImpl = erc20_component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: erc20_component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        ERC20Event: erc20_component::Event
    }

    #[constructor]
    fn constructor(self: @ContractState) {
        let name = 'MyToken';
        let symbol = 'MTK';

        self.erc20.initializer(name, symbol);
    }

    #[external(v0)]
    fn mint(
        self: @ContractState,
        recipient: ContractAddress,
        amount: u256
    ) {
        // This function is NOT protected which means
        // ANYONE can mint tokens
        self.erc20._mint(recipient, amount);
    }
}
----

The exposed `mint` above will create `amount` tokens and allocate them to `recipient`.
We now have our minting mechanism!

There is, however, a big problem.
`mint` does not include any restrictions on who can call this function.
For the sake of good practices, let's implement a simple permissioning mechanism with `Ownable`.

[,javascript]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin::access::ownable::Ownable as ownable_component;
    use openzeppelin::token::erc20::ERC20 as erc20_component;
    use starknet::ContractAddress;

    component!(path: ownable_component, storage: ownable, event: OwnableEvent);
    component!(path: erc20_component, storage: erc20, event: ERC20Event);

    // Ownable
    #[abi(embed_v0)]
    impl OwnableImpl = ownable_component::OwnableImpl<ContractState>;
    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = erc20_component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = erc20_component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = erc20_component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: ownable_component::Storage,
        #[substorage(v0)]
        erc20: erc20_component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        ERC20Event: erc20_component::Event,
        OwnableEvent: ownable_component::Event
    }

    #[constructor]
    fn constructor(self: @ContractState, owner: ContractAddress) {
        // Set contract owner
        self.ownable.initializer(owner);
    
        // Initialize ERC20
        let name = 'MyToken';
        let symbol = 'MTK';
        self.erc20.initializer(name, symbol);
    }

    #[external(v0)]
    fn mint(
        self: @ContractState,
        recipient: ContractAddress,
        amount: u256
    ) {
        // Set permissions with Ownable
        self.ownable.assert_only_owner();

        // Mint tokens if called by the contract owner
        self.erc20._mint(recipient, amount);
    }
}
----

In the constructor, we pass the owner address to set the owner of the `MyToken` contract.
The `mint` function includes `assert_only_owner` which will ensure that only the contract owner can call this function.
Now, we have a protected ERC20 minting mechanism to create a dynamic token supply.

TIP: For a more thorough explanation of permission mechanisms, see {access-control}.
