:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]

= Macros

This crate provides a collection of macros that streamline and simplify development with the library.
To use them, you need to add the `openzeppelin_macros` crate as a dependency in your `Scarb.toml` file:

```toml
[dependencies]
openzeppelin_macros = "2.0.0-alpha.0"
```

== Attribute macros

[.contract]
[[with_components]]
=== `++with_components++`

This macro simplifies the syntax for adding a set of components to a contract. It:

- _Imports the corresponding components into the contract._
- _Adds the corresponding `component!` macro entries._
- _Adds the storage entries for each component to the Storage struct._
- _Adds the event entries for each component to the Event struct, or creates the struct if it is missing._
- _Brings the corresponding internal implementations into scope._
- _Provides some diagnostics for each specific component to help the developer avoid common mistakes._

CAUTION: Since the macro does not expose any external implementations, developers must make sure to specify explicitly
the ones required by the contract.

[#with_components-security]
==== Security considerations

The macro was designed to be simple and effective while still being very hard to misuse. For this reason, the features
that it provides are limited, and things that might make the contract behave in unexpected ways must be
explicitly specified by the developer. It does not specify external implementations, so contracts won't find
themselves in a situation where external functions are exposed without the developer's knowledge. It brings
the internal implementations into scope so these functions are available by default, but if they are not used,
they won't have any effect on the contract's behavior.

[#with_components-usage]
==== Usage

This is how a contract with multiple components looks when using the macro.

```cairo
#[with_components(Account, SRC5, SRC9, Upgradeable)]
#[starknet::contract(account)]
mod OutsideExecutionAccountUpgradeable {
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::{ClassHash, ContractAddress};

    // External
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    #[abi(embed_v0)]
    impl OutsideExecutionV2Impl =
        SRC9Component::OutsideExecutionV2Impl<ContractState>;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
        self.src9.initializer();
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            self.account.assert_only_self();
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
```

This is how the same contract looks using regular syntax.

```cairo
#[starknet::contract(account)]
mod OutsideExecutionAccountUpgradeable {
    use openzeppelin::account::AccountComponent;
    use openzeppelin::account::extensions::SRC9Component;
    use openzeppelin::introspection::src5::SRC5Component;
    use openzeppelin::upgrades::UpgradeableComponent;
    use openzeppelin::upgrades::interface::IUpgradeable;
    use starknet::ClassHash;

    component!(path: AccountComponent, storage: account, event: AccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: SRC9Component, storage: src9, event: SRC9Event);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // External
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    #[abi(embed_v0)]
    impl OutsideExecutionV2Impl =
        SRC9Component::OutsideExecutionV2Impl<ContractState>;

    // Internal
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;
    impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        account: AccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        src9: SRC9Component::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccountEvent: AccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        SRC9Event: SRC9Component::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
        self.src9.initializer();
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            self.account.assert_only_self();
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
```

[.contract]
[[type_hash]]
=== `++type_hash++`

:SNIP-12: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md[SNIP-12]

This macro generates a {SNIP-12}-compatible type hash for a given struct or enum.

NOTE: This macro is fully compatible with the {SNIP-12} standard.

[#type_hash-usage]
==== Usage

```cairo
/// name and debug are optional arguments
#[type_hash(name: "My Struct", debug: true)]
struct MyStruct {
    #[snip12(name: "My Field")]
    my_field: felt252,
}
```

This will generate a type hash for the struct.

```cairo
// Encoded type: "My Struct"("My Field":"felt")
pub const MY_STRUCT_TYPE_HASH: felt252 = 0x1735aa9819941b96c651b740b792a96c854565eaff089b7e293d996828b88a8;
```

And because of the `debug` argument, it will generate the following code:

```cairo
pub fn __MY_STRUCT_encoded_type() {
    println!("\"My Struct\"(\"My Field\":\"felt\")");
}
```

[#type_hash-examples]
==== Examples

Struct with basic types and custom names and kinds:

```cairo
#[type_hash(name: "My Struct", debug: true)]
pub struct MyStruct {
    #[snip12(name: "Simple Felt")] // Optional custom name
    pub simple_felt: felt252,
    #[snip12(name: "Class Hash")]
    pub class_hash: ClassHash,
    #[snip12(name: "Target Token")]
    pub target: ContractAddress,
    #[snip12(name: "Timestamp", kind: "timestamp")]
    pub timestamp: u128,
    #[snip12(name: "Selector", kind: "selector")]
    pub selector: felt252,
}

// Encoded type: "My Struct"("Simple Felt":"felt","Class Hash":"ClassHash","Target Token":"ContractAddress","Timestamp":"timestamp","Selector":"selector")
pub const MY_STRUCT_TYPE_HASH: felt252
    = 0x522e0c3dc5e13b0978f4645760a436b1e119fd335842523fee8fbae6057b8c;

```

Enum with basic types and custom names and kinds:

```cairo
#[type_hash(name: "My Enum", debug: true)]
pub enum MyEnum {
    #[snip12(name: "Simple Felt")]
    SimpleFelt: felt252,
    #[snip12(name: "Class Hash")]
    ClassHash: ClassHash,
    #[snip12(name: "Target Token")]
    ContractAddress: ContractAddress,
    #[snip12(name: "Timestamp", kind: "timestamp")]
    Timestamp: u128,
    #[snip12(name: "Selector", kind: "selector")]
    Selector: felt252,
}

// Encoded type: "My Enum"("Simple Felt"("felt"),"Class Hash"("ClassHash"),"Target Token"("ContractAddress"),"Timestamp"("timestamp"),"Selector"("selector"))
pub const MY_ENUM_TYPE_HASH: felt252
    = 0x3f30aaa6cda9f699d4131940b10602b78b986feb88f28a19f3b48567cb4b566;
```
