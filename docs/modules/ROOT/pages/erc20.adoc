= ERC20

:fungible-tokens: https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[fungible tokens]
:eip20: https://eips.ethereum.org/EIPS/eip-20[EIP-20]
:erc20-api: xref:/api/erc20.adoc[API Reference]

The ERC20 token standard is a specification for {fungible-tokens}, a type of token where all the units are exactly equal to each other.
The `ERC20.cairo` contract implements an approximation of {eip20} in Cairo for Starknet.

TIP: For detailed information on the usage and implementation check the {erc20-api} section.

== Table of Contents

* <<interface,Interface>>
 ** <<erc20_compatibility,ERC20 compatibility>>
* <<extensibility,Extensibility>>
* <<presets,Presets>>
 ** <<basic-erc20,Basic ERC20>>
* <<extensions,Extensions>>

== Interface

[,javascript]
----
trait IERC20 {
    fn name() -> felt252;
    fn symbol() -> felt252;
    fn decimals() -> u8;
    fn total_supply() -> u256;
    fn balance_of(account: ContractAddress) -> u256;
    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(spender: ContractAddress, amount: u256) -> bool;
}
----

=== ERC20 compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC20 standard, in the following ways:

* It uses Cairo's `u256` instead of `felt252`.
* It makes use of Cairo's short strings to simulate `name` and `symbol`.

But some differences can still be found, such as:

* Function selectors are written in snake case as opposed to camel case in Solidity.
* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.

== Extensibility

:components: https://community.starknet.io/t/cairo-1-contract-syntax-is-evolving/94794#extensibility-and-components-11[Components]

ERC20 contracts can be extended by utilizing the contract's `_unsafe_new_contract_state()`.
The unsafe contract state allows access to the `ERC20Impl`.
This enables `IERC20` methods to include additional behaviors.

[,javascript]
----
#[external(v0)]
fn transfer(self: @ContractState, recipient: ContractAddress, amount: u256) -> bool {
    let unsafe_state = ERC20::unsafe_new_contract_state();

    // Add custom logic here

    ERC20::ERC20Impl::transfer(@unsafe_state, recipient, amount)
}
----

The unsafe state also allows access to ERC20's `InternalImpl`.
Having access to ERC20's internal implementation permits contracts, for example, to expose the internal methods like `_mint`.

[,javascript]
----
#[external(v0)]
fn mint(self: @ContractState, to: ContractAddress, amount: u256) {
    let unsafe_state = ERC20::unsafe_new_contract_state();
    
    // Ensures the mint function is protected!
    assert_only_owner(); 
    ERC20::InternalImpl::_mint(@unsafe_state, to, amount);
}
----

WARNING: This mechanism is unsafe because storage members could clash among used contracts if not reviewed carefully. Extensibility will be revisited after {components} are introduced.

== Presets

The ERC20 contract itself includes a basic implementation preset and can be used as-is for quick prototyping and testing.

More presets coming soon!

=== Basic ERC20 [[basic-erc20]]

:erc20-basic: https://github.com/OpenZeppelin/cairo-contracts/blob/cairo-2/src/token/erc20/erc20.cairo[ERC20]

The {erc20-basic} preset offers a quick and easy setup for deploying a basic ERC20 token.
This preset mints an inital supply which is necessary because it does not expose a minting function.

== Extensions

Coming soon!
