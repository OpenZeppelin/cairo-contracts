= Universal Deployer Contract

:deploy-syscall: xref:architecture_and_concepts:Smart_Contracts/system-calls-cairo1.adoc#deploy[deploy syscall]
:deployer-interface: link:https://community.starknet.io/t/snip-deployer-contract-interface/2772[standard deployer interface]
:interface-proposal: link:https://community.starknet.io/t/snip-deployer-contract-interface/2772[proposal for the standard deployer interface]
:udc-proposal: link:https://community.starknet.io/t/universal-deployer-contract-proposal/1864[Universal Deployer Contract proposal]

The Universal Deployer Contract (UDC) is a singleton smart contract that wraps the {deploy-syscall} to expose it to any contract that doesn't implement it, such as account contracts. You can think of it as a standardized generic factory for Starknet contracts.

And since Starknet has no deployment transaction type, it offers a standardized way to deploy smart contracts by following the {deployer-interface} and emitting a `ContractDeployed` event.

For more information see the {interface-proposal}.
For details on the motivation and the decision making process, see the {udc-proposal}.

== UDC contract address

This iteration of the UDC has not yet been deployed (see versions).

The first iteration of the UDC is deployed at address `0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf` in Mainnet, Goerli testner, Sepolia testnet, and starknet-devnet.

== Interface

[,javascript]
----
trait IUniversalDeployer {
    fn deploy_contract(
        class_hash: ClassHash,
        salt: felt252,
        from_zero: bool,
        calldata: Span<felt252>
    ) -> ContractAddress;
}
----

== Deploying a contract with the UDC

First, declare the target contract (if it's not already declared).
Next, call the UDC's `deploy_contract` method.
Here's an implementation example in Cairo:

[,javascript]
----
#[starknet::interface]
trait IUniversalDeployer<TContractState> {
    fn deploy_contract(
        ref self: TContractState,
        class_hash: ClassHash,
        salt: felt252,
        unique: bool,
        calldata: Span<felt252>
    ) -> ContractAddress;
}

const UDC_ADDRESS: felt252 = 0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf;

fn deploy() -> ContractAddress {
    let dispatcher = IUniversalDeployerDispatcher {
        contract_address: UDC_ADDRESS.try_into().unwrap()
    };

    // Deployment parameters
    let class_hash = class_hash_const::<
       0x5c478ee27f2112411f86f207605b2e2c58cdb647bac0df27f660ef2252359c6
    >();
    let salt = 1234567879;
    let from_zero = false;
    let mut calldata = array![];

    // The UDC returns the deployed contract address
    dispatcher.deploy_contract(class_hash, salt, from_zero, calldata.span())
}
----

== UDC versions

=== UDC_V1

The initial iteration of the UDC exposed a camelCase selector

=== UDC_V2

== Precomputing contract addresses
