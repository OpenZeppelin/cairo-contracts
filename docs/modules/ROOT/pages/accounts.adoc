:test-signers: https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.6.1/tests/signers.py
:snip-5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md
:snip-6: https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md

= Accounts

Unlike Ethereum where accounts are derived from a private key, all Starknet accounts are contracts. This means there's no Externally Owned Account (EOA)
concept on Starknet.

Instead, the network features native account abstraction and signature validation happens at the contract level.

For a general overview of account abstraction, see
https://docs.starknet.io/documentation/architecture_and_concepts/Accounts/introduction/[Starknet's documentation].
A more detailed discussion on the topic can be found in
https://community.starknet.io/t/starknet-account-abstraction-model-part-1/781[Starknet Shaman's forum].

TIP: For detailed information on the usage and implementation check the xref:/api/account.adoc[API Reference] section.

== Basic Account

As we mentioned, accounts in Starknet are smart contracts, and so they can be deployed and interacted
with like any other contract, and can be extended to implement any custom logic. However, accounts are a special type
of contract that are used to validate and execute transactions, for which they must implement a minimum set of functions.

=== Account methods

SRC6 standard account contracts must implement the following methods, the first two being enforced by the protocol.
The third one is optional and can be used for enabling declarations.

1. `\\__validate__` verifies the validity of the transaction to be executed. This is usually used to validate signatures,
but following the account abstraction design, the entrypoint implementation can be customized to feature any
validation mechanism.

2. `\\__execute__` executes the transaction if the validation is successful.

3. `\\__validate_declare__` Optional entrypoint similar to `\\__validate__` but for transactions
meant to declare other contracts.


NOTE: Even though these entrypoints _can_ be called directly at the contract level, they are not designed for that,
but to be called by the Starknet OS in the transaction execution flow.

=== Interface

Notice that we haven't mentioned the parameters or the return values of these entrypoints. This is because function
selectors in Starknet are computed from the function name, without including the rest of the signature. This means
that the entrypoints can be implemented with any signature, and the protocol will be able to call them as long
as the function name is correct.

In the following interface, we are using the `Array<Call>` for enabling multicall transactions. Note that we
don't need signature related parameters, because they are part of the transaction information that is accesible
using the global context (ex: `starknet::get_tx_info()`).

[,javascript]
----
/// Represents a call to a target contract function.
struct Call {
    to: ContractAddress,
    selector: felt252,
    calldata: Array<felt252>
}

trait BaseAccount {
    /// Executes a transaction through the account.
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;

    /// Asserts whether the transaction is valid to be executed.
    fn __validate__(calls: Array<Call>) -> felt252;

    // (Optional) Asserts whether the transaction is valid to be declared.
    fn __validate_declare__(class_hash: felt252) -> felt252;
}
----

== Standard Account Interface

In the previous section we've presented the minimal interface a contract must implement to act as an account by
propagating transactions through the network. However, this interface lacks some features required for supporting
interoperability among accounts and DApps in the ecosystem. For example, there is no mechanism for
recognizing on-chain whether a contract is an Account or not.

To address this issue, we have the {snip-6}[SNIP-6] proposal, which defines a standard interface for account contracts.

=== ISRC6 Interface

[,javascript]
----
/// Standard Account Interface
trait ISRC6 {
    /// Executes a transaction through the account.
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;

    /// Asserts whether the transaction is valid to be executed.
    fn __validate__(calls: Array<Call>) -> felt252;

    /// Asserts whether a given signature for a given hash is valid.
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;
}
----

{snip-6}[SNIP-6] adds the `is_valid_signature` method. This method is not used by the protocol, but it's useful for
DApps to verify the validity of signatures, supporting features like Sign In with Starknet.

SNIP-6 also defines that compliant accounts must implement the SRC5 interface following {snip-5}[SNIP-5], as
a mechanism for detecting whether a contract is an account or not through introspection.

=== ISRC5 Interface

[,javascript]
----
/// Standard Interface Detection
trait ISRC5 {
    /// Queries if a contract implements a given interface.
    fn supports_interface(interface_id: felt252) -> bool;
}
----

{snip-6}[SNIP-6] compliant accounts must return `true` when queried for the ISRC6 interface Id.

Even though these interfaces are not enforced by the protocol, it's recommended to implement them for enabling
interoperability with the ecosystem.

== Deploying an account

In Starknet there are two ways of deploying smart contracts: using the `deploy_syscall` and doing
counterfactual deployments.
The former can be easily done with the xref:udc.adoc[Universal Deployer Contract (UDC)], a contract that
wraps and exposes the `deploy_syscall` to provide arbitrary deployments through regular contract calls.
But if you don't have an account to invoke it, you will probably want to use the latter.

To do counterfactual deployments, you need to implement another protocol-level entrypoint named
`\\__validate_deploy__`. You can check the xref:/guides/deployment.adoc[Counterfactual Deployments] guide to learn how.
