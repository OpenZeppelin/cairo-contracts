= Universal Deployer Contract

:deploy-syscall: xref:architecture_and_concepts:Smart_Contracts/system-calls-cairo1.adoc#deploy[deploy syscall]
:deployer-interface: link:https://community.starknet.io/t/snip-deployer-contract-interface/2772[Standard Deployer Interface]
:udc-proposal: link:https://community.starknet.io/t/universal-deployer-contract-proposal/1864[Universal Deployer Contract proposal]
:deploy_contract: xref:/api/udc.adoc#UniversalDeployer-deploy_contract[deploy_contract]
:contract-deployed: xref:/api/udc.adoc#IUniversalDeployer-ContractDeployed[ContractDeployed]

The Universal Deployer Contract (UDC) is a singleton smart contract that wraps the {deploy-syscall} to expose it to any contract that doesn't implement it, such as account contracts. You can think of it as a standardized generic factory for Starknet contracts.

Since Starknet has no deployment transaction type, it offers a standardized way to deploy smart contracts by following the {deployer-interface} and emitting a {contract-deployed} event.

For details on the motivation and the decision making process, see the {udc-proposal}.

== UDC contract address

The UDC address is deployed at address `0xFIX-ME` in ADD-NETWORKS-WHEN-DEPLOYED.

== Interface

[,javascript]
----
trait IUniversalDeployer {
    fn deploy_contract(
        class_hash: ClassHash,
        salt: felt252,
        from_zero: bool,
        calldata: Span<felt252>
    ) -> ContractAddress;
}
----

== Deploying a contract with the UDC

:declare: link:https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/transactions/#declare-transaction[declare]

First, {declare} the target contract (if it's not already declared).
Next, call the UDC's `deploy_contract` method.
Here's an implementation example in Cairo:

[,javascript]
----
use openzeppelin::utils::interfaces::{IUniversalDeployerDispatcher, IUniversalDeployerDispatcherTrait};

const UDC_ADDRESS: felt252 = 0xFIX-ME;

fn deploy() -> ContractAddress {
    let dispatcher = IUniversalDeployerDispatcher {
        contract_address: UDC_ADDRESS.try_into().unwrap()
    };

    // Deployment parameters
    let class_hash = class_hash_const::<
       0x5c478ee27f2112411f86f207605b2e2c58cdb647bac0df27f660ef2252359c6
    >();
    let salt = 1234567879;
    let from_zero = false;
    let mut calldata = array![];

    // The UDC returns the deployed contract address
    dispatcher.deploy_contract(class_hash, salt, from_zero, calldata.span())
}
----

== Deployment types

The Universal Deployer Contract offers two types of addresses to deploy: origin-dependent and origin-independent.
As the names suggest, the origin-dependent type includes the deployer's address in the address calculation,
whereas, the origin-independent type does not.
The `from_zero` boolean parameter ultimately determines the type of deployment.

[IMPORTANT]
====
When deploying a contract that uses `get_caller_address` in the constructor calldata, remember that the UDC, not the account, deploys that contract.
Therefore, querying `get_caller_address` in a contract's constructor returns the UDC's address, _not the account's address_.
====

=== Origin-dependent

By making deployments dependent upon the origin address, users can reserve a whole address space to prevent someone else from taking ownership of the address.

Only the owner of the origin address can deploy to those addresses.

Achieving this type of deployment necessitates that the origin sets `from_zero` to `false` in the {deploy_contract} call.
Under the hood, the function passes a modified salt to the `deploy_syscall`, which is the hash of the origin's address with the given salt.

To deploy a unique contract address pass:

[,js]
----
let deployed_addr = udc.deploy_contract(class_hash, salt, false, calldata.span());
----

=== Origin-independent

Origin-independent contract deployments create contract addresses independent of the deployer and the UDC instance.
Instead, only the class hash, salt, and constructor arguments determine the address.
This type of deployment enables redeployments of accounts and known systems across multiple networks.
To deploy a reproducible deployment, set `from_zero` to `true`.

[source,cairo]
----
let deployed_addr = udc.deploy_contract(class_hash, salt, true, calldata.span());
----

== Version changes

:pedersen: link:https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#pedersen_hash[Pedersen]
:poseidon: link:https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#poseidon_hash[Poseidon]
:origin-dependent-deployments: xref:origin_dependent[origin-dependent deployments]
:previous-udc-api: link:https://docs.openzeppelin.com/contracts-cairo/0.6.1/udc#api_specification[previous Universal Deployer API]
:contract-deployed-event: xref:/api/udc.adoc#IUniversalDeployer-ContractDeployed[ContractDeployed]

NOTE: See the {previous-udc-api} for the initial spec.

The latest iteration of the UDC includes some notable changes to the API which include:

* `deployContract` method is replaced with the snake_case {deploy_contract}.
* {pedersen} hashing algorithm is replaced with the {poseidon} hashing algorithm for computing the salt on {origin-dependent-deployments}.
* `unique` parameter is replaced with `from_zero` in both the `deploy_contract` method and {contract-deployed-event} event.

WARNING: Origin-dependent deployments previously meant that the `unique` argument would be `true`.
Origin-dependent deployments from the new UDC iteration, however, requires that `from_zero` is `false`.
It's especially important to keep this in mind when dealing with `ContractDeployed` events because this change will appear as the opposite boolean per deployment type.

== Precomputing contract addresses

:calculate_address_from_zero: xref:/utilities.adoc#universal_deployer-calculate_contract_address_from_zero[calculate_address_from_zero]
:calculate_address_not_from_zero: xref:/utilities.adoc#universal_deployer-calculate_contract_address_not_from_zero[calculate_address_not_from_zero]

This library offers utility functions written in Cairo to precompute contract addresses.
They include {calculate_address_from_zero} and {calculate_address_not_from_zero} to return origin-independent and origin-dependent contract addresses respectively.
Check out the API docs for more information.
