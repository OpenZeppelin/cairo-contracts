= Test Utilities

This module provides various helper functions for declaring, deploying,
and testing Smart Contracts using Starknet Foundry.

```cairo
use openzeppelin_test_utils;
```

[.contract-index]
.Members
--
.Inner modules
* xref:#testutils-common[`++common++`]
* xref:#testutils-deployment[`++deployment++`]
* xref:#testutils-events[`++events++`]
* xref:#testutils-signing[`++signing++`]
--

[#testutils-Inner-Modules]
==== Inner modules

[.contract-item]
==== `[.contract-item-name]#++common++#` [.item-kind]#module#

See xref:#testutils-common[`openzeppelin_test_utils::common`].

[.contract-item]
==== `[.contract-item-name]#++deployment++#` [.item-kind]#module#

See xref:#testutils-deployment[`openzeppelin_test_utils::deployment`].

[.contract-item]
==== `[.contract-item-name]#++events++#` [.item-kind]#module#

See xref:#testutils-events[`openzeppelin_test_utils::events`].

[.contract-item]
==== `[.contract-item-name]#++signing++#` [.item-kind]#module#

See xref:#testutils-signing[`openzeppelin_test_utils::signing`].

[.contract]
[[testutils-common]]
=== `++common++`

```cairo
use openzeppelin_test_utils::common;
```

[.contract-index]
.Members
--
.Functions
* xref:#testutils-common-panic_data_to_byte_array[`++panic_data_to_byte_array(panic_data)++`]
* xref:#testutils-common-to_base_16_string[`++to_base_16_string(value)++`]
* xref:#testutils-common-assert_entrypoint_not_found_error[`++assert_entrypoint_not_found_error(result, selector, contract_address)++`]

.Traits
* xref:#testutils-common-IntoBase16StringTrait[`++IntoBase16StringTrait++`]
--

[#testutils-common-Functions]
==== Functions

[.contract-item]
[[testutils-common-panic_data_to_byte_array]]
==== `[.contract-item-name]#++panic_data_to_byte_array++#++(panic_data: Array<felt252>) → ByteArray++` [.item-kind]#function#

Converts panic data into a string (ByteArray).

`panic_data` is expected to be a valid serialized byte array with an extra felt252 at the beginning, which is the BYTE_ARRAY_MAGIC.

[.contract-item]
[[testutils-common-to_base_16_string]]
==== `[.contract-item-name]#++to_base_16_string++#++(value: felt252) → ByteArray++` [.item-kind]#function#

Converts a felt252 to a base 16 string padded to 66 characters (including the `0x` prefix).

[.contract-item]
[[testutils-common-assert_entrypoint_not_found_error]]
==== `[.contract-item-name]#++assert_entrypoint_not_found_error++#<T, +Drop<T>>(result: SyscallResult<T>, selector: felt252, contract_address: ContractAddress)` [.item-kind]#function#

Asserts that the syscall result of a call failed with an "Entrypoint not found" error,
following the Starknet Foundry emitted error format.

[#testutils-common-Traits]
==== Traits

[.contract-item]
[[testutils-common-IntoBase16StringTrait]]
==== `[.contract-item-name]#++IntoBase16StringTrait++#` [.item-kind]#trait#

A helper trait that enables a value to be represented as a base 16 string padded to 66 characters
(including the `0x` prefix). For that the type of the value has to implement `Into<T, felt252>` to be
convertible to `felt252`.

Usage example:

```cairo
use openzeppelin_test_utils::common::IntoBase16String;

let expected_panic_message = format!(
    "Entry point selector {} not found in contract {}",
    selector.into_base_16_string(),
    contract_address.into_base_16_string()
);
```

[.contract]
[[testutils-deployment]]
=== `++deployment++`

```cairo
use openzeppelin_test_utils::deployment;
```

A module containing utilities aimed to simplify declaring and deploying contracts via Starknet Foundry.

[.contract-index]
.Members
--
.Functions
* xref:#testutils-deployment-declare_class[`++declare_class(contract_name)++`]
* xref:#testutils-deployment-deploy[`++deploy(contract_class, calldata)++`]
* xref:#testutils-deployment-deploy_at[`++deploy_at(contract_class, contract_address, calldata)++`]
* xref:#testutils-deployment-deploy_another_at[`++deploy_another_at(existing, target_address, calldata)++`]
* xref:#testutils-deployment-declare_and_deploy[`++declare_and_deploy(contract_name, calldata)++`]
* xref:#testutils-deployment-declare_and_deploy_at[`++declare_and_deploy_at(contract_name, target_address, calldata)++`]
--

[#testutils-deployment-Functions]
==== Functions

[.contract-item]
[[testutils-deployment-declare_class]]
==== `[.contract-item-name]#++declare_class++#++(contract_name: ByteArray) → ContractClass++` [.item-kind]#function#

Declares a contract with a Starknet Foundry `declare` call and unwraps the result.

[.contract-item]
[[testutils-deployment-deploy]]
==== `[.contract-item-name]#++deploy++#++(contract_class: ContractClass, calldata: Array<felt252>) → ContractAddress++` [.item-kind]#function#

Deploys an instance of a contract and unwraps the result.

[.contract-item]
[[testutils-deployment-deploy_at]]
==== `[.contract-item-name]#++deploy_at++#++(contract_class: ContractClass, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Deploys an instance of a contract at a given address.

[.contract-item]
[[testutils-deployment-deploy_another_at]]
==== `[.contract-item-name]#++deploy_another_at++#++(existing: ContractAddress, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Deploys a contract using the class hash from another already-deployed contract.

Note that currently, Starknet Foundry does not support redeclaring a contract class. Consequently,
there is no direct method to deploy a second instance of a contract if neither its `ContractClass`
nor its `class_hash` is available in the context. This helper function provides a solution by retrieving
the class hash from an existing contract and using it to facilitate the deployment.

```cairo
use openzeppelin_test_utils::deploy_another_at;

let sender_address = setup_account(array!['PUBKEY']);
let recipient_address = contract_address_const::<'RECIPIENT'>();
deploy_another_at(sender_address, recipient_address, array!['ANOTHER_PUBKEY']);
```

[.contract-item]
[[testutils-deployment-declare_and_deploy]]
==== `[.contract-item-name]#++declare_and_deploy++#++(contract_name: ByteArray, calldata: Array<felt252>) → ContractAddress++` [.item-kind]#function#

Combines the declaration of a class and the deployment of a contract into one function call.

[.contract-item]
[[testutils-deployment-declare_and_deploy_at]]
==== `[.contract-item-name]#++declare_and_deploy_at++#++(contract_name: ByteArray, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Combines the declaration of a class and the deployment of a contract at the given address into one function call.

[.contract]
[[testutils-events]]
=== `++events++`

```cairo
use openzeppelin_test_utils::events;
use openzeppelin_test_utils::events::EventSpyExt;
```

A module offering an extended set of functions for handling emitted events, enhancing the default
event utilities provided by Starknet Foundry. These functions are accessible via the `EventSpyExt`
trait implemented on the `EventSpy` struct.

[.contract-index]
.Members
--
.Functions
* xref:#testutils-events-assert_only_event[`++assert_only_event(self, from_address, event)++`]
* xref:#testutils-events-assert_emitted_single[`++assert_emitted_single(self, from_address, expected_event)++`]
* xref:#testutils-events-drop_event[`++drop_event(self)++`]
* xref:#testutils-events-drop_n_events[`++drop_n_events(self, number_to_drop)++`]
* xref:#testutils-events-drop_all_events[`++drop_all_events(self)++`]
* xref:#testutils-events-assert_no_events_left[`++assert_no_events_left(self)++`]
* xref:#testutils-events-assert_no_events_left_from[`++assert_no_events_left_from(self, from_address)++`]
* xref:#testutils-events-count_events_from[`++count_events_from(self, from_address)++`]
--

[#testutils-events-Functions]
==== Functions

[.contract-item]
[[testutils-events-assert_only_event]]
==== `[.contract-item-name]#++assert_only_event++#++<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)++` [.item-kind]#function#

Ensures that `from_address` has emitted only the `expected_event` and no additional events.

[.contract-item]
[[testutils-events-assert_emitted_single]]
==== `[.contract-item-name]#++assert_emitted_single++#++<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)++` [.item-kind]#function#

Ensures that `from_address` has emitted the `expected_event`.

[.contract-item]
[[testutils-events-drop_event]]
==== `[.contract-item-name]#++drop_event++#++(ref self: EventSpy)++` [.item-kind]#function#

Removes a single event from the queue. If the queue is empty, the function will panic.

[.contract-item]
[[testutils-events-drop_n_events]]
==== `[.contract-item-name]#++drop_n_events++#++(ref self: EventSpy, number_to_drop: u32)++` [.item-kind]#function#

Removes `number_to_drop` events from the queue. If the queue is empty, the function will panic.

[.contract-item]
[[testutils-events-drop_all_events]]
==== `[.contract-item-name]#++drop_all_events++#++(ref self: EventSpy)++` [.item-kind]#function#

Removes all events remaining on the queue. If the queue is empty already, the function will do nothing.

[.contract-item]
[[testutils-events-assert_no_events_left]]
==== `[.contract-item-name]#++assert_no_events_left++#++(ref self: EventSpy)++` [.item-kind]#function#

Ensures that there are no events remaining on the queue.

[.contract-item]
[[testutils-events-assert_no_events_left_from]]
==== `[.contract-item-name]#++assert_no_events_left_from++#++(ref self: EventSpy, from_address: ContractAddress)++` [.item-kind]#function#

Ensures that there are no events emitted from the given address remaining on the queue.

[.contract-item]
[[testutils-events-count_events_from]]
==== `[.contract-item-name]#++count_events_from++#++(ref self: EventSpy, from_address: ContractAddress) → u32++` [.item-kind]#function#

Counts the number of remaining events emitted from the given address.

[.contract]
[[testutils-signing]]
=== `++signing++`

```cairo
use openzeppelin_test_utils::signing;
```

A module offering utility functions for easier management of key pairs and signatures.

[.contract-index]
.Members
--
.Functions
* xref:#testutils-signing-get_stark_keys_from[`++get_stark_keys_from(private_key)++`]
* xref:#testutils-signing-get_secp256k1_keys_from[`++get_secp256k1_keys_from(private_key)++`]

.Traits
* xref:#testutils-signing-SerializedSigning[`++SerializedSigning++`]
--

[#testutils-signing-Functions]
==== Functions

[.contract-item]
[[testutils-signing-get_stark_keys_from]]
==== `[.contract-item-name]#++get_stark_keys_from++#++(private_key: felt252) → StarkKeyPair++` [.item-kind]#function#

Builds a **Stark** Key Pair from a private key represented by a `felt252` value.

[.contract-item]
[[testutils-signing-get_secp256k1_keys_from]]
==== `[.contract-item-name]#++get_secp256k1_keys_from++#++(private_key: u256) → Secp256k1KeyPair++` [.item-kind]#function#

Builds a **Secp256k1** Key Pair from a private key represented by a `u256` value.


[#testutils-signing-Traits]
==== Traits

[.contract-item]
[[testutils-signing-SerializedSigning]]
==== `[.contract-item-name]#++SerializedSigning++#` [.item-kind]#trait#

A helper trait that facilitates signing and converting the result signature into a serialized format.

Usage example:

```cairo
use openzeppelin_test_utils::signing::{
    StarkKeyPair, get_stark_keys_from, StarkSerializedSigning
};

let key_pair = get_stark_keys_from('SECRET_KEY');
let serialized_signature = key_pair.serialized_sign('TX_HASH');
```