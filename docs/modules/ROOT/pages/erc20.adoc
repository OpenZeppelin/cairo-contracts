= ERC20

The ERC20 token standard is a specification for https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[fungible tokens], a type of token where all the units are exactly equal to each other.
The `ERC20.cairo` contract implements an approximation of https://eips.ethereum.org/EIPS/eip-20[EIP-20] in Cairo for StarkNet.

== Table of Contents

* <<interface,Interface>>
 ** <<erc20_compatibility,ERC20 compatibility>>
* <<usage,Usage>>
* <<extensibility,Extensibility>>
* <<presets,Presets>>
 ** <<erc20_basic,ERC20 (basic)>>
* <<api_specification,API Specification>>
 ** <<erc20impl,ERC20Impl>>
  *** <<name,`name`>>
  *** <<symbol,`symbol`>>
  *** <<decimals,`decimals`>>
  *** <<total_supply,`total_supply`>>
  *** <<balance_of,`balance_of`>>
  *** <<allowance,`allowance`>>
  *** <<transfer,`transfer`>>
  *** <<transfer_from,`transfer_from`>>
  *** <<approve,`approve`>>
 ** <<events,Events>>
  *** <<Transfer,`Transfer`>>
  *** <<Approval,`Approval`>>
 ** <<non-standard-external,Non-standard external>>
  *** <<increase_allowance,`increase_allowance`>>
  *** <<decrease_allowance,`decrease_allowance`>>
 ** <<internalimpl,InternalImpl>>
  *** <<initializer,`initializer`>>
  *** <<internal_increase_allowance,`_increase_allowance`>>
  *** <<internal_decrease_allowance,`_decrease_allowance`>>
  *** <<internal_mint,`_mint`>>
  *** <<internal_burn,`_burn`>>
  *** <<internal_approve,`_approve`>>
  *** <<internal_transfer,`_transfer`>>
  *** <<internal_spend_allowance,`_spend_allowance`>>

== Interface

[,rust]
----
#[starknet::interface]
trait IERC20<TState> {
    fn name(self: @TState) -> felt252;
    fn symbol(self: @TState) -> felt252;
    fn decimals(self: @TState) -> u8;
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(
        self: @TState,
        owner: ContractAddress,
        spender: ContractAddress
    ) -> u256;
    fn transfer(
        ref self: TState, 
        recipient: ContractAddress, 
        amount: u256
    ) -> bool;
    fn transfer_from(
        ref self: TState, 
        sender: ContractAddress, 
        recipient: ContractAddress, 
        amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
----

=== ERC20 compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC20 standard, in the following ways:

* It uses Cairo's `u256` instead of `felt252`.
* It makes use of Cairo's short strings to simulate `name` and `symbol`.

But some differences can still be found, such as:

* Function selectors are written in snake case as opposed to camel case in Solidity.
* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.

== Usage

Use cases go from medium of exchange currency to voting rights, staking, and more.

Coming soon!

== Extensibility

:components: https://community.starknet.io/t/cairo-1-contract-syntax-is-evolving/94794#extensibility-and-components-11[Components]

WARNING: This is currently unsafe, because storage members could clash among used contracts if not reviewed carefully. Extensibility will be revisited after {components} are introduced.

ERC20 contracts can be extended by utilizing the contract's _unsafe_new_contract_state().
The unsafe contract state allows access to the _ERC20Impl_.
This enables IERC20 methods to include additional behaviors.

[,rust]
----
#[external(v0)]
fn transfer(self: @ContractState, recipient: ContractAddress, amount: u256) -> bool {
    let unsafe_state = ERC20::unsafe_new_contract_state();

    // Add custom logic here

    ERC20::ERC20Impl::transfer(@unsafe_state, recipient, amount)
}
----

The unsafe state also allows access to ERC20's _InternalImpl_.
Having access to ERC20's interal implementation permits contracts, for example, to expose the internal methods like _mint.

[,rust]
----
#[external(v0)]
fn mint(self: @ContractState, to: ContractAddress, amount: u256) {
    let unsafe_state = ERC20::unsafe_new_contract_state();
    assert_only_owner();  // Ensure the mint function is protected!
    ERC20::InternalImpl::_mint(@unsafe_state, to, amount);
}
----

Note that accessing the contract's state in this way is unsafe at the moment.

== Presets

The ERC20 contract itself includes a basic implementation preset and can be used as-is for quick prototyping and testing.
The basic preset mints an inital supply which is necessary because it does not expose a minting function.

More presets coming soon!

=== ERC20 (basic)

*TODO: CHANGE LINK TO RELEASE COMMIT WHEN AVAILABLE*

The https://github.com/OpenZeppelin/cairo-contracts/blob/cairo-2/src/token/erc20/erc20.cairo[`ERC20`] preset offers a quick and easy setup for deploying a basic ERC20 token.

== API Specification

=== ERC20Impl

[,rust]
----
fn name(self: @TState) -> felt252;
fn symbol(self: @TState) -> felt252;
fn decimals(self: @TState) -> u8;
fn total_supply(self: @TState) -> u256;
fn balance_of(self: @TState, account: ContractAddress) -> u256;
fn allowance(
    self: @TState,
    owner: ContractAddress,
    spender: ContractAddress
) -> u256;
fn transfer(
    ref self: TState,
    recipient: ContractAddress,
    amount: u256
) -> bool;
fn transfer_from(
    ref self: TState,
    sender: ContractAddress,
    recipient: ContractAddress,
    amount: u256
) -> bool;
fn approve(
    ref self: TState,
    spender: ContractAddress,
    amount: u256
) -> bool;
----

==== `name`

[.contract-item]
==== `[.contract-item-name]#++name++#++(self: @TState) → felt252++`

Returns the name of the token.

===== Returns

- Token name.

==== `symbol`

[.contract-item]
==== `[.contract-item-name]#++symbol++#++(self: @TState) → felt252++`

Returns the ticker symbol of the token, usually a shorter version of the name.

===== Returns

- Token symbol.

==== `decimals`

[.contract-item]
==== `[.contract-item-name]#++decimals++#++(self: @TState) → u8++`

Returns the number of decimals the token uses - e.g. 8 means to divide the token amount by 100000000 to get its user representation.
Returns the number of decimals used to get its user representation.

For example, if `decimals` equals `2`, a balance of `505` tokens should
be displayed to a user as `5.05` (`505 / 10 ** 2`).

Tokens usually opt for a value of 18, imitating the relationship between
Ether and Wei. This is the default value returned by this function, unless
a custom implementation is used.

NOTE: This information is only used for _display_ purposes: it in
no way affects any of the arithmetic of the contract.

===== Returns

- Token decimals.

==== `total_supply`

[.contract-item]
==== `[.contract-item-name]#++total_supply++#++(self: @TState) → u256++`

Returns the amount of tokens in existence.

===== Returns

- Total amount of tokens in existence.

==== `balance_of`

[.contract-item]
==== `[.contract-item-name]#++balance_of++#++(self: @TState, account: ContractAddress) → u256++`

Returns the amount of tokens owned by `account`.

===== Arguments

- `*account*`
+
The account balance to query.

===== Returns

- Token balance of `account`.

==== `allowance`

[.contract-item]
==== `[.contract-item-name]#++allowance++#++(self: @TState, owner: ContractAddress, spender: ContractAddress) → u256++`

Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through <<transfer_from,transfer_from>>. This is zero by default.

This value changes when <<approve,approve>> or <<transfer_from,transfer_from>> are called.

===== Arguments

- `*owner*`
+
The address of the token owner.
- `*spender*`
+
The address of the token spender.

===== Returns

- Current allowance granted by `owner` to `spender`.

==== `transfer`

[.contract-item]
==== `[.contract-item-name]#++transfer++#++(ref self: @TState, recipient: ContractAddress, amount: u256) → bool++`

Moves `amount` tokens from the caller's token balance to `to`.

Emits a <<Transfer,Transfer>> event.

===== Arguments

- `*recipient*`
+
The address receiving `amount` tokens.
- `*amount*`
+
The number of tokens to send from the caller to the `recipient`.

===== Returns

- `true` on success.

==== `transfer_from`

[.contract-item]
==== `[.contract-item-name]#++transfer_from++#++(ref self: @TState, sender: ContractAddress, recipient: ContractAddress, amount: u256) → bool++`

Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.
`amount` is then deducted from the caller's allowance.

Emits a <<Transfer,Transfer>> event.

===== Arguments

- `*sender*`
+
The address from which the transfer will be initiated.
- `*recipient*`
+
The address receiving `amount` tokens.
- `*amount*`
+
The number of tokens to send from `sender` to `recipient`.

===== Returns

- `true` on success.

==== `approve`

[.contract-item]
==== `[.contract-item-name]#++approve++#++(ref self: @TState, spender: ContractAddress, amount: u256) → bool++`

Sets `amount` as the allowance of `spender` over the caller's tokens.

Emits an <<Approval,Approval>> event.

===== Arguments

- `*spender*`
+
The address which may spend `amount` tokens on behalf of the caller.
- `*amount*`
+
The token allowance given to the `spender` from the caller.

===== Returns

- `true` on success.

=== Events

[,rust]
----
struct Transfer {
    from: ContractAddress,
    to: ContractAddress,
    value: u256
}
struct Approval {
    owner: ContractAddress,
    spender: ContractAddress,
    value: u256
}
----

==== `Transfer` [[Transfer]]

[.contract-item]
==== `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, amount: u256)++`

Emitted when `value` tokens are moved from one address (`from`) to another (`to`).

Note that `value` may be zero.

===== Arguments

- `*from*`
+
The address from which the tokens are sent.
- `*to*`
+
The recipient address.
- `*amount*`
+
The amount of tokens sent from `from` to `to`.

==== `Approval` [[Approval]]

[.contract-item]
==== `[.contract-item-name]#++Approval++#++(owner: ContractAddress, spender: ContractAddress, value: u256)++`

Emitted when the allowance of a `spender` for an `owner` is set by a call to <<approve,approve>>.
`value` is the new allowance.

===== Arguments

- `*owner*`
+
The address which owns the tokens to approve.
- `*spender*`
+
The address which may spend the tokens on behalf of the `owner`.
- `*value*`
+
The amount which may be spent by the `spender`.

=== Non-standard external [[non-standard-external]]

[,rust]
----
fn increase_allowance(
    ref self: TState, spender: ContractAddress, added_value: u256
);
fn decrease_allowance(
    ref self: TState, spender: ContractAddress, subtracted_value: u256
);
----

==== `increase_allowance`

[.contract-item]
==== `[.contract-item-name]#++increase_allowance++#++(ref self: @TState, spender: ContractAddress, added_value: u256)++`

Atomically increases the allowance granted to `spender` by the caller.

Emits an <<Approval,Approval>> event indicating the updated allowance.

===== Arguments

- `*spender*`
+
The address which may spend tokens on behalf of the caller.
- `*added_value*`
+
The amount of tokens added to the spender's allowance.

==== `decrease_allowance`

[.contract-item]
==== `[.contract-item-name]#++decrease_allowance++#++(ref self: @TState, spender: ContractAddress, subtracted_value: u256)++`

Atomically decreases the allowance granted to `spender` by the caller.

Emits an <<Approval,Approval>> event indicating the updated allowance.

===== Arguments

- `*spender*`
+
The address which may spend tokens on behalf of the caller.
- `*subtracted_value*`
+
The amount of tokens subtracted from the spender's allowance.

=== InternalImpl

[,rust]
----
fn initializer(ref self: TState, name_: felt252, symbol_: felt252);
fn _increase_allowance(
    ref self: TState, spender: ContractAddress, added_value: u256
);
fn _decrease_allowance(
    ref self: TState, spender: ContractAddress, subtracted_value: u256
);
fn _mint(ref self: TState, recipient: ContractAddress, amount: u256);
fn _burn(ref self: TState, account: ContractAddress, amount: u256);
fn _approve(
    ref self: TState,
    owner: ContractAddress,
    spender: ContractAddress,
    amount: u256
);
fn _transfer(
    ref self: TState,
    sender: ContractAddress,
    recipient: ContractAddress,
    amount: u256
);
fn _spend_allowance(
    ref self: TState,
    owner: ContractAddress,
    spender: ContractAddress,
    amount: u256
);
----

==== `initializer`

[.contract-item]
==== `[.contract-item-name]#++initializer++#++(ref self: @TState, name_: felt252, symbol_: felt252)++`

Initializers the contract by setting the token name and symbol.
This should be used inside of the contract's constructor.

===== Arguments

- `*name_*`
+
The token name.
- `*symbol_*`
+
The token symbol.

==== `_increase_allowance` [[internal_increase_allowance]]

[.contract-item]
==== `[.contract-item-name]#++_increase_allowance++#++(ref self: @TState, spender: ContractAddress, added_value: u256)++`

Atomically increases the allowance granted to `spender` by the caller.

===== Arguments

- `*spender*`
+
The address which may spend tokens on behalf of the caller.
- `*added_value*`
+
The amount of tokens added to the spender's allowance.

==== `_decrease_allowance` [[internal_decrease_allowance]]

[.contract-item]
==== `[.contract-item-name]#++_decrease_allowance++#++(ref self: @TState, spender: ContractAddress, subtracted_value: u256)++`

Atomically decreases the allowance granted to `spender` by the caller.

===== Arguments

- `*spender*`
+
The address which may spend tokens on behalf of the caller.
- `*subtracted_value*`
+
The amount of tokens subtracted from the spender's allowance.

==== `_mint` [[internal_mint]]

[.contract-item]
==== `[.contract-item-name]#++_mint++#++(ref self: @TState, recipient: ContractAddress, amount: u256)++`

Creates an `amount` number of tokens and assigns them to `recipient`, by transferring them from the zero address.

Emits a <<Transfer,Transfer>> event with `from` being the zero address.

===== Arguments

- `*recipient*`
+
The address receiving the `amount`.
- `*amount*`
+
The number of tokens created.

==== `_burn` [[internal_burn]]

[.contract-item]
==== `[.contract-item-name]#++_burn++#++(ref self: @TState, account: ContractAddress, amount: u256)++`

Destroys `amount` number of tokens from `account`, by transferring them to the zero address.

Emits a <<Transfer,Transfer>> event with `to` set to the zero address.

===== Arguments

- `*account*`
+
The owner of the tokens to destroy.
- `*amount*`
+
The number of tokens to destroy.

==== `_approve` [[internal_approve]]

[.contract-item]
==== `[.contract-item-name]#++_approve++#++(ref self: @TState, owner: ContractAddress, spender: ContractAddress, amount: u256)++`

Sets `value` as the allowance of `spender` over the `owner` tokens.
This internal function is equivalent to `approve`, and can be used to e.g. set automatic allowances for certain subsystems, etc.

Emits an <<Approval,Approval>> event.

===== Arguments

- `*owner*`
+
The address which owns the tokens to approve.
- `*spender*`
+
The address which may spend the tokens on behalf of the `owner`.
- `*amount*`
+
The number of tokens in the `spender` allowance.

==== `_transfer` [[internal_transfer]]

[.contract-item]
==== `[.contract-item-name]#++_transfer++#++(ref self: @TState, sender: ContractAddress, recipient: ContractAddress, amount: u256)++`

Internal method that moves an `amount` of tokens from `from` to `to`.

Emits a <<Transfer,Transfer>> event.

===== Arguments

- `*sender*`
+
The address from which the transfer will be initiated.
- `*recipient*`
+
The address receiving `amount` tokens.
- `*amount*`
+
The value of tokens the `recipient` receives.

==== `_spend_allowance` [[internal_spend_allowance]]

[.contract-item]
==== `[.contract-item-name]#++_spend_allowance++#++(ref self: @TState, owner: ContractAddress, spender: ContractAddress, amount: u256)++`

Internal method that updates `owner` allowance for `spender` based on spent `amount`.
Does not update the allowance value in case of infinite allowance.

Possible emits an <<Approval,Approval>> event.

===== Arguments

- `*owner*`
+
The address which owns the tokens to approve.
- `*spender*`
+
The address which may spend the tokens on behalf of the `owner`.
- `*amount*`
+
The number of tokens in the `spender` allowance.
