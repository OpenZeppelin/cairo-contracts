= Utilities

The following documentation provides reasoning and examples for functions and constants found in `openzeppelin::utils`
and `openzeppelin::tests::utils`.

CAUTION: Expect this module to evolve (as it has already done).

== Core utilities

[.contract]
[[utils]]
=== `++utils++`

```javascript
use openzeppelin::utils;
```

Module containing core utilities of the library.

[.contract-index]
.Members
--
.Functions
* xref:#utils-try_selector_with_fallback[`++try_selector_with_fallback(target, selector, fallback, args)++`]

.Traits
* xref:#utils-UnwrapAndCast[`++UnwrapAndCast++`]

.Inner modules
* xref:#utils-selectors[`++selectors++`]
* xref:#utils-serde[`++serde++`]
--

[#utils-Functions]
==== Functions

[.contract-item]
[[utils-try_selector_with_fallback]]
==== `[.contract-item-name]#++try_selector_with_fallback++#++(target: ContractAddress, selector: felt252, fallback: felt252, args: Span<felt252>) → SyscallResult<Span<felt252>>++` [.item-kind]#function#

Tries to call a given selector on a given contract, and if it fails, tries to call a fallback selector.

It was designed for falling back to the `camelCase` selector for backward compatibility in the
case of a failure of the `snake_case` selector.

Returns a `SyscallResult` with the result of the successful call.

Note that:

- If the first call succeeds, the second call is not attempted.

- If the first call fails with an error different than `ENTRYPOINT_NOT_FOUND`, the error is returned
without falling back to the second selector.

- If the first call fails with `ENTRYPOINT_NOT_FOUND`, the second call is attempted, and if it fails its
error is returned.

WARNING: The fallback mechanism won't work on live chains (mainnet or testnets) until
they implement panic handling in their runtime.

[#utils-Traits]
==== Traits

[.contract-item]
[[utils-UnwrapAndCast]]
==== `[.contract-item-name]#++UnwrapAndCast++#` [.item-kind]#trait#

Trait for exposing an `unwrap_and_cast` function to `SyscallResult` objects. This may be useful
when unwrapping a syscall result to a type implementing the `Serde` trait, and you want to avoid the boilerplate of
casting and unwrapping the result multiple times.

Usage example:

```javascript
use openzeppelin::utils::selectors;
use openzeppelin::utils::UnwrapAndCast;

fn call_and_cast_to_bool(target: ContractAddress, args: Span<felt252>) -> bool {
    try_selector_with_fallback(
        target, selectors::has_role, selectors::hasRole, args
    ).unwrap_and_cast()
}

fn call_and_cast_to_felt252(target: ContractAddress, args: Span<felt252>) -> felt252 {
    try_selector_with_fallback(
        target, selectors::get_role_admin, selectors::getRoleAdmin, args
    ).unwrap_and_cast()
}
```

Note that it can be automatically casted to any type implementing the `Serde` trait.

[#utils-Inner-Modules]
==== Inner modules

[.contract-item]
[[utils-selectors]]
==== `[.contract-item-name]#++selectors++#` [.item-kind]#module#

See xref:#selectors[`openzeppelin::utils::selectors`].

[.contract-item]
[[utils-serde]]
==== `[.contract-item-name]#++serde++#` [.item-kind]#module#

See xref:#serde[`openzeppelin::utils::serde`].

[.contract]
[[selectors]]
=== `++selectors++`

```javascript
use openzeppelin::utils::selectors;
```

:selectors: https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.8.1-beta.0/src/utils/selectors.cairo[selectors.cairo]

Module containing constants matching multiple selectors used through the library.
To see the full list of selectors, see {selectors}.

[.contract]
[[serde]]
=== `++serde++`

```javascript
use openzeppelin::utils::serde;
```

Module containing utilities related to serialization and deserialization of Cairo data structures.

[.contract-index]
.Members
--
.Traits
* xref:#serde-SerializedAppend[`++SerializedAppend++`]
--

[#serde-Traits]
==== Traits

[.contract-item]
[[serde-SerializedAppend]]
==== `[.contract-item-name]#++SerializedAppend++#` [.item-kind]#trait#

Importing this trait allows the ability to append a serialized representation of a Cairo data structure already
implementing the `Serde` trait to a `felt252` buffer.

Usage example:

```javascript
use openzeppelin::utils::serde::SerializedAppend;
use starknet::ContractAddress;

fn to_calldata(recipient: ContractAddress, amount: u256) -> Array<felt252> {
    let mut calldata = array![];
    calldata.append_serde(recipient);
    calldata.append_serde(amount);
    calldata
}
```

Note that the `append_serde` method is automatically available for arrays of felts, and it accepts any data structure
that implements the `Serde` trait.

== Test utilities


[.contract]
[[testutils]]
=== `++utils++`

```javascript
use openzeppelin::tests::utils;
```

Module containing utilities for testing the library.

[.contract-index]
.Members
--
.Functions
* xref:#testutils-deploy[`++deploy(contract_class_hash, calldata)++`]
* xref:#testutils-pop_log[`++pop_log<T>(address)++`]
* xref:#testutils-assert_indexed_keys[`++assert_indexed_keys<T>(event, expected_keys)++`]
* xref:#testutils-assert_no_events_left[`++assert_no_events_left(address)++`]
* xref:#testutils-drop_event[`++drop_event(address)++`]

.Inner modules
* xref:#testutils-constants[`++constants++`]
--

[#testutils-Functions]
==== Functions

[.contract-item]
[[testutils-deploy]]
==== `[.contract-item-name]#++deploy++#++(contract_class_hash: felt252, calldata: Array<felt252>) → ContractAddress++` [.item-kind]#function#

:deploy_syscall: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls/#deploy[deploy_syscall]

Uses the `{deploy_syscall}` to deploy an instance of the contract given the class hash and the calldata.

The `contract_address_salt` is always set to zero, and `deploy_from_zero` is set to false.

Usage example:

```javascript
use openzeppelin::presets::Account;
use openzeppelin::tests::utils;
use starknet::ContractAddress;

const PUBKEY: felt252 = 'PUBKEY';

fn deploy_test_contract() -> ContractAddress {
    let calldata = array![PUBKEY];
    utils::deploy(Account::TEST_CLASS_HASH, calldata)
}
```

[.contract-item]
[[testutils-pop_log]]
==== `[.contract-item-name]#++pop_log++#++<T>(address: ContractAddress) → Option<T>++` [.item-kind]#function#

Pops the earliest unpopped logged event for the contract as the requested type
and checks that there's no more keys or data left on the event, preventing unaccounted params.

This function also removes the first key from the event, to match the event structure key params without
the event ID.

Required traits for `T`:

- `Drop`
- `starknet::Event`

Requirements:

- No extra data or keys are left on the raw event after deserialization.

WARNING: This method doesn't currently work for component events that are not flattened
because an extra key is added, pushing the event ID key to the second position.

[.contract-item]
[[testutils-assert_indexed_keys]]
==== `[.contract-item-name]#++assert_indexed_keys++#<T>(event: T, expected_keys: Span<felt252>)` [.item-kind]#function#

Asserts that `expected_keys` exactly matches the indexed keys from `event`.

`expected_keys` must include all indexed event keys for `event` in the order
that they're defined.

Required traits for `T`:

- `Drop`
- `starknet::Event`

[.contract-item]
[[testutils-assert_no_events_left]]
==== `[.contract-item-name]#++assert_no_events_left++#++(address: ContractAddress)++` [.item-kind]#function#

Asserts that there are no more events left in the queue for the given address.

[.contract-item]
[[testutils-drop_event]]
==== `[.contract-item-name]#++drop_event++#++(address: ContractAddress)++` [.item-kind]#function#

Removes an event from the queue for the given address.

If the queue is empty, this function won't do anything.

[#testutils-Inner-Modules]
==== Inner modules

[.contract-item]
[[testutils-constants]]
==== `[.contract-item-name]#++constants++#` [.item-kind]#module#

See xref:#constants[`openzeppelin::tests::utils::constants`].

[.contract]
[[constants]]
=== `++constants++`

```javascript
use openzeppelin::tests::utils::constants;
```

:constants: https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.8.1-beta.0/src/tests/utils/constants.cairo[constants.cairo]

Module containing constants that are repeatedly used among tests.
To see the full list, see {constants}.
