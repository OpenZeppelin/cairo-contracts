= ERC6909

:fungibility-agnostic: https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens[fungibility-agnostic]
:eip-6909: https://eips.ethereum.org/EIPS/eip-6909[EIP-6909]

The ERC6909 minimal multi token standard is a specification for {fungibility-agnostic} token contracts.
`token::erc6909::ERC6909Component` provides an approximation of {eip-6909} in Cairo for StarkNet.

== Minimal Multi Token Standard

Similar to ERC1155, it uses a single smart contract to represent multiple tokens via unique IDs. The main difference is 
that in ERC6909 "the callbacks and batching have been removed from the interface and the permission system is a hybrid operator-approval
scheme for granular and scalable permissions. Functionally, the interface has been reduced to the bare minimum 
required to manage multiple tokens under the same contract." {eip-6909}

== Usage

:solidity-implementation: https://github.com/jtriley-eth/ERC-6909/tree/main/src[sample Solidity implementations]

Using Contracts for Cairo, constructing an ERC6909 contract requires integrating the `ERC6909Component`.
Here's what that looks like:

[,cairo]
----
#[starknet::contract]
mod MyERC6909Token {
    use openzeppelin::token::erc6909::{ERC6909Component, ERC6909HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC6909Component, storage: erc6909, event: ERC6909Event);

    // ERC6909 Mixin
    #[abi(embed_v0)]
    impl ERC6909MixinImpl = ERC6909Component::ERC6909MixinImpl<ContractState>;
    impl ERC6909InternalImpl = ERC6909Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc6909: ERC6909Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC6909Event: ERC6909Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        recipient: ContractAddress,
        token_id: u256,
        initial_supply: u256,
        contract_uri: ByteArray
    ) {
        self.erc6909.mint(recipient, token_id, initial_supply);
    }
}
----

`MyERC6909Token` integrates the `ERC6909Impl` with the embed directive which marks the implementation as external in the contract.

There are 3 optional extensions which can also be imported into `MyERC6909Token`:

* `ERC6909ContentURI` - Allows to set the base contract URI and thus show individual token URIs.
* `ERC6909Metadata` - Allows to set the `name`, `symbol` and `decimals` of each token ID.
* `ERC6909TokenSupply` - Allows to keep track of individual token supplies upon mints and burns.

Here is an example of how to include the content URI component in your ERC6909 contract:

[,cairo]
----
#[starknet::contract]
pub(crate) mod MyERC6909TokenWithURI {
    // 1. Import `ERC6909Component` and `ERC6909ContentURIComponent` with trait to use internal functions
    use openzeppelin::token::erc6909::ERC6909Component;
    use openzeppelin::token::erc6909::ERC6909HooksEmptyImpl;
    use openzeppelin::token::erc6909::extensions::ERC6909ContentURIComponent::InternalTrait;
    use openzeppelin::token::erc6909::extensions::ERC6909ContentURIComponent;

    use starknet::{ContractAddress, get_caller_address};

    // 2. Declare both components
    component!(path: ERC6909Component, storage: erc6909, event: ERC6909Event);
    component!(path: ERC6909ContentURIComponent, storage: erc6909_content_uri, event: ERC6909ContentURIEvent);

    // 3. Embed both component implementations to expose their external functions
    #[abi(embed_v0)]
    impl ERC6909MixinImpl = ERC6909Component::ERC6909MixinImpl<ContractState>;
    #[abi(embed_v0)]
    impl ERC6909ContentURIComponentImpl = ERC6909ContentURIComponent::ERC6909ContentURIImpl<ContractState>;

    impl InternalImpl = ERC6909Component::InternalImpl<ContractState>;

    // 4. Set substorage, allowing the contract to have indirect access to each component’s storage
    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc6909: ERC6909Component::Storage,
        #[substorage(v0)]
        erc6909_content_uri: ERC6909ContentURIComponent::Storage,
    }

    // 5. Flatten the component events to remove the first key in the event logs, which is the component ID
    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC6909Event: ERC6909Component::Event,
        #[flat]
        ERC6909ContentURIEvent: ERC6909ContentURIComponent::Event,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState, receiver: ContractAddress, id: u256, amount: u256, uri: ByteArray
    ) {
        self.erc6909.mint(receiver, id, amount);
        self.erc6909_content_uri.initializer(uri)
    }
}
----

`MyERC6909TokenWithURI` integrates both the `ERC6909Impl` and `ERC6909ContentURIImpl` with the embed directive which marks the implementations as external in the contract.
The above example also includes 2 internal implementations. 
The `ERC6909InternalImpl` allows contract's constructor to create an initial supply of tokens via ERC6909's `mint` method.
The `ERC6909ContentURIComponent::InternalTrait` similarly allows the contract's constructor to set the URI via ERC6909ContentURI's `initializer` method

// TODO
TIP: For a more complete guide on ERC6909 token mechanisms, see {erc6909-supply}.

== Interface

:dual-interfaces: xref:/interfaces.adoc#dual_interfaces[Dual interfaces]
:ierc6909-interface: xref:/api/erc6909.adoc#IERC6909[IERC6909]
:ierc6909_metadata-interface: xref:/api/erc6909.adoc#IERC6909Metadata[IERC6909Metadata]
:ierc6909_tokensupply-interface: xref:/api/erc6909.adoc#IERC6909TokenSupply[IERC6909TokenSupply]
:ierc6909_contenturi-interface: xref:/api/erc6909.adoc#IERC6909ContentURI[IERC6909ContentURI]
:erc6909-component: xref:/api/erc6909.adoc#ERC6909Component[ERC6909Component]

// TODO?
//:erc6909-supply: xref:/guides/erc20-supply.adoc[Creating ERC20 Supply]

The following interface represents the full ABI of the Contracts for Cairo {erc6909-component}.
The interface includes the {ierc6909-interface} standard interface.
To support older token deployments, as mentioned in {dual-interfaces}, the component also includes an implementation of the interface written in camelCase.

[,cairo]
----
#[starknet::interface]
pub trait ERC6909ABI<TState> {
    /// @notice IERC6909 standard interface
    fn balance_of(self: @TState, owner: ContractAddress, id: u256) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress, id: u256) -> u256;
    fn is_operator(self: @TState, owner: ContractAddress, spender: ContractAddress) -> bool;
    fn transfer(ref self: TState, receiver: ContractAddress, id: u256, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, receiver: ContractAddress, id: u256, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, id: u256, amount: u256) -> bool;
    fn set_operator(ref self: TState, spender: ContractAddress, approved: bool) -> bool;
    fn supports_interface(self: @TState, interface_id: felt252) -> bool;

    /// @notice IERC6909Camel
    fn balanceOf(self: @TState, owner: ContractAddress, id: u256) -> u256;
    fn isOperator(self: @TState, owner: ContractAddress, spender: ContractAddress) -> bool;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, receiver: ContractAddress, id: u256, amount: u256
    ) -> bool;
    fn setOperator(ref self: TState, spender: ContractAddress, approved: bool) -> bool;
    fn supportsInterface(self: @TState, interfaceId: felt252) -> bool;
}
----

== ERC6909 compatibility

:cairo-selectors: https://github.com/starkware-libs/cairo/blob/7dd34f6c57b7baf5cd5a30c15e00af39cb26f7e1/crates/cairo-lang-starknet/src/contract.rs#L39-L48[Cairo]
:solidity-selectors: https://solidity-by-example.org/function-selector/[Solidity]
:dual-interface: xref:/interfaces.adoc#dual_interfaces[dual interface]
:interface-id: https://community.starknet.io/t/starknet-standard-interface-detection/92664/23[interface ID]

Although Starknet is not EVM compatible, this component aims to be as close as possible to the ERC6909 token standard.
Some notable differences, however, can still be found, such as:

* The `ByteArray` type is used to represent strings in Cairo in the Metadata extension.
* The `felt252` type is used to represent the  `byte4` interface ID. The {interface-id} is also calculated different in Cairo.
* The component offers a {dual-interface} which supports both snake_case and camelCase methods, as opposed to just camelCase in Solidity.
* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.

== Customizing Token Metadata

Since ERC6909 is a multi-token standard, instead of having a single `name`, `decimals`, and `symbol`,
the optional `IERC6909Metadata` module defines these metadata properties for each token ID individually.

There are 3 internal methods which can be used to set individual id metadata: `_set_token_name(id, name)`, `_set_token_symbol(id, symbol)` and `_set_token_decimals(id, decimals)`.

[,cairo]
----
#[starknet::contract]
mod MyERC6909TokenWithMetadata {
    use openzeppelin::token::erc6909::{ERC6909Component, ERC6909HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC6909Component, storage: erc6909, event: ERC6909Event);

    // ERC6909 Mixin
    #[abi(embed_v0)]
    impl ERC6909MixinImpl = ERC6909Component::ERC6909MixinImpl<ContractState>;

    // Optional to keep track of token supplies and URIs. 
    // In this case we only use the snake_case implementations.
    #[abi(embed_v0)]
    impl ERC6909TokenSupplyImpl = ERC6909Component::ERC6909TokenSupplyImpl<ContractState>;
    #[abi(embed_v0)]
    impl ERC6909ContentURIImpl = ERC6909Component::ERC6909ContentURIImpl<ContractState>;

    impl ERC6909InternalImpl = ERC6909Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc6909: ERC6909Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC6909Event: ERC6909Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        recipient: ContractAddress,
        token_id: u256,
        initial_supply: u256,
        contract_uri: ByteArray
    ) {
        self.erc6909._set_contract_uri(contract_uri);
        self.erc6909.mint(recipient, token_id, initial_supply);
    }

    #[abi(per_item)]
    #[generate_trait]
    impl MetadataImpl of MetadataTrait {
        #[external(v0)]
        fn name(self: @ContractState) -> ByteArray {
          "MyToken"
        }

        #[external(v0)]
        fn symbol(self: @ContractState) -> ByteArray {
          "MTK"
        }

        #[external(v0)]
        fn decimals(self: @ContractState) -> u8 {
          18
        }
    }
}
----

== Storing ERC6909 URIs

Token URI and Contract URI are also not part of the EIP. To implement these, the implementation `ERC6909ContentURIImpl` must be imported in the token contract. The contract URI
ideally would be initialized in the constructor via `_set_contract_uri` as shown above.

The base URI is stored as a ByteArray and the full token URI is returned as the ByteArray concatenation of the base URI and the token ID through the token_uri method. 
This design mirrors OpenZeppelin’s default Solidity implementation for ERC721.
