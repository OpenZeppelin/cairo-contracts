= ERC721

:token-types: https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[non-fungible tokens]
:eip721: https://eips.ethereum.org/EIPS/eip-721[EIP-721]
:erc721-api: xref:/api/erc721.adoc[API Reference]
:introspection: xref:/introspection.adoc[Introspection]

The ERC721 token standard is a specification for {token-types}, or more colloquially: NFTs.
The `erc721.cairo` contract implements an approximation of {eip721} in Cairo for StarkNet.

TIP: For detailed information on the usage and implementation check the {erc721-api} section.

== IERC721

[,javascript]
----
trait IERC721 {
    fn balance_of(account: ContractAddress) -> u256;
    fn owner_of(token_id: u256) -> ContractAddress;
    fn transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256
    );
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    );
    fn approve(to: ContractAddress, token_id: u256);
    fn set_approval_for_all(
        operator: ContractAddress,
        approved: bool
    );
    fn get_approved(token_id: u256) -> ContractAddress;
    fn is_approved_for_all(
        owner: ContractAddress, operator: ContractAddress
    ) -> bool;
}

trait ISRC5 {
    fn supports_interface(interface_id: felt252) -> bool;
}
----

=== ERC721 Compatibility

:erc165-storage: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v0.6.1/contracts/utils/introspection/ERC165Storage.sol[ERC165Storage]

Although StarkNet is not EVM compatible, this implementation aims to be as close as possible to the ERC721 standard in the following ways:

* It makes use of Cairo's short strings to simulate `name` and `symbol`.

But some differences can still be found, such as:

* `token_uri` returns a felt252 representation of the queried token's URI.
The EIP721 standard, however, states that the return value should be of type string.
If a token's URI is not set, the returned value is `0`.
Note that URIs cannot exceed 31 characters at this time.
See <<storing_erc721_uris,Storing ERC721 URIs>>.
* ``interface_id``s are hardcoded and initialized by the constructor.
The hardcoded values derive from Starknet's selector calculcations.
See the {introspection} docs.
* `safe_transfer_from` can only be expressed as a single function in Cairo as opposed to the two functions declared in EIP721.
The difference between both functions consists of accepting `data` as an argument.
Because function overloading is currently not possible in Cairo, `safe_transfer_from` by default accepts the `data` argument.
If `data` is not used, simply pass an empty array.
* `safe_transfer_from` is specified such that the optional `data` argument should be of type bytes.
In Solidity, this means a dynamically-sized array.
To be as close as possible to the standard, it accepts a dynamic array of felts.
* `SRC5.register_interface` allows contracts to set and communicate which interfaces they support.
This is similar to OpenZeppelin's {erc165-storage}.
* `IERC721Receiver` compliant contracts return a hardcoded selector id according to Starknet selectors (as opposed to selector calculation in Solidity).

== Usage

:components: https://community.starknet.io/t/cairo-1-contract-syntax-is-evolving/94794#extensibility-and-components-11[Components]

WARNING: The following example uses a contract's `unsafe_new_contract_state` to access another contract's state.
This is currently unsafe, because storage members could clash among used contracts if not reviewed carefully.
Extensibility will be revisited after {components} are introduced.

Using Contracts for Cairo, constructing an ERC721 contract requires setting up the constructor and exposing the ERC721 interface.
Hereâ€™s what that looks like:

[,javascript]
----
#[starknet::contract]
mod MyNFT {
    use starknet::ContractAddress;
    use openzeppelin::token::erc721::ERC721;
    use openzeppelin::token::erc721::interface;
    use openzeppelin::introspection::interface::ISRC5;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(
        self: @ContractState,
        recipient: ContractAddress
    ) {
        let name = 'MyNFT';
        let symbol = 'NFT';
        let token_id = 1;
        let token_uri = 'NFT_URI';

        let mut unsafe_state = ERC721::unsafe_new_contract_state();
        // Initialize ERC721
        ERC721::InternalImpl::initializer(ref unsafe_state, name, symbol);
        // Mint NFT
        ERC721::InternalImpl::_mint(ref unsafe_state, recipient, token_id);
        // Set the token's URI
        ERC721::InternalImpl::_set_token_uri(ref unsafe_state, token_id, token_uri);
    }

    /// Implement the ISRC5 interface.
    #[external(v0)]
    impl SRC5Impl of ISRC5<ContractState> {
        fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {
            let unsafe_state = ERC721::unsafe_new_contract_state();
            ERC721::SRC5Impl::supports_interface(@unsafe_state, interface_id)
        }
    }

    /// Implement the standard IERC721 interface.
    #[external(v0)]
    impl MyTokenImpl of interface::IERC721<ContractState> {
        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {
            let unsafe_state = ERC721::unsafe_new_contract_state();
            ERC721::ERC721Impl::balance_of(@unsafe_state, account) 
        }

        (...)
    }

    /// Implement the IERC721Metadata interface.
    #[external(v0)]
    impl MyTokenMetadataImpl of interface::IERC721Metadata<ContractState> {
        fn name(self: @ContractState) -> felt252 {
            let unsafe_state = ERC721::unsafe_new_contract_state();
            ERC721::ERC721Impl::name(@unsafe_state) 
        }

        (...)
    }
}
----

In order for the `MyNFT` contract to extend the ERC721 contract, it utilizes the `unsafe_new_contract_state`.
The unsafe contract state allows access to ERC721's implementations.
With this access, the constructor first calls the initializer to set the NFT name and symbol.
The constructor then calls `_mint` to create a one-of-one NFT. Finally, the constructor sets the token URI.

Below the constructor, this contract includes two implementations: `IERC721` and `IERC721Metadata`.
`IERC721Metadata` isn't technically required to create an ERC721 contract; however, most contracts include the metadata interface which exposes `name`, `symbol`, and `token_uri`.

=== Token Transfers

:src-5: xref:introspection.adoc#src5[SRC-5]

This library includes `transfer_from` and `safe_transfer_from` to transfer NFTs.
If using `transfer_from`, *the caller is responsible to confirm that the recipient is capable of receiving NFTs or else they may be permanently lost.*
The `safe_transfer_from` method mitigates this risk by querying the recipient contract's interface support.


The safe mechanism first queries if the recipient contract supports the IERC721Receiver interface through introspection ({src-5}).
If the recipient contract does _not_ support the receiver interface, then the safe mechanism checks if the recipient contract supports the ISRC-6 interface, which is the standard account contract interface.
If either case is true, then the token transfer behaves as if `transfer_from` was called.
Otherwise, the transfer will fail.

To better visualize the process, see the snippet below.

[,javascript]
----
fn _check_on_erc721_received(
    from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>
) -> bool {
    // Check if `to` has declared support for IERC721Receiver
    if (DualCaseSRC5 { contract_address: to }
        .supports_interface(interface::IERC721_RECEIVER_ID)) {
        DualCaseERC721Receiver { contract_address: to }
            .on_erc721_received(
                get_caller_address(), from, token_id, data
            ) == interface::IERC721_RECEIVER_ID
    } else {
        // Check if `to` is an account contract
        DualCaseSRC5 { contract_address: to }.supports_interface(account::interface::ISRC6_ID)
    }
}
----

=== Receiving tokens

:erc165-discussion: https://github.com/OpenZeppelin/cairo-contracts/discussions/100[this discussion]
:src-6: https://community.starknet.io/t/snip-starknet-standard-account/95665[SRC-6 in Starknet Shamans]
:src-5: xref:introspection.adoc#src5[SRC-5]

In order to be sure a non-account contract can safely accept ERC721 tokens, said contract must implement both the `IERC721Receiver` interface (as expressed in the EIP721 specification) and the `ISRC5` interface which supports introspection.

==== IERC721Receiver

[,javascript]
----
trait IERC721Receiver {
    fn on_erc721_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    ) -> felt252;
}
----

Implementing the `IERC721Receiver` interface exposes the `on_erc721_received` method.
When safe methods such as `safe_transfer_from` and `_safe_mint` are called, they invoke the recipient contract's `on_erc721_received` method which *must* return the IERC721Receiver interface ID.
Otherwise, the transaction will fail.

==== ISRC-5

[,javascript]
----
trait ISRC5 {
    fn supports_interface(interface_id: felt252) -> bool;
}
----

The `ISRC5` interface allows the safe methods to query if the recipient supports the `IERC721Receiver` interface ID.
See {introspection} for more information.

==== Creating a token receiver contract

[,javascript]
----
#[starknet::contract]
mod ERC721Receiver {
    use starknet::ContractAddress;
    use openzeppelin::token::erc721::ERC721;
    use openzeppelin::token::erc721::interface;
    use openzeppelin::introspection::interface::ISRC5;
    use openzeppelin::introspection::src5::SRC5;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(ref self: ContractState) {
        // Register the token receiver interface
        let mut unsafe_state = SRC5::unsafe_new_contract_state();
        SRC5::InternalImpl::register_interface(ref unsafe_state, interface::IERC721_RECEIVER_ID);
    }

    /// Implement the ISRC-5 interface so the sender contract can query
    /// if the recipient supports the token receiver interface ID
    #[external(v0)]
    impl ISRC5Impl of ISRC5<ContractState> {
        fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {
            let unsafe_state = SRC5::unsafe_new_contract_state();
            SRC5::SRC5Impl::supports_interface(@unsafe_state, interface_id)
        }
    }

    /// Implement the token receiver interface
    #[external(v0)]
    impl ERC721ReceiverImpl of interface::IERC721Receiver<ContractState> {
        fn on_erc721_received(
            self: @ContractState,
            operator: ContractAddress,
            from: ContractAddress,
            token_id: u256,
            data: Span<felt252>
        ) -> felt252 {
            interface::IERC721_RECEIVER_ID
        }
    }
}
----

=== Storing ERC721 URIs

:string-roadmap: https://github.com/orgs/starkware-libs/projects/1/views/1?pane=issue&itemId=28823165[here]

Token URIs in Cairo are stored as single field elements.
Each field element equates to 252-bits (or 31.5 bytes) which means that a token's URI can be no longer than 31 characters.

NOTE: Native string support in Cairo is currently in progress and tracked {string-roadmap}.
Once Cairo offers full string support, this will be revisited.

== Presets

ERC721 presets have been created to allow for quick deployments as-is whic are a great option for testing and prototyping.

== Extensions

ERC721 includes the optional <<erc721metadata,ERC721Metadata>> extension as well as other forthcoming extensions.

=== ERC721Metadata

[,javascript]
----
trait IERC721Metadata {
    fn name() -> felt252;
    fn symbol() -> felt252;
    fn token_uri(token_id: u256) -> felt252;
}
----

The `ERC721Metadata` extension allows a smart contract to be interrogated for its name and for details about the assets which the NFTs represent.

Contracts for Cairo follows the Solidity Contracts approach of integrating the metadata methods `name`, `symbol`, and `token_uri` (`tokenURI` in Solidity) into all ERC721 implementations.
