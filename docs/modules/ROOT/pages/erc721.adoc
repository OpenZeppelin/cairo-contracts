= ERC721

:token-types: https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[non-fungible tokens]
:eip721: https://eips.ethereum.org/EIPS/eip-721[EIP-721]
:erc721-api: xref:/api/erc721.adoc[API Reference]
:introspection: xref:/introspection.adoc[Introspection]

The ERC721 token standard is a specification for {token-types}, or more colloquially: NFTs.
The `token::erc721::ERC721` contract implements an approximation of {eip721} in Cairo for Starknet.

TIP: For detailed information on the usage and implementation check the {erc721-api} section.

== Interface

:compatibility: xref:/erc721.adoc#erc721_compatibility[ERC721 Compatibility]
:ierc721-interface: xref:/erc721.adoc#ierc721[IERC721]
:ierc721metadata-interface: xref:/erc721.adoc#ierc721metadata[IERC721Metadata]
:isrc5-interface: xref:/erc721.adoc#isrc5[ISRC5]

ERC721 contracts must implement both the {ierc721-interface} and {isrc5-interface} interfaces in order to have an ERC721-compliant contract.
Additionally, ERC721 contracts often include {ierc721metadata-interface} interface as well.
The following preset contract includes all three interfaces and represents the full interface of the `ERC721ABI` module.

WARNING: The {ierc721-interface} and {ierc721metadata-interface} interfaces are approximations of their Ethereum counterparts.
These approximations include a few notable differences.
See {compatibility} for more information.

[,javascript]
----
trait IERC721ABI {
    // IERC721
    fn balance_of(account: ContractAddress) -> u256;
    fn owner_of(token_id: u256) -> ContractAddress;
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    );
    fn transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256);
    fn approve(to: ContractAddress, token_id: u256);
    fn set_approval_for_all(operator: ContractAddress, approved: bool);
    fn get_approved(token_id: u256) -> ContractAddress;
    fn is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IERC721Metadata
    fn name() -> felt252;
    fn symbol() -> felt252;
    fn token_uri(token_id: u256) -> felt252;

    // Camel case compatibility
    fn balanceOf(account: ContractAddress) -> u256;
    fn ownerOf(tokenId: u256) -> ContractAddress;
    fn safeTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenId: u256,
        data: Span<felt252>
    );
    fn transferFrom(from: ContractAddress, to: ContractAddress, tokenId: u256);
    fn setApprovalForAll(operator: ContractAddress, approved: bool);
    fn getApproved(tokenId: u256) -> ContractAddress;
    fn isApprovedForAll(owner: ContractAddress, operator: ContractAddress) -> bool;
    fn supportsInterface(interfaceId: felt252) -> bool;
    fn tokenURI(tokenId: u256) -> felt252;
}
----

=== IERC721

The `IERC721` interface provides basic functionality to track, transfer, and consign NFTs.

[,javascript]
----
trait IERC721 {
    fn balance_of(account: ContractAddress) -> u256;
    fn owner_of(token_id: u256) -> ContractAddress;
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    );
    fn transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256
    );
    fn approve(to: ContractAddress, token_id: u256);
    fn set_approval_for_all(
        operator: ContractAddress,
        approved: bool
    );
    fn get_approved(token_id: u256) -> ContractAddress;
    fn is_approved_for_all(
        owner: ContractAddress, operator: ContractAddress
    ) -> bool;
}
----

=== ISRC5

:snip5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md[SNIP-5]
:eip165: https://eips.ethereum.org/EIPS/eip-165[EIP-165]

`ISRC5`, from the {snip5} standard, allows for other contracts to query if the implementing contract supports a specific interface.
This is especially important with NFT contracts because if an NFT is transferred to a contract that does not support the `IERC721Receiver` interface, the NFT may be lost forever.
To mitigate this risk, the `ISRC5` interface allows for interface introspection which helps facilitate safe token transfers.

TIP: `ISRC5` is very similar to Ethereum's {eip165}.
It's imperative to understand the introspection mechanism to avoid making drastic errors.
See {introspection}.

[,javascript]
----
trait ISRC5 {
    fn supports_interface(interface_id: felt252) -> bool;
}
----

=== IERC721Metadata

The `ERC721Metadata` extension allows a smart contract to be interrogated for its name and for details about the assets which the NFTs represent.
The vast majority of NFT contracts include this interface.

[,javascript]
----
trait IERC721Metadata {
    fn name() -> felt252;
    fn symbol() -> felt252;
    fn token_uri(token_id: u256) -> felt252;
}
----

=== ERC721 compatibility

:erc165-storage: https://docs.openzeppelin.com/contracts/4.x/api/utils#ERC165Storage[ERC165Storage]
:src5-api: xref:introspection.adoc#src5[SRC5]
:eip165: https://eips.ethereum.org/EIPS/eip-165[EIP165]

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC721 standard by utilizing Cairo's short strings to simulate `name` and `symbol`.
This implementation does, however, include a few notable differences such as:

* `token_uri` returns a felt252 representation of the queried token's URI.
The EIP721 standard, however, states that the return value should be of type string.
If a token's URI is not set, the returned value is `0`.
Note that URIs cannot exceed 31 characters at this time.
See <<storing_erc721_uris,Storing ERC721 URIs>>.
* ``interface_id``s are hardcoded and initialized by the constructor.
The hardcoded values derive from Starknet's selector calculations.
See the {introspection} docs.
* `safe_transfer_from` can only be expressed as a single function in Cairo as opposed to the two functions declared in EIP721, because function overloading is currently not possible in Cairo.
The difference between both functions consists of accepting `data` as an argument.
`safe_transfer_from` by default accepts the `data` argument.
If `data` is not used, simply pass an empty array.
* `safe_transfer_from` is implemented such that the optional `data` argument mimics `bytes`.
In Solidity, this means a dynamically-sized array.
To be as close as possible to the standard, it accepts a dynamic array of felts.
* ERC721 utilizes {src5-api} to declare and query interface support on Starknet as opposed to Ethereum's {eip165}.
The design for `SRC5` is similar to OpenZeppelin's {erc165-storage}.
* `IERC721Receiver` compliant contracts return a hardcoded interface ID according to Starknet selectors (as opposed to selector calculation in Solidity).

== Usage

:components: https://community.starknet.io/t/cairo-1-contract-syntax-is-evolving/94794#extensibility-and-components-11[Components]
:mint-api: xref:api/erc721.adoc#ERC721-_mint[_mint]

WARNING: The following example uses a contract's `unsafe_new_contract_state` to access another contract's state.
Although this is useful to use them as modules, it's considered unsafe because storage members could clash among used contracts if not reviewed carefully.
Extensibility will be revisited after {components} are introduced.

Using Contracts for Cairo, constructing an ERC721 contract requires setting up the constructor and exposing the ERC721 interface.
Hereâ€™s what that looks like:

[,javascript]
----
#[starknet::contract]
mod MyNFT {
    use starknet::ContractAddress;
    use openzeppelin::token::erc721::ERC721;
    use openzeppelin::token::erc721::interface;
    use openzeppelin::introspection::interface::ISRC5;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(
        self: @ContractState,
        recipient: ContractAddress
    ) {
        let name = 'MyNFT';
        let symbol = 'NFT';
        let token_id = 1;
        let token_uri = 'NFT_URI';

        let mut unsafe_state = ERC721::unsafe_new_contract_state();
        // Initialize the ERC721 storage
        ERC721::InternalImpl::initializer(ref unsafe_state, name, symbol);
        // Mint the NFT to recipient and set the token's URI
        _mint_with_uri(recipient, token_id, token_uri);
    }

    /// Implement the ISRC5 interface.
    #[external(v0)]
    impl SRC5Impl of ISRC5<ContractState> {
        fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {
            let unsafe_state = ERC721::unsafe_new_contract_state();
            ERC721::SRC5Impl::supports_interface(@unsafe_state, interface_id)
        }
    }

    /// Implement the standard IERC721 interface.
    #[external(v0)]
    impl MyTokenImpl of interface::IERC721<ContractState> {
        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {
            let unsafe_state = ERC721::unsafe_new_contract_state();
            ERC721::ERC721Impl::balance_of(@unsafe_state, account) 
        }

        (...)
    }

    /// Implement the IERC721Metadata interface.
    #[external(v0)]
    impl MyTokenMetadataImpl of interface::IERC721Metadata<ContractState> {
        fn name(self: @ContractState) -> felt252 {
            let unsafe_state = ERC721::unsafe_new_contract_state();
            ERC721::ERC721Impl::name(@unsafe_state) 
        }

        (...)
    }

    #[internal]
    fn _mint_with_uri(
        recipient: ContractAddress,
        token_id: u256,
        token_uri: felt252
    ) {
        let mut unsafe_state = ERC721::unsafe_new_contract_state();
        ERC721::InternalImpl::_mint(ref unsafe_state, recipient, token_id);
        ERC721::InternalImpl::_set_token_uri(ref unsafe_state, token_id, token_uri);
    }
}
----

In order for the `MyNFT` contract to extend the `ERC721` contract, it utilizes the `unsafe_new_contract_state`.
The unsafe contract state allows access to ``ERC721``'s storage.
With this access, the constructor first calls the initializer to set the NFT name and symbol.
Next, the constructor calls the custom internal function `_mint_with_uri` that mints a one-of-one NFT and sets the URI for the minted token ID.

=== Token transfers

:transfer_from-api: xref:api/erc721.adoc#IERC721-transfer_from[transfer_from]
:safe_transfer_from-api: xref:api/erc721.adoc#IERC721-safe_transfer_from[safe_transfer_from]

This library includes {transfer_from-api} and {safe_transfer_from-api} to transfer NFTs.
If using `transfer_from`, *the caller is responsible to confirm that the recipient is capable of receiving NFTs or else they may be permanently lost.*
The `safe_transfer_from` method mitigates this risk by querying the recipient contract's interface support.

WARNING: Usage of `safe_transfer_from` prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

=== Receiving tokens

:erc165-discussion: https://github.com/OpenZeppelin/cairo-contracts/discussions/100[this discussion]
:src5: xref:introspection.adoc#src5[SRC5]
:on_erc721_received-api: xref:api/erc721.adoc#IERC721Receiver-on_erc721_received[on_erc721_received]
:computing-interface-id: xref:introspection.adoc#computing_the_interface_id[Computing the interface ID]
:safe_transfer_from-api: xref:api/erc721.adoc#IERC721-safe_transfer_from[safe_transfer_from]
:safe_mint-api: xref:api/erc721.adoc#ERC721-_safe_mint[_safe_mint]

In order to be sure a non-account contract can safely accept ERC721 tokens, said contract must implement the `IERC721Receiver` interface.
The recipient contract must also implement the {src5} interface which, as described earlier, supports interface introspection.

==== IERC721Receiver

:receiver-id: xref:/api/erc721.adoc#IERC721Receiver[IERC721Receiver interface ID]

[,javascript]
----
trait IERC721Receiver {
    fn on_erc721_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    ) -> felt252;
}
----

Implementing the `IERC721Receiver` interface exposes the {on_erc721_received-api} method.
When safe methods such as {safe_transfer_from-api} and {safe_mint-api} are called, they invoke the recipient contract's `on_erc721_received` method which *must* return the {receiver-id}.
Otherwise, the transaction will fail.

TIP: For information on how to calculate interface IDs, see {computing-interface-id}.

==== Creating a token receiver contract

[,javascript]
----
#[starknet::contract]
mod ERC721Receiver {
    use starknet::ContractAddress;
    use openzeppelin::token::erc721::ERC721;
    use openzeppelin::token::erc721::interface;
    use openzeppelin::introspection::interface::ISRC5;
    use openzeppelin::introspection::src5::SRC5;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(ref self: ContractState) {
        // Register the token receiver interface
        let mut unsafe_state = SRC5::unsafe_new_contract_state();
        SRC5::InternalImpl::register_interface(ref unsafe_state, interface::IERC721_RECEIVER_ID);
    }

    /// Implement the ISRC5 interface so the sender contract can query
    /// if the recipient supports the token receiver interface ID.
    #[external(v0)]
    impl ISRC5Impl of ISRC5<ContractState> {
        fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {
            let unsafe_state = SRC5::unsafe_new_contract_state();
            SRC5::SRC5Impl::supports_interface(@unsafe_state, interface_id)
        }
    }

    /// Implement the token receiver interface.
    #[external(v0)]
    impl ERC721ReceiverImpl of interface::IERC721Receiver<ContractState> {
        fn on_erc721_received(
            self: @ContractState,
            operator: ContractAddress,
            from: ContractAddress,
            token_id: u256,
            data: Span<felt252>
        ) -> felt252 {
            interface::IERC721_RECEIVER_ID
        }
    }
}
----

=== Storing ERC721 URIs

:string-roadmap: https://github.com/orgs/starkware-libs/projects/1/views/1?pane=issue&itemId=28823165[here]

Token URIs in Cairo are stored as single field elements (`felt252`).
Each field element equates to 252-bits (or 31.5 bytes) which means that a token's URI can be no longer than 31 characters.

NOTE: Native string support in Cairo is currently in progress and tracked {string-roadmap}.
Once Cairo offers full string support, this will be revisited.
