:eip-6909: https://eips.ethereum.org/EIPS/eip-6909[EIP-6909]
:fungibility-agnostic: https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens[fungibility-agnostic]
:solidity-implementation: https://github.com/jtriley-eth/ERC-6909/tree/main/src

= ERC6909

The ERC6909 minimal multi token standard is a specification for {fungibility-agnostic} token contracts.
`token::erc6909::ERC6909Component` provides an approximation of {eip-6909} in Cairo for StarkNet.

== Minimal Multi Token Standard

Similar to ERC1155, it uses a single smart contract to represent multiple tokens at once via IDs. The main difference is 
that callbacks and batching have been removed from the interface and the permission system is a hybrid operator-approval
scheme for granular and scalable permissions. Functionally, the interface has been reduced to the bare minimum 
required to manage multiple tokens under the same contract.

== Usage

Using Contracts for Cairo, constructing an ERC6909 contract requires integrating the `ERC6909Component`.

Since some functions commonly found on token standards (such as `total_supply` or metadata) are not part of the EIP,
the logic for these are implemented under separate modules for ease of use. Developers can choose which modules to 
include within their contracts as they see fit. We followed the original {solidity-implementation} to replicate these in Cairo.

Aside from the core `ERC6909`, the 3 optional modules that can be imported are:

* `ERC6909Metadata`
* `ERC6909ContentURI`
* `ERC6909TokenSupply`

Each module also has their camel counterparts:

* `ERC6909MetadataCamel`
* `ERC6909ContentURICamel`
* `ERC6909TokenSupplyCamel`

To create the contract URI, it can be set up (ideally) in the constructor via `_set_contract_uri`.

Here’s an example of a basic contract which includes the Content URI and Token Supply modules:

[,cairo]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin::token::erc6909::{ERC6909Component, ERC6909HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC6909Component, storage: erc6909, event: ERC6909Event);

    // ERC6909 Mixin
    #[abi(embed_v0)]
    impl ERC6909MixinImpl = ERC6909Component::ERC6909MixinImpl<ContractState>;

    // Optional to keep track of token supplies and URIs. 
    // In this case we only use the snake_case implementations.
    #[abi(embed_v0)]
    impl ERC6909TokenSupplyImpl = ERC6909Component::ERC6909TokenSupplyImpl<ContractState>;
    #[abi(embed_v0)]
    impl ERC6909ContentURIImpl = ERC6909Component::ERC6909ContentURIImpl<ContractState>;

    impl ERC6909InternalImpl = ERC6909Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc6909: ERC6909Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC6909Event: ERC6909Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        recipient: ContractAddress,
        token_id: u256,
        initial_supply: u256,
        contract_uri: ByteArray
    ) {
        self.erc6909._set_contract_uri(contract_uri);
        self.erc6909.mint(recipient, token_id, initial_supply);
    }
}
----

`MyToken` integrates  the `ERC6909Impl`, `ERC6909TokenSupplyImpl` and `ERC6909ContentURIImpl` with the embed directives which marks the implementations as external in the contract.
While the `ERC6909TokenSupplyImpl` and `ERC6909ContentURIImpl` are optional, it's generally recommended to include them to keep track of individual token supplies and URIs.
The above example also includes the `ERC6909InternalImpl` instance, allowing the contract's constructor to set the `contract_uri` and mint an initial supply of tokens.

== Interface

:dual-interfaces: xref:/interfaces.adoc#dual_interfaces[Dual interfaces]
:erc6909-component: xref:/api/erc6909.adoc#ERC6909Component[ERC6909Component]
:ierc6909-interface: xref:/api/erc6909.adoc#IERC6909[IERC6909]

:ierc6909-supply: xref:/guides/ierc6909-supply.adoc[Creating ERC6909 Supply]
:ierc6909-content: xref:/guides/ierc6909-content.adoc[Creating ERC6909 Content URI]
:ierc6909-metadata: xref:/guides/erc6909-metadata.adoc[Creating ERC6909 Metadata]

The following interface represents the full ABI of the Contracts for Cairo {erc6909-component}.

To support older token deployments, as mentioned in {dual-interfaces}, the component also includes an implementation of the interface written in camelCase.

[,cairo]
----
#[starknet::interface]
pub trait ERC6909ABI<TState> {
    /// @notice IERC6909 standard interface
    fn balance_of(self: @TState, owner: ContractAddress, id: u256) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress, id: u256) -> u256;
    fn is_operator(self: @TState, owner: ContractAddress, spender: ContractAddress) -> bool;
    fn transfer(ref self: TState, receiver: ContractAddress, id: u256, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, receiver: ContractAddress, id: u256, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, id: u256, amount: u256) -> bool;
    fn set_operator(ref self: TState, spender: ContractAddress, approved: bool) -> bool;
    fn supports_interface(self: @TState, interface_id: felt252) -> bool;

    /// @notice IERC6909Camel
    fn balanceOf(self: @TState, owner: ContractAddress, id: u256) -> u256;
    fn isOperator(self: @TState, owner: ContractAddress, spender: ContractAddress) -> bool;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, receiver: ContractAddress, id: u256, amount: u256
    ) -> bool;
    fn setOperator(ref self: TState, spender: ContractAddress, approved: bool) -> bool;
    fn supportsInterface(self: @TState, interfaceId: felt252) -> bool;
}
----

== ERC6909 compatibility

:cairo-selectors: https://github.com/starkware-libs/cairo/blob/7dd34f6c57b7baf5cd5a30c15e00af39cb26f7e1/crates/cairo-lang-starknet/src/contract.rs#L39-L48[Cairo]
:solidity-selectors: https://solidity-by-example.org/function-selector/[Solidity]
:dual-interface: xref:/interfaces.adoc#dual_interfaces[dual interface]
:interface-id: https://community.starknet.io/t/starknet-standard-interface-detection/92664/23[interface ID]

Although Starknet is not EVM compatible, this component aims to be as close as possible to the ERC6909 token standard.
Some notable differences, however, can still be found, such as:

* The `ByteArray` type is used to represent strings in Cairo.
* The `felt252` type is used to represent the  `byte4` interface ID. The {interface-id} is also calculated different in Cairo.
* The component offers a {dual-interface} which supports both snake_case and camelCase methods, as opposed to just camelCase in Solidity.
* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.

== Customizing Token Metadata

Metadata is not required as per the EIP so it is included as a separate optional module.

Since ERC6909 is a multi-token standard, instead of having a single `name`, `decimals`, and `symbol` functions for the entire token contract,
the optional module defines these metadata properties for each token ID individually.

There are 3 internal methods which can be used to set individual id metadata: `_set_token_name(id, name)`, `_set_token_symbol(id, symbol)` and `_set_token_decimals(id, decimals)`.

Developers can also just set a single `name`, `decimals` and `symbol` for the whole contract which might prove to be simpler (just like in the ERC20 standard).

[,cairo]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin::token::erc6909::{ERC6909Component, ERC6909HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC6909Component, storage: erc6909, event: ERC6909Event);

    // ERC6909 Mixin
    #[abi(embed_v0)]
    impl ERC6909MixinImpl = ERC6909Component::ERC6909MixinImpl<ContractState>;

    // Optional to keep track of token supplies and URIs. 
    // In this case we only use the snake_case implementations.
    #[abi(embed_v0)]
    impl ERC6909TokenSupplyImpl = ERC6909Component::ERC6909TokenSupplyImpl<ContractState>;
    #[abi(embed_v0)]
    impl ERC6909ContentURIImpl = ERC6909Component::ERC6909ContentURIImpl<ContractState>;

    impl ERC6909InternalImpl = ERC6909Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc6909: ERC6909Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC6909Event: ERC6909Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        recipient: ContractAddress,
        token_id: u256,
        initial_supply: u256,
        contract_uri: ByteArray
    ) {
        self.erc6909._set_contract_uri(contract_uri);
        self.erc6909.mint(recipient, token_id, initial_supply);
    }

    #[abi(per_item)]
    #[generate_trait]
    impl MetadataImpl of MetadataTrait {
        #[external(v0)]
        fn name(self: @ContractState) -> ByteArray {
          "MyToken"
        }

        #[external(v0)]
        fn symbol(self: @ContractState) -> ByteArray {
          "MTK"
        }

        #[external(v0)]
        fn decimals(self: @ContractState) -> u8 {
          18
        }
    }
}
----

== Storing ERC6909 URIs

Token URI and Contract URI are also not part of the EIP. To implement these, the implementation `ERC6909ContentURIImpl` must be imported in the token contract. The contract URI
ideally would be initialized in the constructor via `_set_contract_uri` as shown above.

The base URI is stored as a ByteArray and the full token URI is returned as the ByteArray concatenation of the base URI and the token ID through the token_uri method. 
This design mirrors OpenZeppelin’s default Solidity implementation for ERC721.
