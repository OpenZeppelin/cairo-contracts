= ERC721

:token-types: https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[non-fungible tokens]
:eip721: https://eips.ethereum.org/EIPS/eip-721[EIP-721]
:erc721-api: xref:/api/erc721.adoc[API Reference]

The ERC721 token standard is a specification for {token-types}, or more colloquially: NFTs.
The `erc721.cairo` contract implements an approximation of {eip721} in Cairo for StarkNet.

TIP: For detailed information on the usage and implementation check the {erc721-api} section.

== Table of Contents

* <<ierc721,IERC721>>
** <<erc721_compatibility,ERC721 Compatibility>>
* <<usage,Usage>>
 ** <<token_transfers,Token Transfers>>
 ** <<receiving_tokens,Receiving tokens>>
 ** <<interpreting_erc721_uris,Interpreting ERC721 URIs>>
* <<presets,Presets>>
* <<extensions,Extensions>>
 ** <<erc721metadata,ERC721Metadata>>

== IERC721

[,javascript]
----
trait IERC721 {
    fn balance_of(account: ContractAddress) -> u256;
    fn owner_of(token_id: u256) -> ContractAddress;
    fn transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256
    );
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    );
    fn approve(to: ContractAddress, token_id: u256);
    fn set_approval_for_all(
        operator: ContractAddress,
        approved: bool
    );
    fn get_approved(token_id: u256) -> ContractAddress;
    fn is_approved_for_all(
        owner: ContractAddress, operator: ContractAddress
    ) -> bool;
}

trait ISRC5 {
    fn supports_interface(interface_id: felt252) -> bool;
}
----

=== ERC721 Compatibility

:erc165-storage: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v0.6.1/contracts/utils/introspection/ERC165Storage.sol[ERC165Storage]

Although StarkNet is not EVM compatible, this implementation aims to be as close as possible to the ERC721 standard in the following ways:

* It uses Cairo's `u256` instead of `felt252`.
* It makes use of Cairo's short strings to simulate `name` and `symbol`.

But some differences can still be found, such as:

* `token_uri` returns a felt252 representation of the queried token's URI.
The EIP721 standard, however, states that the return value should be of type string.
If a token's URI is not set, the returned value is `0`.
Note that URIs cannot exceed 31 characters at this time.
See <<interpreting_erc721_uris,Interpreting ERC721 URIs>>.
* ``interface_id``s are hardcoded and initialized by the constructor.
The hardcoded values derive from Starknet's selector calculcations.
See <<supporting_interfaces,Supporting Interfaces>>.
* `safe_transfer_from` can only be expressed as a single function in Cairo as opposed to the two functions declared in EIP721.
The difference between both functions consists of accepting `data` as an argument.
Because function overloading is currently not possible in Cairo, `safe_transfer_from` by default accepts the `data` argument.
If `data` is not used, simply pass an empty array.
* `safe_transfer_from` is specified such that the optional `data` argument should be of type bytes.
In Solidity, this means a dynamically-sized array.
To be as close as possible to the standard, it accepts a dynamic array of felts.
* `SRC5.register_interface` allows contracts to set and communicate which interfaces they support.
This is similar to OpenZeppelin's {erc165-storage}.
* `IERC721Receiver` compliant contracts return a hardcoded selector id according to Starknet selectors (as opposed to selector calculation in Solidity).
In doing so, recipient contracts (both accounts and non-accounts) can be verified that they support ERC721 transfers.

== Usage

=== Token Transfers

This library includes `transfer_from` and `safe_transfer_from` to transfer NFTs.
If using `transfer_from`, *the caller is responsible to confirm that the recipient is capable of receiving NFTs or else they may be permanently lost.*

The `safe_transfer_from` method incorporates the following conditional logic:

. If the calling address is an account contract, the token transfer will behave as if `transfer_from` was called.
. If the calling address is not an account contract, the safe function will check that the contract supports ERC721 tokens.

The current implementation of `safe_transfer_from` checks for `on_erc721_received` and requires that the recipient contract supports SRC5 and exposes the `supports_interface` method.
See <<erc721received,ERC721Received>>.

=== Receiving tokens

:erc165-discussion: https://github.com/OpenZeppelin/cairo-contracts/discussions/100[this discussion]
:src-6: https://community.starknet.io/t/snip-starknet-standard-account/95665[SRC-6 in Starknet Shamans]
:src-5: xref:introspection.adoc#src5[SRC-5]

In order to be sure a contract can safely accept ERC721 tokens, said contract must implement the `IERC721Receiver` interface (as expressed in the EIP721 specification).
Methods such as `safe_transfer_from` and `_safe_mint` call the recipient contract's `on_erc721_received` method.
If the contract fails to return the correct magic value, the transaction fails.

Starknet contracts that support safe transfers, however, must also support {src-5} and include `supports_interface` as proposed (originally as ERC165) in {erc165-discussion}.
`safe_transfer_from` requires a means of differentiating between account and non-account contracts.
Account contracts must support the Starknet standard account interface in order to communicate the contract's ability to receive safe NFT transfers.
The standard account interface is drafted and defined as {src-6}.
`on_erc721_received` will call `supports_interface` with the SRC6 magic value _0x2ceccef7f994940b3962a6c67e0ba4fcd37df7d131417c604f91e03caecc1cd_ on the recipient address.
SRC6-compliant account contracts will return `true` thus communicating that the recipient is an account contract.
Non-account contracts, however, _must_ register support for ERC721 safe transfers.
Otherwise, the safe transfer will fail.

==== IERC721Receiver

The IERC721Receiver interface must be implemented in any non-account contract that wants to support safe transfers from ERC721 asset contracts.

[,javascript]
----
trait IERC721Receiver {
    fn on_erc721_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    ) -> felt252;
}
----

=== Interpreting ERC721 URIs

Token URIs in Cairo are stored as single field elements.
Each field element equates to 252-bits (or 31.5 bytes) which means that a token's URI can be no longer than 31 characters.

NOTE: Storing the URI as an array of felts was considered to accommodate larger strings.
While this approach is more flexible regarding URIs, a returned array further deviates from the standard set in https://eips.ethereum.org/EIPS/eip-721[EIP721].
Therefore, this library's ERC721 implementation sets URIs as a single field element.

== Presets

ERC721 presets have been created to allow for quick deployments as-is whic are a great option for testing and prototyping.

== Extensions

ERC721 includes the optional <<erc721metadata,ERC721Metadata>> extension as well as other forthcoming extensions.

=== ERC721Metadata

[,javascript]
----
trait IERC721Metadata {
    fn name() -> felt252;
    fn symbol() -> felt252;
    fn token_uri(token_id: u256) -> felt252;
}
----

The `ERC721Metadata` extension allows your smart contract to be interrogated for its name and for details about the assets which your NFTs represent.

We follow OpenZeppelin's Solidity approach of integrating the Metadata methods `name`, `symbol`, and `token_uri` (`tokenURI` in Solidity) into all ERC721 implementations.
If preferred, a contract can be created that does not import the Metadata methods from the `ERC721` library.
Note that the `IERC721Metadata` interface id should be removed from the constructor as well.
