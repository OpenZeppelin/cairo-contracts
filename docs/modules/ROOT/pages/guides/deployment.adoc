:foundry: https://foundry-rs.github.io/starknet-foundry/starknet/account.html[Starknet Foundry]
:starkli: https://book.starkli.rs/accounts#account-deployment[Starkli]

= Counterfactual deployments

A deployment is said to be counterfactual when the one paying for the deployment fees is the address of the contract to be deployed. In other words, we need to send the funds to the address even when the deployment hasnâ€™t happened.

This process can be described with the following steps:

TIP: For testing this flow you can check the {foundry} or the {starkli} guides for deploying accounts.

1. Deterministically precompute the `contract_address` given a `class_hash`, `salt`, and constructor `calldata`. Note that the `class_hash` must be previously declared for the deployment to succeed.

2. Send funds to the `contract_address`. Usually you will estimate the fee of the transaction first. Existing tools usually do this for you.

3. Send a `DeployAccount` type transaction to the network.

4. The protocol will then validate the transaction with the `\\__validate_deploy__` entrypoint.

5. If the validation succeeds, the protocol will charge the fee and then register the contract as deployed.


== Deployment validation

For counterfactual deployments, contracts must implement the `\\__validate_deploy__` entrypoint, and it is called by the protocol when a `DeployAccount` transaction is sent to the network.

[,javascript]
----
trait IDeployable {
    /// Must return 'VALID' when the validation is successful.
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, _public_key: felt252
    ) -> felt252;
}
----
