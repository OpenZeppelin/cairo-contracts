= ERC6909

:fungibility-agnostic: https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens[fungibility-agnostic]
:eip-6909: https://eips.ethereum.org/EIPS/eip-6909[EIP-6909]

The ERC6909 minimal multi token standard is a specification for {fungibility-agnostic} token contracts.
`token::erc6909::ERC6909Component` provides an approximation of {eip-6909} in Cairo for StarkNet.

== Minimal Multi Token Standard

Similar to ERC1155, it uses a single smart contract to represent multiple tokens via unique IDs. The main difference is 
that in ERC6909 "the callbacks and batching have been removed from the interface and the permission system is a hybrid operator-approval
scheme for granular and scalable permissions. Functionally, the interface has been reduced to the bare minimum 
required to manage multiple tokens under the same contract." {eip-6909}

== Usage

:eip-6909: https://eips.ethereum.org/EIPS/eip-6909[EIP-6909]
:erc6909-extensions: xref:/guides/erc6909-extensions.adoc[ERC6909 Extensions]

The ERC6909 minimal multi token standard is a specification for {fungibility-agnostic} token contracts.

Using Contracts for Cairo, constructing an ERC6909 contract requires integrating the `ERC6909Component`.
Here's an example of a basic ERC6909 contract:

[,cairo]
----
#[starknet::contract]
mod MyERC6909Token {
    use openzeppelin::token::erc6909::{ERC6909Component, ERC6909HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC6909Component, storage: erc6909, event: ERC6909Event);

    // ERC6909 Mixin
    #[abi(embed_v0)]
    impl ERC6909MixinImpl = ERC6909Component::ERC6909MixinImpl<ContractState>;
    impl ERC6909InternalImpl = ERC6909Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc6909: ERC6909Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC6909Event: ERC6909Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        recipient: ContractAddress,
        token_id: u256,
        initial_supply: u256,
        contract_uri: ByteArray
    ) {
        self.erc6909.mint(recipient, token_id, initial_supply);
    }
}
----

`MyERC6909Token` integrates the `ERC6909Impl` with the embed directive which marks the implementation as external in the contract
by importing the `ERC6909Mixin` which has both camel and snake-case functions.

The above example also includes the `ERC6909InternalImpl` instance to access internal functions (such as `mint`)

There are 3 optional extensions which can also be imported into `MyERC6909Token`:

* `ERC6909ContentURI` - Allows to set the base contract URI and thus show individual token URIs.
* `ERC6909Metadata` - Allows to set the `name`, `symbol` and `decimals` of each token ID.
* `ERC6909TokenSupply` - Allows to keep track of individual token supplies upon mints and burns.

TIP: For a more complete guide on using these extensions, see {erc6909-extensions}.

== Interface

:dual-interfaces: xref:/interfaces.adoc#dual_interfaces[Dual interfaces]
:ierc6909-interface: xref:/api/erc6909.adoc#IERC6909[IERC6909]
:ierc6909_metadata-interface: xref:/api/erc6909.adoc#IERC6909Metadata[IERC6909Metadata]
:ierc6909_tokensupply-interface: xref:/api/erc6909.adoc#IERC6909TokenSupply[IERC6909TokenSupply]
:ierc6909_contenturi-interface: xref:/api/erc6909.adoc#IERC6909ContentURI[IERC6909ContentURI]
:erc6909-component: xref:/api/erc6909.adoc#ERC6909Component[ERC6909Component]

The following interface represents the full ABI of the Contracts for Cairo {erc6909-component}.
The interface includes the {ierc6909-interface} standard interface.

To support older token deployments, as mentioned in {dual-interfaces}, the component also includes an implementation of the interface written in camelCase.

[,cairo]
----
#[starknet::interface]
pub trait ERC6909ABI<TState> {
    /// @notice IERC6909 standard interface
    fn balance_of(self: @TState, owner: ContractAddress, id: u256) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress, id: u256) -> u256;
    fn is_operator(self: @TState, owner: ContractAddress, spender: ContractAddress) -> bool;
    fn transfer(ref self: TState, receiver: ContractAddress, id: u256, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, receiver: ContractAddress, id: u256, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, id: u256, amount: u256) -> bool;
    fn set_operator(ref self: TState, spender: ContractAddress, approved: bool) -> bool;
    fn supports_interface(self: @TState, interface_id: felt252) -> bool;

    /// @notice IERC6909Camel
    fn balanceOf(self: @TState, owner: ContractAddress, id: u256) -> u256;
    fn isOperator(self: @TState, owner: ContractAddress, spender: ContractAddress) -> bool;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, receiver: ContractAddress, id: u256, amount: u256
    ) -> bool;
    fn setOperator(ref self: TState, spender: ContractAddress, approved: bool) -> bool;
    fn supportsInterface(self: @TState, interfaceId: felt252) -> bool;
}
----

== ERC6909 compatibility

:cairo-selectors: https://github.com/starkware-libs/cairo/blob/7dd34f6c57b7baf5cd5a30c15e00af39cb26f7e1/crates/cairo-lang-starknet/src/contract.rs#L39-L48[Cairo]
:solidity-selectors: https://solidity-by-example.org/function-selector/[Solidity]
:dual-interface: xref:/interfaces.adoc#dual_interfaces[dual interface]
:interface-id: https://community.starknet.io/t/starknet-standard-interface-detection/92664/23[interface ID]

Although Starknet is not EVM compatible, this component aims to be as close as possible to the ERC6909 token standard.
Some notable differences, however, can still be found, such as:

* The `ByteArray` type is used to represent strings in Cairo in the Metadata extension.
* The `felt252` type is used to represent the  `byte4` interface ID. The {interface-id} is also calculated different in Cairo.
* The component offers a {dual-interface} which supports both snake_case and camelCase methods, as opposed to just camelCase in Solidity.
* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.
