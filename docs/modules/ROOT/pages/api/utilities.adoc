= Utilities

:deploy_syscall: link:https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#deploy[deploy_syscall]

The following documentation provides reasoning and examples for functions and constants found in `openzeppelin_utils`
and `openzeppelin_utils::test_utils`.

CAUTION: Expect this module to evolve (as it has already done).

== Core utilities

[.contract]
[[utils]]
=== `++utils++`

```cairo
use openzeppelin_utils;
```

Module containing core utilities of the library.

[.contract-index]
.Members
--
.Functions
* xref:#utils-try_selector_with_fallback[`++try_selector_with_fallback(target, selector, fallback, args)++`]

.Traits
* xref:#utils-UnwrapAndCast[`++UnwrapAndCast++`]

.Inner modules
* xref:#utils-cryptography[`++cryptography++`]
* xref:#utils-deployments[`++deployments++`]
* xref:#utils-math[`++math++`]
* xref:#utils-selectors[`++selectors++`]
* xref:#utils-serde[`++serde++`]
--

[#utils-Functions]
==== Functions

[.contract-item]
[[utils-try_selector_with_fallback]]
==== `[.contract-item-name]#++try_selector_with_fallback++#++(target: ContractAddress, selector: felt252, fallback: felt252, args: Span<felt252>) → SyscallResult<Span<felt252>>++` [.item-kind]#function#

Tries to call a given selector on a given contract, and if it fails, tries to call a fallback selector.

It was designed for falling back to the `camelCase` selector for backward compatibility in the
case of a failure of the `snake_case` selector.

Returns a `SyscallResult` with the result of the successful call.

Note that:

- If the first call succeeds, the second call is not attempted.

- If the first call fails with an error different than `ENTRYPOINT_NOT_FOUND`, the error is returned
without falling back to the second selector.

- If the first call fails with `ENTRYPOINT_NOT_FOUND`, the second call is attempted, and if it fails its
error is returned.

WARNING: The fallback mechanism won't work on live chains (mainnet or testnets) until
they implement panic handling in their runtime.

[#utils-Traits]
==== Traits

[.contract-item]
[[utils-UnwrapAndCast]]
==== `[.contract-item-name]#++UnwrapAndCast++#` [.item-kind]#trait#

Trait for exposing an `unwrap_and_cast` function to `SyscallResult` objects. This may be useful
when unwrapping a syscall result to a type implementing the `Serde` trait, and you want to avoid the boilerplate of
casting and unwrapping the result multiple times.

Usage example:

```cairo
use openzeppelin_utils::selectors;
use openzeppelin_utils::UnwrapAndCast;

fn call_and_cast_to_bool(target: ContractAddress, args: Span<felt252>) -> bool {
    try_selector_with_fallback(
        target, selectors::has_role, selectors::hasRole, args
    ).unwrap_and_cast()
}

fn call_and_cast_to_felt252(target: ContractAddress, args: Span<felt252>) -> felt252 {
    try_selector_with_fallback(
        target, selectors::get_role_admin, selectors::getRoleAdmin, args
    ).unwrap_and_cast()
}
```

Note that it can be automatically casted to any type implementing the `Serde` trait.

[#utils-Inner-Modules]
==== Inner modules

[.contract-item]
[[utils-cryptography]]
==== `[.contract-item-name]#++cryptography++#` [.item-kind]#module#

See xref:#cryptography[`openzeppelin_utils::cryptography`].

[.contract-item]
[[utils-deployments]]
==== `[.contract-item-name]#++deployments++#` [.item-kind]#module#

See xref:#deployments[`openzeppelin_utils::deployments`].

[.contract-item]
[[utils-math]]
==== `[.contract-item-name]#++math++#` [.item-kind]#module#

See xref:#math[`openzeppelin_utils::math`].

[.contract-item]
[[utils-selectors]]
==== `[.contract-item-name]#++selectors++#` [.item-kind]#module#

See xref:#selectors[`openzeppelin_utils::selectors`].

[.contract-item]
[[utils-serde]]
==== `[.contract-item-name]#++serde++#` [.item-kind]#module#

See xref:#serde[`openzeppelin_utils::serde`].

[.contract]
[[cryptography]]
=== `++cryptography++`

:snip12: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md[SNIP12]

```cairo
use openzeppelin_utils::cryptography;
```

Module containing utilities related to cryptography.

[.contract-index]
.Members
--
.Inner modules
* xref:#cryptography-nonces[`++nonces++`]
* xref:#cryptography-snip12[`++snip12++`]
--

[#cryptography-Inner modules]
==== Inner modules

[.contract-item]
[[cryptography-nonces]]
==== `[.contract-item-name]#++nonces++#` [.item-kind]#module#

See xref:#NoncesComponent[`openzeppelin_utils::cryptography::nonces::NoncesComponent`].

[.contract-item]
[[cryptography-snip12]]
==== `[.contract-item-name]#++snip12++#` [.item-kind]#module#

See xref:#snip12[`openzeppelin_utils::cryptography::snip12`].

[.contract]
[[deployments]]
=== `++deployments++`

:udc-doc: xref:/udc.adoc[Universal Deployer Contract]

```cairo
use openzeppelin_utils::deployments;
```

Module containing utility functions for calculating contract addresses through {deploy_syscall} and the {udc-doc} (UDC).

[.contract-index]
.Members
--
.Structs
* xref:deployments-DeployerInfo[`++DeployerInfo(caller_address, udc_address)++`]

.Functions
* xref:deployments-calculate_contract_address_from_deploy_syscall[`++calculate_contract_address_from_deploy_syscall(salt, class_hash, constructor_calldata, deployer_address)++`]
* xref:deployments-compute_hash_on_elements[`++compute_hash_on_elements(data)++`]
* xref:deployments-calculate_contract_address_from_udc[`++calculate_contract_address_from_udc(salt, class_hash, constructor_calldata, deployer_info)++`]
--

[#deployments-Structs]
==== Structs

:calculate_contract_address_from_udc: xref:deployments-calculate_contract_address_from_udc[utils::calculate_contract_address_from_udc]

[.contract-item]
[[deployments-DeployerInfo]]
==== `[.contract-item-name]#++DeployerInfo++#++(caller_address: ContractAddress, udc_address: ContractAddress)++` [.item-kind]#struct#

Struct containing arguments necessary in {calculate_contract_address_from_udc} for origin-dependent deployment calculations.

[#deployments-Functions]
==== Functions

:deployer-info: xref:deployments-DeployerInfo[DeployerInfo]

[.contract-item]
[[deployments-calculate_contract_address_from_deploy_syscall]]
==== `[.contract-item-name]#++calculate_contract_address_from_deploy_syscall++#++(salt: felt252, class_hash: ClassHash, constructor_calldata: Span<felt252>, deployer_address: ContractAddress) → ContractAddress++` [.item-kind]#function#

Returns the contract address when passing the given arguments to {deploy_syscall}.

[.contract-item]
[[deployments-compute_hash_on_elements]]
==== `[.contract-item-name]#++compute_hash_on_elements++#++(mut data: Span<felt252>) → felt252++` [.item-kind]#function#

Creates a Pedersen hash chain with the elements of `data` and returns the finalized hash.

[.contract-item]
[[deployments-calculate_contract_address_from_udc]]
==== `[.contract-item-name]#++calculate_contract_address_from_udc++#++(salt: felt252, class_hash: ClassHash, constructor_calldata: Span<felt252>, deployer_info: Option<DeployerInfo>) → ContractAddress++` [.item-kind]#function#

Returns the calculated contract address for UDC deployments.

Origin-independent deployments (deployed from zero) should pass `Option::None` as `deployer_info`.

Origin-dependent deployments hash `salt` with `caller_address` (member of {deployer-info}) and pass the hashed salt to the inner {deploy_syscall} as the `contract_address_salt` argument.

[.contract]
[[math]]
=== `++math++`

```cairo
use openzeppelin_utils::math;
```

Module containing math utilities.

[.contract-index]
.Members
--
.Functions
* xref:#math-average[`++average(a, b)++`]
--

[#math-Functions]
==== Functions

[.contract-item]
[[math-average]]
==== `[.contract-item-name]#++average++#++(a: T, b: T) → T++` [.item-kind]#function#

Returns the average of two values. The result is rounded down.

NOTE: `T` is a generic value matching different numeric implementations.

[.contract]
[[selectors]]
=== `++selectors++`

```cairo
use openzeppelin_utils::selectors;
```

:selectors: https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.15.0-rc.0/src/utils/selectors.cairo[selectors.cairo]

Module containing constants matching multiple selectors used through the library.
To see the full list of selectors, see {selectors}.

[.contract]
[[serde]]
=== `++serde++`

```cairo
use openzeppelin_utils::serde;
```

Module containing utilities related to serialization and deserialization of Cairo data structures.

[.contract-index]
.Members
--
.Traits
* xref:#serde-SerializedAppend[`++SerializedAppend++`]
--

[#serde-Traits]
==== Traits

[.contract-item]
[[serde-SerializedAppend]]
==== `[.contract-item-name]#++SerializedAppend++#` [.item-kind]#trait#

Importing this trait allows the ability to append a serialized representation of a Cairo data structure already
implementing the `Serde` trait to a `felt252` buffer.

Usage example:

```cairo
use openzeppelin_utils::serde::SerializedAppend;
use starknet::ContractAddress;

fn to_calldata(recipient: ContractAddress, amount: u256) -> Array<felt252> {
    let mut calldata = array![];
    calldata.append_serde(recipient);
    calldata.append_serde(amount);
    calldata
}
```

Note that the `append_serde` method is automatically available for arrays of felts, and it accepts any data structure
that implements the `Serde` trait.

== Cryptography

[.contract]
[[NoncesComponent]]
=== `++NoncesComponent++`

```cairo
use openzeppelin_utils::cryptography::nonces::NoncesComponent;
```

Simple component for managing nonces.

[.contract-index#NoncesComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#NoncesComponent-Embeddable-Impls-NoncesImpl]
.NoncesImpl

* xref:#NoncesComponent-nonces[`++nonces(self, owner)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#NoncesComponent-use_nonce[`++use_nonce(self, owner)++`]
* xref:#NoncesComponent-use_checked_nonce[`++use_checked_nonce(self, owner, nonce)++`]
--

[#NoncesComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[NoncesComponent-nonces]]
==== `[.contract-item-name]#++nonces++#++(self: @ContractState, owner: ContractAddress) → felt252++` [.item-kind]#external#

Returns the next unused nonce for an `owner`.

[#NoncesComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[NoncesComponent-use_nonce]]
==== `[.contract-item-name]#++use_nonce++#++(ref self: ComponentState, owner: ContractAddress) → felt252++` [.item-kind]#internal#

Consumes a nonce, returns the current value, and increments nonce.

For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be
decremented or reset. This guarantees that the nonce never overflows.

[.contract-item]
[[NoncesComponent-use_checked_nonce]]
==== `[.contract-item-name]#++use_checked_nonce++#++(ref self: ComponentState, owner: ContractAddress, nonce: felt252) → felt252++` [.item-kind]#internal#

Same as `use_nonce` but checking that `nonce` is the next valid one for `owner`.

[.contract]
[[snip12]]
=== `++snip12++`

```cairo
use openzeppelin_utils::snip12;
```

Supports on-chain generation of message hashes compliant with {snip12}.

NOTE: For a full walkthrough on how to use this module, see the
xref:/guides/snip12.adoc[SNIP12 and Typed Messages] guide.

== Test Utilities

[.contract]
[[testutils]]
=== `++test_utils++`

```cairo
use openzeppelin_utils::test_utils;
```

[.contract-index]
.Members
--
.Inner modules
* xref:#testutils-common[`++common++`]
* xref:#testutils-deployment[`++deployment++`]
* xref:#testutils-events[`++events++`]
* xref:#testutils-signing[`++signing++`]
--

[#testutils-Inner-Modules]
==== Inner modules

[.contract-item]
==== `[.contract-item-name]#++common++#` [.item-kind]#module#

See xref:#testutils-common[`openzeppelin::test_utils::common`].

[.contract-item]
==== `[.contract-item-name]#++deployment++#` [.item-kind]#module#

See xref:#testutils-deployment[`openzeppelin::test_utils::deployment`].

[.contract-item]
==== `[.contract-item-name]#++events++#` [.item-kind]#module#

See xref:#testutils-events[`openzeppelin::test_utils::events`].

[.contract-item]
==== `[.contract-item-name]#++signing++#` [.item-kind]#module#

See xref:#testutils-signing[`openzeppelin::test_utils::signing`].

[.contract]
[[testutils-common]]
=== `++common++`

```cairo
use openzeppelin_utils::test_utils::common;
```

[.contract-index]
.Members
--
.Functions
* xref:#testutils-common-panic_data_to_byte_array[`++panic_data_to_byte_array(panic_data)++`]
* xref:#testutils-common-to_base_16_string[`++to_base_16_string(value)++`]
* xref:#testutils-common-assert_entrypoint_not_found_error[`++assert_entrypoint_not_found_error(result, selector, contract_address)++`]

.Traits
* xref:#testutils-common-IntoBase16StringTrait[`++IntoBase16StringTrait++`]
--

[#testutils-common-Functions]
==== Functions

[.contract-item]
[[testutils-common-panic_data_to_byte_array]]
==== `[.contract-item-name]#++panic_data_to_byte_array++#++(panic_data: Array<felt252>) → ByteArray++` [.item-kind]#function#

Converts panic data into a string (ByteArray).

`panic_data` is expected to be a valid serialized byte array with an extra felt252 at the beginning, which is the BYTE_ARRAY_MAGIC.

[.contract-item]
[[testutils-common-to_base_16_string]]
==== `[.contract-item-name]#++to_base_16_string++#++(value: felt252) → ByteArray++` [.item-kind]#function#

Converts a felt252 to a base 16 string padded to 66 characters (including the `0x` prefix).

[.contract-item]
[[testutils-common-assert_entrypoint_not_found_error]]
==== `[.contract-item-name]#++assert_entrypoint_not_found_error++#<T, +Drop<T>>(result: SyscallResult<T>, selector: felt252, contract_address: ContractAddress)` [.item-kind]#function#

Asserts that the syscall result of a call failed with an "Entrypoint not found" error,
following the Starknet Foundry emitted error format.

[#testutils-common-Traits]
==== Traits

[.contract-item]
[[testutils-common-IntoBase16StringTrait]]
==== `[.contract-item-name]#++IntoBase16StringTrait++#` [.item-kind]#trait#

A helper trait that enables a value to be represented as a base 16 string padded to 66 characters
(including the `0x` prefix). For that the type of the value has to implement `Into<T, felt252>` to be
convertible to `felt252`.

Usage example:

```cairo
use openzeppelin_utils::test_utils::common::IntoBase16String;

let expected_panic_message = format!(
    "Entry point selector {} not found in contract {}",
    selector.into_base_16_string(),
    contract_address.into_base_16_string()
);
```

[.contract]
[[testutils-deployment]]
=== `++deployment++`

```cairo
use openzeppelin_utils::test_utils::deployment;
```

A module containing utilities aimed to simplify declaring and deploying contracts via Starknet Foundry.

[.contract-index]
.Members
--
.Functions
* xref:#testutils-deployment-declare_class[`++declare_class(contract_name)++`]
* xref:#testutils-deployment-deploy[`++deploy(contract_class, calldata)++`]
* xref:#testutils-deployment-deploy_at[`++deploy_at(contract_class, contract_address, calldata)++`]
* xref:#testutils-deployment-deploy_another_at[`++deploy_another_at(existing, target_address, calldata)++`]
* xref:#testutils-deployment-declare_and_deploy[`++declare_and_deploy(contract_name, calldata)++`]
* xref:#testutils-deployment-declare_and_deploy_at[`++declare_and_deploy_at(contract_name, target_address, calldata)++`]
--

[#testutils-deployment-Functions]
==== Functions

[.contract-item]
[[testutils-deployment-declare_class]]
==== `[.contract-item-name]#++declare_class++#++(contract_name: ByteArray) → ContractClass++` [.item-kind]#function#

Declares a contract with a Starknet Foundry `declare` call and unwraps the result.

[.contract-item]
[[testutils-deployment-deploy]]
==== `[.contract-item-name]#++deploy++#++(contract_class: ContractClass, calldata: Array<felt252>) → ContractAddress++` [.item-kind]#function#

Deploys an instance of a contract and unwraps the result.

[.contract-item]
[[testutils-deployment-deploy_at]]
==== `[.contract-item-name]#++deploy_at++#++(contract_class: ContractClass, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Deploys an instance of a contract at a given address.

[.contract-item]
[[testutils-deployment-deploy_another_at]]
==== `[.contract-item-name]#++deploy_another_at++#++(existing: ContractAddress, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Deploys a contract using the class hash from another already-deployed contract.

Note that currently, Starknet Foundry does not support redeclaring a contract class. Consequently,
there is no direct method to deploy a second instance of a contract if neither its `ContractClass`
nor its `class_hash` is available in the context. This helper function provides a solution by retrieving
the class hash from an existing contract and using it to facilitate the deployment.

```cairo
use openzeppelin_utils::test_utils::deploy_another_at;

let sender_address = setup_account(array!['PUBKEY']);
let recipient_address = contract_address_const::<'RECIPIENT'>();
deploy_another_at(sender_address, recipient_address, array!['ANOTHER_PUBKEY']);
```

[.contract-item]
[[testutils-deployment-declare_and_deploy]]
==== `[.contract-item-name]#++declare_and_deploy++#++(contract_name: ByteArray, calldata: Array<felt252>) → ContractAddress++` [.item-kind]#function#

Combines the declaration of a class and the deployment of a contract into one function call.

[.contract-item]
[[testutils-deployment-declare_and_deploy_at]]
==== `[.contract-item-name]#++declare_and_deploy_at++#++(contract_name: ByteArray, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Combines the declaration of a class and the deployment of a contract at the given address into one function call.

[.contract]
[[testutils-events]]
=== `++events++`

```cairo
use openzeppelin_utils::test_utils::events;
use openzeppelin_utils::test_utils::events::EventSpyExt;
```

A module offering an extended set of functions for handling emitted events, enhancing the default
event utilities provided by Starknet Foundry. These functions are accessible via the `EventSpyExt`
trait implemented on the `EventSpy` struct.

[.contract-index]
.Members
--
.Functions
* xref:#testutils-events-assert_only_event[`++assert_only_event(self, from_address, event)++`]
* xref:#testutils-events-assert_emitted_single[`++assert_emitted_single(self, from_address, expected_event)++`]
* xref:#testutils-events-drop_event[`++drop_event(self)++`]
* xref:#testutils-events-drop_n_events[`++drop_n_events(self, number_to_drop)++`]
* xref:#testutils-events-drop_all_events[`++drop_all_events(self)++`]
* xref:#testutils-events-assert_no_events_left[`++assert_no_events_left(self)++`]
* xref:#testutils-events-assert_no_events_left_from[`++assert_no_events_left_from(self, from_address)++`]
* xref:#testutils-events-count_events_from[`++count_events_from(self, from_address)++`]
--

[#testutils-events-Functions]
==== Functions

[.contract-item]
[[testutils-events-assert_only_event]]
==== `[.contract-item-name]#++assert_only_event++#++<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)++` [.item-kind]#function#

Ensures that `from_address` has emitted only the `expected_event` and no additional events.

[.contract-item]
[[testutils-events-assert_emitted_single]]
==== `[.contract-item-name]#++assert_emitted_single++#++<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)++` [.item-kind]#function#

Ensures that `from_address` has emitted the `expected_event`.

[.contract-item]
[[testutils-events-drop_event]]
==== `[.contract-item-name]#++drop_event++#++(ref self: EventSpy)++` [.item-kind]#function#

Removes a single event from the queue. If the queue is empty, the function will panic.

[.contract-item]
[[testutils-events-drop_n_events]]
==== `[.contract-item-name]#++drop_n_events++#++(ref self: EventSpy, number_to_drop: u32)++` [.item-kind]#function#

Removes `number_to_drop` events from the queue. If the queue is empty, the function will panic.

[.contract-item]
[[testutils-events-drop_all_events]]
==== `[.contract-item-name]#++drop_all_events++#++(ref self: EventSpy)++` [.item-kind]#function#

Removes all events remaining on the queue. If the queue is empty already, the function will do nothing.

[.contract-item]
[[testutils-events-assert_no_events_left]]
==== `[.contract-item-name]#++assert_no_events_left++#++(ref self: EventSpy)++` [.item-kind]#function#

Ensures that there are no events remaining on the queue.

[.contract-item]
[[testutils-events-assert_no_events_left_from]]
==== `[.contract-item-name]#++assert_no_events_left_from++#++(ref self: EventSpy, from_address: ContractAddress)++` [.item-kind]#function#

Ensures that there are no events emitted from the given address remaining on the queue.

[.contract-item]
[[testutils-events-count_events_from]]
==== `[.contract-item-name]#++count_events_from++#++(ref self: EventSpy, from_address: ContractAddress) → u32++` [.item-kind]#function#

Counts the number of remaining events emitted from the given address.

[.contract]
[[testutils-signing]]
=== `++signing++`

```cairo
use openzeppelin_utils::test_utils::signing;
```

A module offering utility functions for easier management of key pairs and signatures.

[.contract-index]
.Members
--
.Functions
* xref:#testutils-signing-get_stark_keys_from[`++get_stark_keys_from(private_key)++`]
* xref:#testutils-signing-get_secp256k1_keys_from[`++get_secp256k1_keys_from(private_key)++`]

.Traits
* xref:#testutils-signing-SerializedSigning[`++SerializedSigning++`]
--

[#testutils-signing-Functions]
==== Functions

[.contract-item]
[[testutils-signing-get_stark_keys_from]]
==== `[.contract-item-name]#++get_stark_keys_from++#++(private_key: felt252) → StarkKeyPair++` [.item-kind]#function#

Builds a **Stark** Key Pair from a private key represented by a `felt252` value.

[.contract-item]
[[testutils-signing-get_secp256k1_keys_from]]
==== `[.contract-item-name]#++get_secp256k1_keys_from++#++(private_key: u256) → Secp256k1KeyPair++` [.item-kind]#function#

Builds a **Secp256k1** Key Pair from a private key represented by a `u256` value.


[#testutils-signing-Traits]
==== Traits

[.contract-item]
[[testutils-signing-SerializedSigning]]
==== `[.contract-item-name]#++SerializedSigning++#` [.item-kind]#trait#

A helper trait that facilitates signing and converting the result signature into a serialized format.

Usage example:

```cairo
use openzeppelin_utils::test_utils::signing::{
    StarkKeyPair, get_stark_keys_from, StarkSerializedSigning
};

let key_pair = get_stark_keys_from('SECRET_KEY');
let serialized_signature = key_pair.serialized_sign('TX_HASH');
```