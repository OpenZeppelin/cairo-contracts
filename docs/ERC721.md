# ERC721

The ERC721 token standard is a specification for [non-fungible tokens](https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens), or more colloquially: NFTs. The `ERC721.cairo` contract implements an approximation of [EIP-721](https://eips.ethereum.org/EIPS/eip-721) in Cairo for StarkNet.

## Table of Contents

- [Interfaces](#interfaces)
  * [IERC721](#ierc721)
  * [IERC721_Metadata](#ierc721_metadata)
  * [IERC721_Enumerable](#ierc721_enumerable)
  * [IERC721_Receiver](#ierc721_receiver)
  * [IERC165](#ierc165)
- [ERC721 Compatibility](#erc721-compatibility)
- [Usage](#usage)
  *  [Token Transfers](#token-transfers)
  *  [ERC721Received](#erc721received)
  *  [Supporting Interfaces](#supporting-interfaces)
- [Extensibility](#extensibility)
  *  [Mintable](#mintable)
  *  [Metadata](#metadata)
  *  [Enumerable](#enumerable)
- [Utilities](#utilities)
  *  [ERC721_Holder](#erc721-holder)
- [API Specification](#api-specification)
  * [`IERC721`](#ierc721-api)
    - [`balanceOf`](#-balanceOf-)
    - [`ownerOf`](#-ownerOf-)
    - [`safeTransferFrom`](#-safeTransferFrom-)
    - [`transferFrom`](#-transferFrom-)
    - [`approve`](#-approve-)
    - [`setApprovalForAll`](#-setApprovalForAll-)
    - [`getApproved`](#-getApproved-)
    - [`isApprovedForAll`](#-isApprovedForAll-)
  * [`IERC721_Metadata`](#ierc721_metadata)
    - [`name`](#-name-)
    - [`symbol`](#-symbol-)
    - [`tokenURI`](#-tokenURI-)
  * [`IERC721_Enumerable`](#ierc721_enumerable)
    - [`totalSupply`](#-supportsInterface-)
    - [`tokenByIndex`](#-supportsInterface-)
    - [`ownerOfTokenByIndex`](#-supportsInterface-)
  * [`IERC721_Receiver`](#ierc721_receiver)
    - [`onERC721Received`](#-supportsInterface-)
  * [`IERC165`](#ierc165)
    - [`supportsInterface`](#-supportsInterface-)


## Interfaces

### IERC721

```jsx
@contract_interface
namespace IERC721:
    func balanceOf(owner: felt) -> (balance: Uint256):
    end

    func ownerOf(tokenId: Uint256) -> (owner: felt):
    end

    func safeTransferFrom(
        _from: felt, 
        to: felt, 
        tokenId: Uint256, 
        data_len: felt,
        data: felt*
    ):

    func transferFrom(_from: felt, to: felt, tokenId: Uint256):
    end

    func approve(approved: felt, tokenId: Uint256):
    end

    func setApprovalForAll(operator: felt, approved: felt):
    end

    func getApproved(tokenId: Uint256) -> (approved: felt):
    end

    func isApprovedForAll(owner: felt, operator: felt) -> (isApproved: felt):
    end

    --------------- IERC165 ---------------

    func supportsInterface(interfaceId: felt) -> (success: felt):
    end
end
```

### IERC721_Metadata

```jsx
@contract_interface
namespace IERC721_Metadata:
    func name() -> (name: felt):
    end

    func symbol() -> (symbol: felt):
    end

    func tokenURI(tokenId: Uint256) -> (tokenURI: felt):
    end
end
```

### IERC721_Enumerable

```jsx
@contract_interface
namespace IERC721_Enumerable:
    func totalSupply() -> (totalSupply: Uint256):
    end

    func tokenByIndex(index: Uint256) -> (tokenId: Uint256):
    end

    func tokenOfOwnerByIndex(owner: felt, index: Uint256) -> (tokenId: Uint256):
    end
end
```

### IERC721_Receiver

```jsx
@contract_interface
namespace IERC721_Receiver:
    func onERC721Received(
        operator: felt,
        _from: felt,
        tokenId: Uint256,
        data_len: felt
        data: felt*
    ) -> (selector: felt):
    end
end
```

### IERC165
```jsx
@contract_interface
namespace IERC165:
    func supportsInterface(interfaceId: felt) -> (success: felt):
    end
end
```

### ERC721 Compatibility

Although StarkNet is not EVM compatible, this implementation aims to be as close as possible to the ERC721 standard in the following ways:

- it uses Cairo's `uint256` instead of `felt`
- it returns `1` as true/success to imitate a `bool`
- it makes use of Cairo's short strings to simulate `name` and `symbol`
- it will emit events once they're implemented on StarkNet

But some differences can still be found, such as:

- `tokenURI` returns a felt representation of the queried token's URI. The EIP721 standard, however, states that the return value should be of type string. If a token's URI is not set, the return felt is `0`
- methods that check for `interfaceId`s compare them against hardcoded `interfaceId`s calculated from the Solidity implementation
- `safeTransferFrom` can only be expressed as a single function in Cairo as opposed to the two functions declared in EIP721. The difference between both functions consists of accepting `data` as an argument. Because function overloading is currently not possible in Cairo, `safeTransferFrom` by default accepts the `data` argument. If `data` is not used, simply insert `0`.
- the EIP721 spec declares that the optional `data` argument should be of type bytes. In Solidity, this means a dynamically-sized array. To be as close as possible to the standard, `safeTransferFrom` accepts a dynamic array of felts. In Cairo, arrays are expressed with the array length preceding the actual array; hence, the method accepts `data_len` and `data` respectively as types felt and felt*
- supporting additional `interfaceId`s in ERC165's `supportsInterface` can be achieved using the setter method `ERC165_register_interface`. This follows OpenZeppelin's [ERC165Storage](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Storage.sol) approach as opposed to the ERC165 standard. See [Supporting Interfaces](#supporting-interfaces)
- the utility contract `ERC721_Holder` does not inherit `IERC721_Receiver`. In the Solidity implementation, the holder contract inherits the receiver contract and calls `onERC721Received`; where, the method returns its own selector's interface ID. This implementation simply returns the correct interface ID
- the enumerable extension tracks the total number of tokens by using the `all_tokens` and `all_tokens_len` storage variables. This differs from the Solidity implementation; where, all of the tokens are tracked using an array

## Usage

Use cases go from artwork, digital collectibles, physical property, and many more.

To show a standard use-case, we'll follow the `ERC721_Mintable` model which allows for only the owner to `mint` and `burn` tokens. Considering that the constructor method looks like this:

```python
func constructor(
    name: felt,          # Token name as Cairo short string
    symbol: felt,        # Token symbol as Cairo short string
    owner: felt          # Address designated as the contract owner
):
```

To create a token you need to first deploy the contract like this:

```python
erc721 = await starknet.deploy(
    "contracts/token/ERC721_Mintable.cairo",
    constructor_calldata=[
        str_to_felt("Token"),                       # name
        str_to_felt("TKN"),                         # symbol
        account.contract_address                    # owner
    ]
)
```

As most StarkNet contracts, it expects to be called by another contract and it identifies it through `get_caller_address` (analogous to Solidity's `this.address`). This is why we need an Account contract to interact with it. For example, to mint a non-fungible token:

```python
signer = Signer(PRIVATE_KEY)
tokenId = uint(1)

account = await starknet.deploy(
    "contracts/Account.cairo",
    constructor_calldata=[signer.public_key]
)

await signer.send_transaction(account, erc721.contract_address, 'mint', [recipient_address, *tokenId])
```

### Token Transfers

EIP721 discourages the use of `transferFrom` and favors `safeTransferFrom` in regard to token transfers; where, the safe function adds the following conditional logic:
1. if the calling address is an externally owned account (EOA), the token transfer will behave as if `transferFrom` was called
2. if the calling address is a contract, the safe function will check that the contract supports ERC721 tokens

The current implementation of `safeTansferFrom` checks for `onERC721Received`. 
Because EOAs cannot be differentiated from regular contracts on StarkNet at this time, it's recommended to transfer tokens with `transferFrom`; however, please be aware that transfering tokens to a contract that does not support ERC721 can result in lost tokens forever. 

### ERC721Received

In order to be sure a contract can safely accept ERC721 tokens, said contract must implement the `ERC721_Receiver` interface. Methods such as `safeTransferFrom` and `safeMint` call the recipient contract's `onERC721Received` method. If the contract fails to return the correct magic value, the transaction fails. 

> Please note: EOA/contract differentiation must be resolved in order to correctly use this feature

### Supporting Interfaces

In order to attain seamless layer one interoperability, this ERC721 implementation uses hardcoded interface IDs that have already been calculated on layer one. The Solidity implementation of ERC165 uses the `super` method to amend parent functions. Being that Cairo/Starknet currently does not support this feature, this implementation uses a mapping to store supported interfaces (similar to OpenZeppelin's [ERC165Storage](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Storage.sol)). 

## Extensibility

This implementation of Cairo smart contract extensibility is set up to include all ERC721 storage and function logic within the base contract `ERC721_base.cairo`. Base contract methods with the prefix `ERC721_` must be imported to the frontend contract and inserted into an `external` method with the requisite name. This is already done in `ERC721.cairo`; however, additional functionality can be added. For instance, you could:
- Implement a pausing mechanism
- Add roles such as owner or minter
- Modify the `transferFrom` function to perform actions [before](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L335)

Just be sure that the exposed `external` methods invoke their imported function logic a la `approve` invokes `ERC721_approve`. As an example, see below.

```python
from contracts.token.ERC721_base import ERC721_approve

@external
func approve{
        pedersen_ptr: HashBuiltin*, 
        syscall_ptr: felt*, 
        range_check_ptr
    }(to: felt, tokenId: Uint256):
    ERC721_approve(to, tokenId)
    return()
end

```

### Mintable

The ERC721_Mintable preset offers a quick and easy setup for creating NFTs. This preset includes two imports: Ownable and ERC721_base. Further, this contract includes `mint` and `burn` methods to create and destroy NFTs. A common implementation of ERC721 contracts include setting a check on the `mint` and `burn` methods; where, only the owner can create and destroy tokens. In this preset, the owner is set in the constructor. 

### Metadata

The Metadata extension is quite similar to the Mintable preset; however, this preset includes a baseURI parameter in the constructor and omits the `burn` method. Setting the baseURI initializes the `tokenURI` method to return an array with both the baseURI and the tokenId. Without this set, `tokenURI` returns an array with a zero value. 


### Enumerable

The Enumerable extension adds enumerability of all the token ids in the contract as well as all token ids owned by each account. This allows contracts to publish its full list of NFTs and make them discoverable. In regard to implementation, the extension exposes three new view methods as seen in the interface. Tokens are tracked via the `all_tokens_list` and `all_tokens_len`. No additional changes are required in the constructor for deployment.

## Utilities

### ERC721_Holder

Implementation of the `IERC721Receiver` interface.

Accepts all token transfers. Make sure the contract is able to use its token with `IERC721.safeTransferFrom`, `IERC721.approve` or `IERC721.setApprovalForAll`.

## API Specification

### IERC721 API

```jsx
func balanceOf(owner: felt) -> (balance: Uint256):
end

func ownerOf(tokenId: Uint256) -> (owner: felt):
end

func safeTransferFrom(
        _from: felt, 
        to: felt, 
        tokenId: Uint256, 
        data_len: felt,
        data: felt*
    ):
end

func transferFrom(_from: felt, to: felt, tokenId: Uint256):
    end

func approve(approved: felt, tokenId: Uint256):
end

func setApprovalForAll(operator: felt, approved: felt):
end

func getApproved(tokenId: Uint256) -> (approved: felt):
end

func isApprovedForAll(owner: felt, operator: felt) -> (isApproved: felt):
end

```

#### `balanceOf`

Returns the number of tokens in `owner`'s account.

Parameters:

```jsx
owner: felt
```

Returns:

```jsx
balance: Uint256
```

#### `ownerOf`

Returns the owner of the `tokenId` token.

Parameters:

```jsx
tokenId: Uint256
```

Returns:

```jsx
owner: felt
```

#### `safeTransferFrom`

Safely transfers `tokenId` token from `_from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.

> Note this function should NOT be used. EOA differentiation still needs to be resolved on StarkNet.

Parameters:

```jsx
_from: felt
to: felt
tokenId: Uint256
data_len: felt
data: felt*
```

Returns:

None.

#### `transferFrom`

Transfers `tokenId` token from `_from` to `to`.

> Note that this function should be used instead of `safeTransferFrom` to transfer tokens. Exercise caution as tokens sent to a contract that does not support ERC721 can be lost forever.

Parameters:

```jsx
_from: felt
to: felt
tokenId: Uint256
```

Returns:

None.

#### `approve`

Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred.

Parameters:

```jsx
to: felt
tokenId: Uint256
```

Returns:

None.

#### `getApproved`

Returns the account approved for `tokenId` token.

Parameters:

```jsx
tokenId: Uint256
```

Returns:

```jsx
operator: felt
```

#### `setApprovalForAll`

Approve or remove `operator` as an operator for the caller. Operators can call `transferFrom` or `safeTransferFrom` for any token owned by the caller.

Parameters:

```jsx
operator: felt
```

Returns:

None.

#### `isApprovedForAll`

Returns if the `operator` is allowed to manage all of the assets of `owner`.

Parameters:

```jsx
owner: felt
operator: felt
```

Returns:

```jsx
isApproved: felt
```

---

### IERC721_Metadata API
```jsx
func name() -> (name: felt):
end

func symbol() -> (symbol: felt):
end

func tokenURI(tokenId: Uint256) -> (uri_len: felt, uri: felt*):
end
```

#### `name`

Returns the token collection name.

Parameters:

None.

Returns:

```jsx
name: felt
```

#### `symbol`

Returns the token collection symbol.

Parameters: 

None.

Returns:

```jsx
symbol: felt
```

#### `tokenURI`

Returns the Uniform Resource Identifier (URI) for `tokenId` token. If the baseURI is not set, this function will return `[0]`. Otherwise, the returned array will return 3 values: baseURI, tokenId.low, tokenId.high. This differs from the Solidity implementation where the returned value is a concatenated string of both the baseURI and token ID.

Parameters:

```jsx
tokenId: Uint256
```

Returns:

```jsx
uri_len: felt
uri: felt*
```

---

### IERC721_Enumerable API
```jsx

func totalSupply() -> (totalSupply: Uint256):
end

func tokenByIndex(index: Uint256) -> (tokenId: Uint256):
end

func tokenOfOwnerByIndex(owner: felt, index: Uint256) -> (tokenId: Uint256):
end
```

#### `totalSupply`

Returns the total amount of tokens stored by the contract.

Parameters: None

Returns:

```jsx
totalSupply: Uint256
```

#### `tokenByIndex`

Returns a token ID owned by `owner` at a given `index` of its token list. Use along with [balanceOf](#balanceOf) to enumerate all of `owner`'s tokens.

Parameters:

```jsx
index: Uint256
```

Returns:

```jsx
tokenId: Uint256
```

#### `tokenOfOwnerByIndex`

Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with [totalSupply](#totalSupply) to enumerate all tokens.

Parameters:

```jsx
owner: felt
index: Uint256
```

Returns:

```jsx
tokenId: Uint256
```

---

### IERC721_Receiver API
```jsx

func onERC721Received(
        operator: felt, 
        _from: felt, 
        tokenId: Uint256, 
        data_len: felt
        data: felt*
    ) -> (selector: felt):
end
```

#### `onERC721Received`

Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.

Parameters:

```jsx
operator: felt
_from: felt
tokenId: Uint256
data_len: felt
data: felt*
```

Returns:

```jsx
selector: felt
```
---

### IERC165 API
```jsx
func supportsInterface(interfaceId: felt) -> (success: felt):
end
```

#### `supportsInterface`

Returns true if this contract implements the interface defined by `interfaceId`.

Parameters:

```jsx
interfaceId: felt
```

Returns:

```jsx
success: felt
```