:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:eip721: https://eips.ethereum.org/EIPS/eip-721[EIP721]
:receiving-tokens: xref:/erc721.adoc#receiving_tokens[Receiving Tokens]
:casing-discussion: https://github.com/OpenZeppelin/cairo-contracts/discussions/34[here]
:inner-src5: xref:api/introspection.adoc#ISRC5[SRC5 ID]

= ERC721

include::../utils/_common.adoc[]

Reference of interfaces, presets, and utilities related to ERC721 contracts.

TIP: For an overview of ERC721, read our xref:erc721.adoc[ERC721 guide].

== Core

[.contract]
[[IERC721]]
=== `++IERC721++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.15.0-rc.0/src/token/erc721/interface.cairo#L13-L31[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin::token::erc721::interface::IERC721;
```
Interface of the IERC721 standard as defined in {eip721}.

[.contract-index]
.{inner-src5}
--
0x33eb2f84c309543403fd69f0d0f363781ef06ef6faeb0131ff16ea3175bd943
--

[.contract-index]
.Functions
--
* xref:#IERC721-balance_of[`++balance_of(account)++`]
* xref:#IERC721-owner_of[`++owner_of(token_id)++`]
* xref:#IERC721-safe_transfer_from[`++safe_transfer_from(from, to, token_id, data)++`]
* xref:#IERC721-transfer_from[`++transfer_from(from, to, token_id)++`]
* xref:#IERC721-approve[`++approve(to, token_id)++`]
* xref:#IERC721-set_approval_for_all[`++set_approval_for_all(operator, approved)++`]
* xref:#IERC721-get_approved[`++get_approved(token_id)++`]
* xref:#IERC721-is_approved_for_all[`++is_approved_for_all(owner, operator)++`]
--

[.contract-index]
.Events
--
* xref:#IERC721-Approval[`++Approval(owner, approved, token_id)++`]
* xref:#IERC721-ApprovalForAll[`++ApprovalForAll(owner, operator, approved)++`]
* xref:#IERC721-Transfer[`++Transfer(from, to, token_id)++`]
--

==== Functions

[.contract-item]
[[IERC721-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(account: ContractAddress) → u256++` [.item-kind]#external#

Returns the number of NFTs owned by `account`.

[.contract-item]
[[IERC721-owner_of]]
==== `[.contract-item-name]#++owner_of++#++(token_id: u256) → ContractAddress++` [.item-kind]#external#

Returns the owner address of `token_id`.

[.contract-item]
[[IERC721-safe_transfer_from]]
==== `[.contract-item-name]#++safe_transfer_from++#++(from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#external#

Transfer ownership of `token_id` from `from` to `to`, checking first that `to` is aware of the ERC721 protocol to prevent tokens being locked forever.
For information regarding how contracts communicate their awareness of the ERC721 protocol, see {receiving-tokens}.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[IERC721-transfer_from]]
==== `[.contract-item-name]#++transfer_from++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

Transfer ownership of `token_id` from `from` to `to`.

Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 transfers or else they may be permanently lost.
Usage of <<IERC721-safe_transfer_from,IERC721::safe_transfer_from>> prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[IERC721-approve]]
==== `[.contract-item-name]#++approve++#++(to: ContractAddress, token_id: u256)++` [.item-kind]#external#

Change or reaffirm the approved address for an NFT.

Emits an <<IERC721-Approval,Approval>> event.

[.contract-item]
[[IERC721-set_approval_for_all]]
==== `[.contract-item-name]#++set_approval_for_all++#++(operator: ContractAddress, approved: bool)++` [.item-kind]#external#

Enable or disable approval for `operator` to manage all of the caller's assets.

Emits an <<IERC721-ApprovalForAll,ApprovalForAll>> event.

[.contract-item]
[[IERC721-get_approved]]
==== `[.contract-item-name]#++get_approved++#++(token_id: u256) -> u256++` [.item-kind]#external#

Returns the address approved for `token_id`.

[.contract-item]
[[IERC721-is_approved_for_all]]
==== `[.contract-item-name]#++is_approved_for_all++#++(owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

Query if `operator` is an authorized operator for `owner`.

==== Events

[.contract-item]
[[IERC721-Approval]]
==== `[.contract-item-name]#++Approval++#++(owner: ContractAddress, approved: ContractAddress, token_id: u256)++` [.item-kind]#event#

Emitted when `owner` enables `approved` to manage the `token_id` token.

[.contract-item]
[[IERC721-ApprovalForAll]]
==== `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#event#

Emitted when `owner` enables or disables `operator` to manage the `token_id` token.

[.contract-item]
[[IERC721-Transfer]]
==== `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#event#

Emitted when `token_id` token is transferred from `from` to `to`.

[.contract]
[[IERC721Metadata]]
=== `++IERC721Metadata++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.15.0-rc.0/src/token/erc721/interface.cairo#L54-L59[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin::token::erc721::interface::IERC721Metadata;
```

Interface for the optional metadata functions in {eip721}.

[.contract-index]
.{inner-src5}
--
0xabbcd595a567dce909050a1038e055daccb3c42af06f0add544fa90ee91f25
--

[.contract-index]
.Functions
--
* xref:#IERC721Metadata-name[`++name()++`]
* xref:#IERC721Metadata-symbol[`++symbol()++`]
* xref:#IERC721Metadata-token_uri[`++token_uri(token_id)++`]
--

==== Functions

[.contract-item]
[[IERC721Metadata-name]]
==== `[.contract-item-name]#++name++#++() -> ByteArray++` [.item-kind]#external#

Returns the NFT name.

[.contract-item]
[[IERC721Metadata-symbol]]
==== `[.contract-item-name]#++symbol++#++() -> ByteArray++` [.item-kind]#external#

Returns the NFT ticker symbol.

[.contract-item]
[[IERC721Metadata-token_uri]]
==== `[.contract-item-name]#++token_uri++#++(token_id: u256) -> ByteArray++` [.item-kind]#external#

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

[.contract]
[[ERC721Component]]
=== `++ERC721Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.15.0-rc.0/src/token/erc721/erc721.cairo#L7[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin::token::erc721::ERC721Component;
```

ERC721 component implementing <<IERC721,IERC721>> and <<IERC721Metadata,IERC721Metadata>>.

NOTE: {src5-component-required-note}

NOTE: See xref:#ERC721Component-Hooks[Hooks] to understand how are hooks used.

[.contract-index]
.Hooks
--
[.sub-index#ERC721Component-ERC721HooksTrait]
.ERC721HooksTrait
* xref:#ERC721Component-before_update[`++before_update(self, to, token_id, auth)++`]
* xref:#ERC721Component-after_update[`++after_update(self, to, token_id, auth)++`]
--

[.contract-index#ERC721Component-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.ERC721MixinImpl
* xref:#ERC721Component-Embeddable-Impls-ERC721Impl[`++ERC721Impl++`]
* xref:#ERC721Component-Embeddable-Impls-ERC721MetadataImpl[`++ERC721MetadataImpl++`]
* xref:#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl[`++ERC721CamelOnlyImpl++`]
* xref:#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl[`++ERC721MetadataCamelOnlyImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
--

[.contract-index#ERC721Component-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC721Component-Embeddable-Impls-ERC721Impl]
.ERC721Impl
* xref:#ERC721Component-balance_of[`++balance_of(self, account)++`]
* xref:#ERC721Component-owner_of[`++owner_of(self, token_id)++`]
* xref:#ERC721Component-safe_transfer_from[`++safe_transfer_from(self, from, to, token_id, data)++`]
* xref:#ERC721Component-transfer_from[`++transfer_from(self, from, to, token_id)++`]
* xref:#ERC721Component-approve[`++approve(self, to, token_id)++`]
* xref:#ERC721Component-set_approval_for_all[`++set_approval_for_all(self, operator, approved)++`]
* xref:#ERC721Component-get_approved[`++get_approved(self, token_id)++`]
* xref:#ERC721Component-is_approved_for_all[`++is_approved_for_all(self, owner, operator)++`]

[.sub-index#ERC721Component-Embeddable-Impls-ERC721MetadataImpl]
.ERC721MetadataImpl
* xref:#ERC721Component-name[`++name(self)++`]
* xref:#ERC721Component-symbol[`++symbol(self)++`]
* xref:#ERC721Component-token_uri[`++token_uri(self, token_id)++`]

[.sub-index#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl]
.ERC721CamelOnlyImpl
* xref:#ERC721Component-balanceOf[`++balanceOf(self, account)++`]
* xref:#ERC721Component-ownerOf[`++ownerOf(self, tokenId)++`]
* xref:#ERC721Component-safeTransferFrom[`++safeTransferFrom(self, from, to, tokenId, data)++`]
* xref:#ERC721Component-transferFrom[`++transferFrom(self, from, to, tokenId)++`]
* xref:#ERC721Component-setApprovalForAll[`++setApprovalForAll(self, operator, approved)++`]
* xref:#ERC721Component-getApproved[`++getApproved(self, tokenId)++`]
* xref:#ERC721Component-isApprovedForAll[`++isApprovedForAll(self, owner, operator)++`]

[.sub-index#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl]
.ERC721MetadataCamelOnlyImpl
* xref:#ERC721Component-tokenURI[`++tokenURI(self, tokenId)++`]

.SRC5Impl
* xref:api/introspection.adoc#ISRC5-supports_interface[`supports_interface(self, interface_id: felt252)`]
--

[.contract-index]
.Internal functions
--
.InternalImpl
* xref:#ERC721Component-initializer[`++initializer(self, name, symbol, base_uri)++`]
* xref:#ERC721Component-exists[`++exists(self, token_id)++`]
* xref:#ERC721Component-transfer[`++transfer(self, from, to, token_id)++`]
* xref:#ERC721Component-mint[`++mint(self, to, token_id)++`]
* xref:#ERC721Component-safe_transfer[`++safe_transfer(self, from, to, token_id, data)++`]
* xref:#ERC721Component-safe_mint[`++safe_mint(self, to, token_id, data)++`]
* xref:#ERC721Component-burn[`++burn(self, token_id)++`]
* xref:#ERC721Component-update[`++update(self, to, token_id, auth)++`]
* xref:#ERC721Component-_owner_of[`++_owner_of(self, token_id)++`]
* xref:#ERC721Component-_require_owned[`++_require_owned(self, token_id)++`]
* xref:#ERC721Component-_approve[`++_approve(self, to, token_id, auth)++`]
* xref:#ERC721Component-_approve_with_optional_event[`++_approve_with_optional_event(self, to, token_id, auth, emit_event)++`]
* xref:#ERC721Component-_set_approval_for_all[`++_set_approval_for_all(self, owner, operator, approved)++`]
* xref:#ERC721Component-_set_base_uri[`++_set_base_uri(self, base_uri)++`]
* xref:#ERC721Component-_base_uri[`++_base_uri(self)++`]
* xref:#ERC721Component-_is_authorized[`++_is_authorized(self, owner, spender, token_id)++`]
* xref:#ERC721Component-_check_authorized[`++_check_authorized(self, owner, spender, token_id)++`]
--

[.contract-index]
.Events
--
.IERC721
* xref:#ERC721Component-Approval[`++Approval(owner, approved, token_id)++`]
* xref:#ERC721Component-ApprovalForAll[`++ApprovalForAll(owner, operator, approved)++`]
* xref:#ERC721Component-Transfer[`++Transfer(from, to, token_id)++`]
--

[#ERC721Component-Hooks]
==== Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC721Component is expected to provide an implementation of the ERC721HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

TIP: You can use `openzeppelin::token::erc721::ERC721HooksEmptyImpl` which is already available as part of the library
for this purpose.

[.contract-item]
[[ERC721Component-before_update]]
==== `[.contract-item-name]#++before_update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#hook#

Function executed at the beginning of the xref:#ERC721Component-update[update] function prior to any other logic.

[.contract-item]
[[ERC721Component-after_update]]
==== `[.contract-item-name]#++after_update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#hook#

Function executed at the end of the xref:#ERC721Component-update[update] function.

==== Embeddable functions

[.contract-item]
[[ERC721Component-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(self: @ContractState, account: ContractAddress) → u256++` [.item-kind]#external#

See <<IERC721-balance_of,IERC721::balance_of>>.

[.contract-item]
[[ERC721Component-owner_of]]
==== `[.contract-item-name]#++owner_of++#++(self: @ContractState, token_id: u256) → ContractAddress++` [.item-kind]#external#

See <<IERC721-owner_of,IERC721::owner_of>>.

Requirements:

- `token_id` exists.

[.contract-item]
[[ERC721Component-safe_transfer_from]]
==== `[.contract-item-name]#++safe_transfer_from++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#external#

See <<IERC721-safe_transfer_from,IERC721::safe_transfer_from>>.

Requirements:

- Caller is either approved or the `token_id` owner.
- `to` is not the zero address.
- `from` is not the zero address.
- `token_id` exists.
- `to` is either an account contract or supports the <<IERC721Receiver,IERC721Receiver>> interface.

[.contract-item]
[[ERC721Component-transfer_from]]
==== `[.contract-item-name]#++transfer_from++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

See <<IERC721-transfer_from,IERC721::transfer_from>>.

Requirements:

- Caller either approved or the `token_id` owner.
- `to` is not the zero address.
- `from` is not the zero address.
- `token_id` exists.

[.contract-item]
[[ERC721Component-approve]]
==== `[.contract-item-name]#++approve++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

See <<IERC721-approve,IERC721::approve>>.

Requirements:

- The caller is either an approved operator or the `token_id` owner.
- `to` cannot be the token owner or the zero address.
- `token_id` exists.

[.contract-item]
[[ERC721Component-set_approval_for_all]]
==== `[.contract-item-name]#++set_approval_for_all++#++(ref self: ContractState, operator: ContractAddress, approved: bool)++` [.item-kind]#external#

See <<IERC721-set_approval_for_all,IERC721::set_approval_for_all>>.

Requirements:

- `operator` is not the zero address.

[.contract-item]
[[ERC721Component-get_approved]]
==== `[.contract-item-name]#++get_approved++#++(self: @ContractState, token_id: u256) -> u256++` [.item-kind]#external#

See <<IERC721-get_approved,IERC721::get_approved>>.

Requirements:

- `token_id` exists.

[.contract-item]
[[ERC721Component-is_approved_for_all]]
==== `[.contract-item-name]#++is_approved_for_all++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

See <<IERC721-is_approved_for_all,IERC721::is_approved_for_all>>.

[.contract-item]
[[ERC721Component-name]]
==== `[.contract-item-name]#++name++#++(self: @ContractState) -> ByteArray++` [.item-kind]#external#

See <<IERC721Metadata-name,IERC721Metadata::name>>.

[.contract-item]
[[ERC721Component-symbol]]
==== `[.contract-item-name]#++symbol++#++(self: @ContractState) -> ByteArray++` [.item-kind]#external#

See <<IERC721Metadata-symbol,IERC721Metadata::symbol>>.

[.contract-item]
[[ERC721Component-token_uri]]
==== `[.contract-item-name]#++token_uri++#++(self: @ContractState, token_id: u256) -> ByteArray++` [.item-kind]#external#

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If a base URI is set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
For example, the base URI pass:[<code>https://token-cdn-domain/</code>] would be returned as pass:[<code>https://token-cdn-domain/123</code>] for token ID `123`.

If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

[.contract-item]
[[ERC721Component-balanceOf]]
==== `[.contract-item-name]#++balanceOf++#++(self: @ContractState, account: ContractAddress) -> u256++` [.item-kind]#external#

See <<ERC721Component-balance_of,ERC721Component::balance_of>>.

[.contract-item]
[[ERC721Component-ownerOf]]
==== `[.contract-item-name]#++ownerOf++#++(self: @ContractState, tokenId: u256) -> ContractAddress++` [.item-kind]#external#

See <<ERC721Component-owner_of,ERC721Component::owner_of>>.

[.contract-item]
[[ERC721Component-safeTransferFrom]]
==== `[.contract-item-name]#++safeTransferFrom++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256, data: Span<felt252>)++` [.item-kind]#external#

See <<ERC721Component-safe_transfer_from,ERC721Component::safe_transfer_from>>.

[.contract-item]
[[ERC721Component-transferFrom]]
==== `[.contract-item-name]#++transferFrom++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256)++` [.item-kind]#external#

See <<ERC721Component-transfer_from,ERC721Component::transfer_from>>.

[.contract-item]
[[ERC721Component-setApprovalForAll]]
==== `[.contract-item-name]#++setApprovalForAll++#++(ref self: ContractState, operator: ContractAddress, approved: bool)++` [.item-kind]#external#

See <<ERC721Component-set_approval_for_all,ERC721Component::set_approval_for_all>>.

[.contract-item]
[[ERC721Component-getApproved]]
==== `[.contract-item-name]#++getApproved++#++(self: @ContractState, tokenId: u256) -> ContractAddress++` [.item-kind]#external#

See <<ERC721Component-get_approved,ERC721Component::get_approved>>.

[.contract-item]
[[ERC721Component-isApprovedForAll]]
==== `[.contract-item-name]#++isApprovedForAll++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

See <<ERC721Component-is_approved_for_all,ERC721Component::is_approved_for_all>>.

[.contract-item]
[[ERC721Component-tokenURI]]
==== `[.contract-item-name]#++tokenURI++#++(self: @ContractState, tokenId: u256) -> ByteArray++` [.item-kind]#external#

See <<ERC721Component-token_uri,ERC721Component::token_uri>>.

==== Internal functions

[.contract-item]
[[ERC721Component-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray, base_uri: ByteArray)++` [.item-kind]#internal#

Initializes the contract by setting the token name and symbol.
This should be used inside the contract's constructor.

[.contract-item]
[[ERC721Component-exists]]
==== `[.contract-item-name]#++exists++#++(self: @ContractState, token_id: u256) -> bool++` [.item-kind]#internal#

Internal function that returns whether `token_id` exists.

Tokens start existing when they are minted (<<ERC721-mint,mint>>), and stop existing when they are burned (<<ERC721-burn,burn>>).

[.contract-item]
[[ERC721Component-transfer]]
==== `[.contract-item-name]#++transfer++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Transfers `token_id` from `from` to `to`.

Internal function without access restriction.

WARNING: This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.

Requirements:

- `to` is not the zero address.
- `from` is the token owner.
- `token_id` exists.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-mint]]
==== `[.contract-item-name]#++mint++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Mints `token_id` and transfers it to `to`.
Internal function without access restriction.

WARNING: This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.

Requirements:

- `to` is not the zero address.
- `token_id` does not exist.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-safe_transfer]]
==== `[.contract-item-name]#++safe_transfer++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#internal#

Transfers ownership of `token_id` from `from` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

WARNING: This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.

Requirements:

- `to` cannot be the zero address.
- `from` must be the token owner.
- `token_id` exists.
- `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-safe_mint]]
==== `[.contract-item-name]#++safe_mint++#++(ref self: ContractState, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#internal#

Mints `token_id` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

WARNING: This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.

Requirements:

- `token_id` does not exist.
- `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-burn]]
==== `[.contract-item-name]#++burn++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#internal#

Destroys `token_id`. The approval is cleared when the token is burned.

This internal function does not check if the caller is authorized
to operate on the token.

Requirements:

- `token_id` exists.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-update]]
==== `[.contract-item-name]#++update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#internal#

Transfers `token_id` from its current owner to `to`, or alternatively mints (or burns) if the current owner
(or `to`) is the zero address. Returns the owner of the `token_id` before the update.

The `auth` argument is optional. If the value passed is non-zero, then this function will check that
`auth` is either the owner of the token, or approved to operate on the token (by the owner).

Emits a <<IERC721-Transfer,Transfer>> event.

NOTE: This function can be extended using the `ERC721HooksTrait`, to add
functionality before and/or after the transfer, mint, or burn.

[.contract-item]
[[ERC721Component-_owner_of]]
==== `[.contract-item-name]#++_owner_of++#++(self: @ContractState, token_id: felt252) -> ContractAddress++` [.item-kind]#internal#

Internal function that returns the owner address of `token_id`.

[.contract-item]
[[ERC721Component-_require_owned]]
==== `[.contract-item-name]#++_require_owned++#++(self: @ContractState, token_id: felt252) -> ContractAddress++` [.item-kind]#internal#

Version of xref:#ERC721Component-_owner_of[_owner_of] that panics if owner is the zero address.

[.contract-item]
[[ERC721Component-_approve]]
==== `[.contract-item-name]#++_approve++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#internal#

Approve `to` to operate on `token_id`

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is
either the owner of the token, or approved to operate on all tokens held by this owner.

Emits an <<IERC721-Approval,Approval>> event.

[.contract-item]
[[ERC721Component-_approve_with_optional_event]]
==== `[.contract-item-name]#++_approve_with_optional_event++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress, emit_event: bool)++` [.item-kind]#internal#

Variant of xref:#ERC721Component-_approve[_approve] with an optional flag to enable or disable the `Approval` event.
The event is not emitted in the context of transfers.

WARNING: If `auth` is zero and `emit_event` is false, this function will not check that the token exists.

Requirements:

- if `auth` is non-zero, it must be either the owner of the token or approved to
operate on all of its tokens.

May emit an <<IERC721-Approval,Approval>> event.

[.contract-item]
[[ERC721Component-_set_approval_for_all]]
==== `[.contract-item-name]#++_set_approval_for_all++#++(ref self: ContractState, owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#internal#

Enables or disables approval for `operator` to manage
all of the `owner` assets.

Requirements:

- `operator` is not the zero address.

Emits an <<IERC721-Approval,Approval>> event.

[.contract-item]
[[ERC721Component-_set_base_uri]]
==== `[.contract-item-name]#++_set_base_uri++#++(ref self: ContractState, base_uri: ByteArray)++` [.item-kind]#internal#

Internal function that sets the `base_uri`.

[.contract-item]
[[ERC721Component-_base_uri]]
==== `[.contract-item-name]#++_base_uri++#++(self: @ContractState) -> ByteArray++` [.item-kind]#internal#

Base URI for computing <<IERC721Metadata-token_uri, token_uri>>.

If set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
Returns an empty `ByteArray` if not set.

[.contract-item]
[[ERC721Component-_is_authorized]]
==== `[.contract-item-name]#++_is_authorized++#++(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool++` [.item-kind]#internal#

Returns whether `spender` is allowed to manage ``owner``'s tokens, or `token_id` in
particular (ignoring whether it is owned by `owner`).

WARNING: This function assumes that `owner` is the actual owner of `token_id` and does not verify this
assumption.

[.contract-item]
[[ERC721Component-_check_authorized]]
==== `[.contract-item-name]#++_check_authorized++#++(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool++` [.item-kind]#internal#

Checks if `spender` can operate on `token_id`, assuming the provided `owner` is the actual owner.

Requirements:

- `owner` cannot be the zero address.
- `spender` cannot be the zero address.
- `spender` must be the owner of `token_id` or be approved to operate on it.

WARNING: This function assumes that `owner` is the actual owner of `token_id` and does not verify this
assumption.

==== Events

[.contract-item]
[[ERC721Component-Approval]]
==== `[.contract-item-name]#++Approval++#++(owner: ContractAddress, approved: ContractAddress, token_id: u256)++` [.item-kind]#event#

See <<IERC721-Approval,IERC721::Approval>>.

[.contract-item]
[[ERC721Component-ApprovalForAll]]
==== `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#event#

See <<IERC721-ApprovalForAll,IERC721::ApprovalForAll>>.

[.contract-item]
[[ERC721Component-Transfer]]
==== `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#event#

See <<IERC721-Transfer,IERC721::Transfer>>.


== Extensions

[.contract]
[[ERC721URIstorageComponent]]
=== `++ERC721URIstorageComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.14.0/src/token/erc721/extensions/erc721_uri_storage.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin::token::extensions::ERC721URIstorageComponent;
```

:MetadataUpdate: xref:ERC721URIstorageComponent-MetadataUpdate[MetadataUpdate]

Extension of ERC721 to support dynamic NFTs. It is an implementation of <<IERC721Metadata, IERC721Metadata>> but with a different `token_uri` behavior

NOTE: Implementing xref:#ERC721Component[ERC721Component] is a requirement for this component to be implemented.

This extension keeps a track of URIs of each `token_id` of a particular ERC721 token. The `token_uri` of any `token_id` can be set by calling the 
internal function, xref:#ERC721URIstorageComponent-set_token_uri[set_token_uri]. Updated `token_uri` can be queried through the external function 
xref:#ERC721URIstorageComponent-token_uri[token_uri] or the internal function xref:#ERC721URIstorageComponent-_token_uri[_token_uri].


[.contract-index#ERC721URIstorageComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC721URIstorageComponent-Embeddable-Impls-ERC721URIstorageImpl]
.ERC721URIstorageImpl
* xref:#ERC721URIstorageComponent-name[`++name(self)++`]
* xref:#ERC721URIstorageComponent-symbol[`++symbol(self)++`]
* xref:#ERC721URIstorageComponent-token_uri[`++token_uri(self,token_id)++`]

--

[.contract-index]
.Internal implementations
--
.InternalImpl
* xref:#ERC721URIstorageComponent-_name[`++_name(self)++`]
* xref:#ERC721URIstorageComponent-_symbol[`++_symbol(self)++`]
* xref:#ERC721URIstorageComponent-_token_uri[`++_token_uri(self,token_id)++`]
* xref:#ERC721URIstorageComponent-set_token_uri[`++set_token_uri(self,token_id,token_uri)++`]

--

[.contract-index]
.Events
--
* xref:#ERC721URIstorageComponent-MetadataUpdate[`++MetadataUpdate(token_id)++`]
--

[#ERC721URIstorageComponent-Embeddable-functions]
==== Embeddable functions

[.contract-item]
[[ERC721URIstorageComponent-name]]
==== `[.contract-item-name]#++name++#++(self: @ContractState) → ByteArray++` [.item-kind]#external#

See <<IERC721Metadata-name,IERC721::name>>.

[.contract-item]
[[ERC721URIstorageComponent-symbol]]
==== `[.contract-item-name]#++symbol++#++(self: @ContractState) → ByteArray++` [.item-kind]#external#

See <<IERC721Metadata-symbol,IERC721::symbol>>.

[.contract-item]
[[ERC721URIstorageComponent-token_uri]]
==== `[.contract-item-name]#++token_uri++#++(self: @ContractState, token_id : u256) → ByteArray++` [.item-kind]#external#

See <<ERC721URIstorageComponent-_token_uri,ERC721URIstorageComponent::_token_uri>>

[#ERC721URIstorageComponent-Internal-functions]
==== Internal functions

[.contract-item]
[[ERC721URIstorageComponent-name]]
==== `[.contract-item-name]#++name++#++(self: @ContractState) → ByteArray++` [.item-kind]#internal#

See <<IERC721Metadata-name,IERC721Metadata::name>>.

[.contract-item]
[[ERC721URIstorageComponent-symbol]]
==== `[.contract-item-name]#++symbol++#++(self: @ContractState) → ByteArray++` [.item-kind]#internal#

See <<IERC721Metadata-symbol,IERC721Metadata::symbol>>.

[.contract-item]
[[ERC721URIstorageComponent-_token_uri]]
==== `[.contract-item-name]#++_token_uri++#++(self: @ContractState, token_id: u256) → ByteArray++` [.item-kind]#internal#

Returns the Uniform Resource Identifier (URI) for the `token_id` token. 


If a base URI is set and the token URI is set , the resulting URI for each token will be the concatenation of the base URI and the token URI. 
If a base URI is set and the token URI is not set , the resulting URI for each token will be the concatenation of the base URI and the token ID. 
If a base URI is not set and the token URI is set , the resulting URI for each token will be the token URI. 

If the base URI and token URI is not set for `token_id`, the return value will be an empty `ByteArray`.

[.contract-item]
[[ERC721URIstorageComponent-se_token_uri]]
==== `[.contract-item-name]#++set_token_uri++#++(ref self: ContractState,token_id: u256,token_uri: ByteArray)++` [.item-kind]#internal#

Sets the `token_uri` of `token_id`.

Emits a {MetadataUpdate} event.

[#ERC721URIstorageComponent-Events]
==== Events

[.contract-item]
[[ERC721URIstorageComponent-MetadataUpdate]]
==== `[.contract-item-name]#++MetadataUpdate++#++(token_id: u256)++` [.item-kind]#event#

Emitted when `token_uri` of `token_id` is set.

== Receiver

[.contract]
[[IERC721Receiver]]
=== `++IERC721Receiver++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.15.0-rc.0/src/token/erc721/interface.cairo#L70-L79[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin::token::erc721::interface::IERC721Receiver;
```

Interface for contracts that support receiving `safe_transfer_from` transfers.

[.contract-index]
.{inner-src5}
--
0x3a0dff5f70d80458ad14ae37bb182a728e3c8cdda0402a5daa86620bdf910bc
--

[.contract-index]
.Functions
--
* xref:#IERC721Receiver-on_erc721_received[`++on_erc721_received(operator, from, token_id, data)++`]
--

==== Functions

[.contract-item]
[[IERC721Receiver-on_erc721_received]]
==== `[.contract-item-name]#++on_erc721_received++#++(operator: ContractAddress, from: ContractAddress, token_id: u256, data: Span<felt252>) -> felt252++` [.item-kind]#external#

Whenever an IERC721 `token_id` token is transferred to this non-account contract via <<IERC721-safe_transfer_from,IERC721::safe_transfer_from>> by `operator` from `from`, this function is called.

[.contract]
[[ERC721ReceiverComponent]]
=== `++ERC721ReceiverComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.15.0-rc.0/src/token/erc721/erc721_receiver.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin::token::erc721::ERC721ReceiverComponent;
```

ERC721Receiver component implementing <<IERC721Receiver,IERC721Receiver>>.

NOTE: {src5-component-required-note}

[.contract-index#ERC721ReceiverComponent-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.ERCReceiverMixinImpl
* xref:#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl[`++ERC721ReceiverImpl++`]
* xref:#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl[`++ERC721ReceiverCamelImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
--

[.contract-index#ERC721ReceiverComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl]
.ERC721ReceiverImpl
* xref:#ERC721ReceiverComponent-on_erc721_received[`++on_erc721_received(self, operator, from, token_id, data)++`]

[.sub-index#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl]
.ERC721ReceiverCamelImpl
* xref:#ERC721ReceiverComponent-onERC721Received[`++onERC721Received(self, operator, from, tokenId, data)++`]
--

[.contract-index]
.Internal Functions
--
.InternalImpl
* xref:#ERC721ReceiverComponent-initializer[`++initializer(self)++`]
--

==== Embeddable functions

[.contract-item]
[[ERC721ReceiverComponent-on_erc721_received]]
==== `[.contract-item-name]#++on_erc721_received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

Returns the `IERC721Receiver` interface ID.

[.contract-item]
[[ERC721ReceiverComponent-onERC721Received]]
==== `[.contract-item-name]#++onERC721Received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

See <<ERC721ReceiverComponent-on_erc721_received,ERC721ReceiverComponent::on_erc721_received>>.

==== Internal functions

[.contract-item]
[[ERC721ReceiverComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState)++` [.item-kind]#internal#

Registers the `IERC721Receiver` interface ID as supported through introspection.

== Presets

[.contract]
[[ERC721Upgradeable]]
=== `++ERC721Upgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.15.0-rc.0/src/presets/erc721.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin::presets::ERC721Upgradeable;
```

Upgradeable ERC721 contract leveraging xref:#ERC721Component[ERC721Component].

include::../utils/_class_hashes.adoc[]

[.contract-index]
.{presets-page}
--
{ERC721Upgradeable-class-hash}
--

[.contract-index]
.Constructor
--
* xref:#ERC721Upgradeable-constructor[`++constructor(self, name, symbol, recipient, token_ids, base_uri, owner)++`]
--

[.contract-index]
.Embedded Implementations
--
.ERC721MixinImpl

* xref:#ERC721Component-Embeddable-Mixin-Impl[`++ERC721MixinImpl++`]

.OwnableMixinImpl

* xref:/api/access.adoc#OwnableComponent-Mixin-Impl[`++OwnableMixinImpl++`]
--

[.contract-index]
.External Functions
--
* xref:#ERC721Upgradeable-upgrade[`++upgrade(self, new_class_hash)++`]
--

[#ERC721Upgradeable-constructor-section]
==== Constructor

[.contract-item]
[[ERC721Upgradeable-constructor]]
==== `[.contract-item-name]#++constructor++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, base_uri: ByteArray, owner: ContractAddress)++` [.item-kind]#constructor#

Sets the `name` and `symbol`.
Mints `token_ids` tokens to `recipient` and sets the `base_uri`.
Assigns `owner` as the contract owner with permissions to upgrade.

[#ERC721Upgradeable-external-functions]
==== External functions

[.contract-item]
[[ERC721Upgradeable-upgrade]]
==== `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.
- `new_class_hash` cannot be zero.
