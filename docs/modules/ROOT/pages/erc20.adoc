= ERC20

The ERC20 token standard is a specification for https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[fungible tokens], a type of token where all the units are exactly equal to each other.
The `ERC20.cairo` contract implements an approximation of https://eips.ethereum.org/EIPS/eip-20[EIP-20] in Cairo for StarkNet.

== Table of Contents

* <<interface,Interface>>
 ** <<erc20_compatibility,ERC20 compatibility>>
* <<usage,Usage>>
* <<extensibility,Extensibility>>
* <<presets,Presets>>
 ** <<erc20_basic,ERC20 (basic)>>
* <<api_specification,API Specification>>
 ** <<erc20impl,ERC20Impl>>
  *** <<name,`name`>>
  *** <<symbol,`symbol`>>
  *** <<decimals,`decimals`>>
  *** <<total_supply,`total_supply`>>
  *** <<balance_of,`balance_of`>>
  *** <<allowance,`allowance`>>
  *** <<transfer,`transfer`>>
  *** <<transfer_from,`transfer_from`>>
  *** <<approve,`approve`>>
 ** <<events,Events>>
  *** <<transfer_event,`Transfer (event)`>>
  *** <<approval_event,`Approval (event)`>>
 ** <<internalimpl,InternalImpl>>
  *** <<initializer,initializer>>
  *** <<_increase_allowance,_increase_allowance>>
  *** <<_decrease_allowance,_decrease_allowance>>
  *** <<_mint,_mint>>
  *** <<_burn,_burn>>
  *** <<_approve,_approve>>
  *** <<_transfer,_transfer>>
  *** <<_spend_allowance,_spend_allowance>>

== Interface

[,rust]
----
#[starknet::interface]
trait IERC20<TState> {
    fn name(self: @TState) -> felt252;
    fn symbol(self: @TState) -> felt252;
    fn decimals(self: @TState) -> u8;
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
----

=== ERC20 compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC20 standard, in the following ways:

* It uses Cairo's `u256` instead of `felt252`.
* It makes use of Cairo's short strings to simulate `name` and `symbol`.

But some differences can still be found, such as:

* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.
* Function selectors are calculated differently between https://github.com/starkware-libs/cairo/blob/7dd34f6c57b7baf5cd5a30c15e00af39cb26f7e1/crates/cairo-lang-starknet/src/contract.rs#L39-L48[Cairo] and https://solidity-by-example.org/function-selector/[Solidity].

== Usage

Use cases go from medium of exchange currency to voting rights, staking, and more.

Coming soon!

== Extensibility

(*This is currently unsafe*)

ERC20 contracts can be extended by utilizing the contract's _unsafe_new_contract_state().
The unsafe contract state allows access to the _ERC20Impl_.
This enables IERC20 methods to include additional behaviors.

[,rust]
----
#[external(v0)]
fn transfer(self: @ContractState, recipient: ContractAddress, amount: u256) -> bool {
    let unsafe_state = ERC20::unsafe_new_contract_state();

    // Add custom logic here

    ERC20::ERC20Impl::transfer(@unsafe_state, recipient, amount)
}
----

The unsafe state also allows access to ERC20's _InternalImpl_.
Having access to ERC20's interal implementation permits contracts, for example, to expose the internal methods like _mint.

[,rust]
----
#[external(v0)]
fn mint(self: @ContractState, to: ContractAddress, amount: u256) {
    let unsafe_state = ERC20::unsafe_new_contract_state();
    assert_only_owner();  // Ensure the mint function is protected!
    ERC20::InternalImpl::_mint(@unsafe_state, to, amount);
}
----

Note that accessing the contract's state in this way is unsafe at the moment.

== Presets

The ERC20 contract itself includes a basic implementation preset and can be used as-is for quick prototyping and testing.
The basic preset mints an inital supply which is necessary because it does not expose a minting function.

More presets coming soon!

=== ERC20 (basic)

*TODO: CHANGE LINK TO RELEASE COMMIT WHEN AVAILABLE*

The https://github.com/OpenZeppelin/cairo-contracts/blob/cairo-2/src/token/erc20/erc20.cairo[`ERC20`] preset offers a quick and easy setup for deploying a basic ERC20 token.

== API Specification

=== ERC20Impl

[,rust]
----
fn name(self: @TState) -> felt252;
fn symbol(self: @TState) -> felt252;
fn decimals(self: @TState) -> u8;
fn total_supply(self: @TState) -> u256;
fn balance_of(self: @TState, account: ContractAddress) -> u256;
fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
fn transfer_from(
    ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
) -> bool;
fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
----

==== `name`

Returns the name of the token.

Parameters: None.

Returns:

[,rust]
----
name: felt252
----

==== `symbol`

Returns the ticker symbol of the token.

Parameters: None.

Returns:

[,rust]
----
symbol: felt252
----

==== `decimals`

Returns the number of decimals the token uses - e.g.
`8` means to divide the token amount by `100000000` to get its user representation.

Parameters: None.

Returns:

[,rust]
----
decimals: u8
----

==== `total_supply`

Returns the amount of tokens in existence.

Parameters: None.

Returns:

[,rust]
----
total_supply: u256
----

==== `balance_of`

Returns the amount of tokens owned by `account`.

Parameters:

[,rust]
----
account: ContractAddress
----

Returns:

[,rust]
----
balance: u256
----

==== `allowance`

Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through `transfer_from`.
This is zero by default.

This value changes when `approve` or `transfer_from` are called.

Parameters:

[,rust]
----
owner: ContractAddress
spender: ContractAddress
----

Returns:

[,rust]
----
remaining: u256
----

==== `transfer`

Moves `amount` tokens from the caller's account to `recipient`.
It returns `true` on success.

Emits a <<transfer_event,Transfer>> event.

Parameters:

[,rust]
----
recipient: ContractAddress
amount: u256
----

Returns:

[,rust]
----
success: bool
----

==== `transfer_from`

Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.
`amount` is then deducted from the caller's allowance.
It returns `true` on success.

Emits a <<transfer_event,Transfer>> event.

Parameters:

[,rust]
----
sender: ContractAddress
recipient: ContractAddress
amount: u256
----

Returns:

[,rust]
----
success: bool
----

==== `approve`

Sets `amount` as the allowance of `spender` over the caller's tokens.
It returns `true` on success.

Emits an <<approval_event,Approval>> event.

Parameters:

[,rust]
----
spender: ContractAddress
amount: u256
----

Returns:

[,rust]
----
success: bool
----

=== Events

[,rust]
----
func Transfer(from: ContractAddress, to: ContractAddress, value: u256) {
}

func Approval(owner: ContractAddress, spender: ContractAddress, value: u256) {
}
----

==== `Transfer (event)`

Emitted when `value` tokens are moved from one account (`from`) to another (`to`).

Note that `value` may be zero.

Parameters:

[,rust]
----
from: ContractAddress
to: ContractAddress
value: u256
----

==== `Approval (event)`

Emitted when the allowance of a `spender` for an `owner` is set by a call to <<approve,approve>>.
`value` is the new allowance.

Parameters:

[,rust]
----
owner: ContractAddress
spender: ContractAddress
value: u256
----

=== InternalImpl

[,rust]
----
fn initializer(ref self: ContractState, name_: felt252, symbol_: felt252);
fn _increase_allowance(
    ref self: ContractState, spender: ContractAddress, added_value: u256
);
fn _decrease_allowance(
    ref self: ContractState, spender: ContractAddress, subtracted_value: u256
);
fn _mint(ref self: ContractState, recipient: ContractAddress, amount: u256);
fn _burn(ref self: ContractState, account: ContractAddress, amount: u256);
fn _approve(
    ref self: ContractState,
    owner: ContractAddress,
    spender: ContractAddress,
    amount: u256
);
fn _transfer(
    ref self: ContractState,
    sender: ContractAddress,
    recipient: ContractAddress,
    amount: u256
);
fn _spend_allowance(
    ref self: ContractState,
    owner: ContractAddress,
    spender: ContractAddress,
    amount: u256
);
----

==== `initializer`

Initializes the contract and sets the token name and symbol.
This should be called in the contract's constructor.

Parameters:

[,rust]
----
name_: felt252
symbol_: felt252
----

Returns: None.

[#_increase_allowance]
==== `_increase_allowance`

Lorem ipsum...

Parameters:

[,rust]
----
spender: ContractAddress
added_value: u256
----

Returns: None.

[#_decrease_allowance]
==== `_decrease_allowance`

Lorem ipsum...

Parameters:

[,rust]
----
spender: ContractAddress
subtracted_value: u256
----

Returns: None.

[#_mint]
==== `_mint`

Lorem ipsum...

Parameters:

[,rust]
----
recipient: ContractAddress
amount: u256
----

Returns: None.

[#_burn]
==== `_burn`

Lorem ipsum...

Parameters:

[,rust]
----
account: ContractAddress
amount: u256
----

Returns: None.

[#_approve]
==== `_approve`

Lorem ipsum...

Parameters:

[,rust]
----
owner: ContractAddress
spender: ContractAddress
amount: u256
----

Returns: None.

[#_transfer]
==== `_transfer`

Lorem ipsum...

Parameters:

[,rust]
----
sender: ContractAddress
recipient: ContractAddress
amount: u256
----

Returns: None.

[#_spend_allowance]
==== `_spend_allowance`

Lorem ipsum...

Parameters:

[,rust]
----
owner: ContractAddress
spender: ContractAddress
amount: u256
----

Returns: None.
