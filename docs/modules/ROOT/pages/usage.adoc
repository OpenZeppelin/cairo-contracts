= Usage

The following documentation provides reasoning and examples on how to use Contracts for Cairo components.

== Components

:shamans-post: https://community.starknet.io/t/cairo-components/101136#components-1[Starknet Shamans post]

Starknet components are separate modules that contain storage, events, and implementations that can be integrated into a contract.
Components themselves cannot be declared or deployed.
Another way to think of components is that they are abstract modules that must be instantiated.

TIP: For more information on the construction and design of Starknet components, see the {shamans-post}.

== Building a contract

:initializable-component: xref:/security.adoc#initializable[InitializableComponent]

The contract should first import the component and declare it with the `component!` macro:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    // Import the component
    use openzeppelin::security::InitializableComponent;

    // Declare the component
    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);
}
----

The `path` argument should be the imported component itself (in this case, {initializable-component}).
Notice that the `storage` and `event` arguments are representations set within the macro.
In other words, the `initializable` and `InitializableEvent` names follow this library's convention, but they can be renamed.

=== Storage and events

The component's storage and events must be added to the contract's `Storage` struct and `Event` enum respectively.
If the component doesn't define any events, the compiler will still create an empty event enum inside the component module.

[,javascript]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin::security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }

    (...)
}
----

The `#[substorage(v0)]` attribute must be included for each component in the `Storage` trait.
This allows the contract to have indirect access to the component's storage.

The `#[flat]` attribute for events in the `Event` enum, however, is not required.
Component events are not flattened in the component itself because it would remove the event ID from the event log.
Note that if contracts do not flatten component events, the first key in the event log will be the component ID.
By flattening the component event in the contract, the first key will be the event ID.

=== Implementations

:accessing-storage: xref:/usage.adoc#accessing_component_storage[Accessing component storage]

Components come with granular implementations of different interfaces.
This allows contracts to integrate only the implementations that they'll use and avoid unnecessary bloat.
Integrating an implementation looks like this:

[,javascript]
----
mod MyContract {
    use openzeppelin::security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    // Gives the contract access to the implementation methods
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
----

Defining an `impl` gives the contract access to the methods within the implementation from the component.
For example, `is_initialized` is defined in the `InitializableImpl`.
A function on the contract level can expose it like this:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin::security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;

    #[external(v0)]
    fn is_initialized(ref self: ContractState) -> bool {
        self.initializable.is_initialized()
    }
}
----

Notice that the function must pass the state (`self`) and the component's storage (`initializable`) before finally accessing the implementation method.

NOTE: Contracts can also (indirectly) access a component's storage. See {accessing-storage}.

While there's nothing wrong with manually exposing methods like in the previous example, this process can be tedious for implementations with many methods.
Fortunately, a contract can embed implementations into the ABI which will expose all of the methods of the implementation.
To embed an implementation, add the `#[abi(embed_v0)]` attribute above the `impl`:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    (...)

    // This attribute exposes the methods of the `impl`
    #[abi(embed_v0)]
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
----

`InitializableImpl` defines the `is_initialized` method in the component.
By adding the embed attribute, `is_initialized` becomes a contract entrypoint for `MyContract`.

=== Initializers

:ownable-component: xref:/api/access.adoc#OwnableComponent[OwnableComponent]

WARNING: Failing to use a component's `initializer` can result in irreparable contract deployments.
Always read the API documentation for each integrated component.

Some components require some sort of setup upon construction.
Usually, this would be a job for a constructor; however, components themselves cannot provide constructors.
Components instead offer ``initializer``s within their `InternalImpl` which enables a contract to create a constructor and invoke the component's `initializer`.
Let's look at how a contract would integrate {ownable-component}:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin::access::ownable::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        // Invoke ownable's `initializer`
        self.ownable.initializer(owner);
    }
}
----

=== Dependencies

:access-component: xref:/api/access.adoc#AccessControlComponent[AccessControlComponent]
:src5-component: xref:/api/introspection.adoc#SRC5Component[SRC5Component]

Some components include dependencies of other components.
Contracts that integrate components with dependencies must also include the component dependency.
For instance, {access-component} depends on {src5-component}.
Creating a contract with `AccessControlComponent` should look like this:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin::access::accesscontrol::AccessControlComponent;
    use openzeppelin::introspection::src5::SRC5Component;

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    #[abi(embed_v0)]
    impl AccessControlCamelImpl =
        AccessControlComponent::AccessControlCamelImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    (...)
}
----

== Customization

:security: xref:/usage.adoc#security[Security]

WARNING: Customizing implementations and accessing component storage can potentially corrupt the state, bypass security checks, and undermine the component logic.
*Exercise extreme caution*. See {security}.

=== Custom implementations

:erc20-component: xref:/api/erc20.adoc#ERC20Component[ERC20Component]
:decimals: xref:/api/erc20.adoc#IERC20Metadata-decimals[decimals]
:ierc20metadata: xref:/api/erc20.adoc#IERC20Metadata[IERC20Metadata]
:custom-decimals: xref:/erc20.adoc#customizing_decimals[Customizing decimals]

There may be instances where a contract requires different behavior from a component implementation.
The contract can create a custom implementation by importing the appropriate interface and defining the new logic.

In {erc20-component}, for example, the `ERC20MetadataImpl` provides a static {decimals} method which returns`18`.
If a contract wanted to change the return value of `decimals`, the `impl` can no longer be embedded.
Rather, the contract would have to create its own `impl` of the {ierc20metadata} interface and expose it in the contract.

TIP: {custom-decimals} provides a guide for this exact scenario.

=== Accessing component storage

Just as contracts can access methods within a component implementation, contracts can also access component storage.
Storage members are accessible to the contract by instantiating the component's `InternalImpl` like this:

[,javascript]
----
#[starknet::contract]
mod MyContract {
    (...)

    impl InternalImpl = InitializableComponent::InternalImpl<ContractState>;

    fn write_to_comp_storage(ref self: ContractState) -> bool {
        self.initializable.Initializable_initialized.write(true);
    }

    fn read_from_comp_storage(self: @ContractState) -> bool {
        self.initializable.Initializable_initialized.read()
    }
}
----

== Security

The maintainers of OpenZeppelin Contracts for Cairo are mainly concerned with the correctness and security of the code as published in the library.

Customizing implementations and manipulating the component state may break some important assumptions and introduce vulnerabilities in otherwise secure code.
While we try to ensure the components remain secure in the face of a wide range of potential customizations, this is done in a best-effort manner.
Any and all customizations to the component logic should be carefully reviewed and checked against the source code of the component they are customizing so as to fully understand their impact and guarantee their security. 
