= Migrating ERC165 to SRC5

:eip165: https://eips.ethereum.org/EIPS/eip-165[EIP-165]
:snip5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md[SNIP-5]
:dual-interface-discussion: https://github.com/OpenZeppelin/cairo-contracts/discussions/640[Dual Introspection Detection]
:shamans-proposal: https://community.starknet.io/t/starknet-standard-interface-detection/92664[Starknet Shamans proposal]

In the smart contract ecosystem, having the ability to query if a contract supports a given interface is an extremely important feature.
The initial introspection design for Contracts for Cairo before version v0.7.0 followed Ethereum's {eip165}.
Since the Cairo language evolved introducing native types, we needed an introspection solution tailored to the Cairo ecosystem: the {snip5} standard.
SNIP-5 allows interface ID calculations to use Cairo types and the Starknet keccak (`sn_keccak`) function.
For more information on the decision, see the {shamans-proposal} or the {dual-interface-discussion} discussion.

== Migrating to SRC5

:src5-component: xref:api/introspection#SRC5Component[SRC5Component]
:upgradeable-component: xref:api/upgrades#UpgradeableComponent[UpgradeableComponent]
:isrc6: xref:api/account.adoc#ISRC6[ISRC6]
:src5-rs: https://github.com/ericnordelo/src5-rs[src5-rs]

This guide is for already-deployed, upgradeable contracts that support ERC165.
Migrating to SRC5 requires integrating the {src5-component}.

[,javascript]
----
#[starknet::contract]
mod MigratingContract {
    use openzeppelin::introspection::src5::SRC5Component;
    use openzeppelin::upgrades::UpgradeableComponent;
    use starknet::ClassHash;
    use starknet::ContractAddress;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    #[abi(embed_v0)]
    impl SRC5CamelOnlyImpl = SRC5Component::SRC5CamelImpl<ContractState>;
    impl SRC5InternalImpl = SRC5Component::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    // The rest of the contract logic
}
----

The contract will also need to register the new SRC5 interface IDs in order to continue declaring support for those interfaces.
We can create a migration initializer to handle this which needs to be called after the contract upgrade.

TIP: OpenZeppelin's Contracts for Cairo already provides the interface IDs of common interfaces in the API section (like {isrc6}).
For interfaces not provided, tools such as {src5-rs} can help with interface ID calculation.

[,javascript]
----
#[starknet::contract]
mod MigratingContract {

    (...)

    #[external(v0)]
    fn migration_initializer(ref self: ContractState, interface_ids: Span<felt252>) {
        // Add permissions mechanism
        self.src5.register_interfaces(interface_ids);
    }
}
----

Note that deployed contracts with upgradeability should also be carefully tested before migrating.
Upgradeable contracts will likely include some form of xref:access.adoc[access mechanism] for the upgrade function.
Take extreme care with ensuring admins are not inadvertantly stripped of their permissions.
