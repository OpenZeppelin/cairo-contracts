= ERC20

The ERC20 token standard is a specification for https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[fungible tokens], a type of token where all the units are exactly equal to each other.
The `ERC20.cairo` contract implements an approximation of https://eips.ethereum.org/EIPS/eip-20[EIP-20] in Cairo for Starknet.

TIP: For detailed information on the usage and implementation check the xref:/api/erc20.adoc[API Reference] section.

== Table of Contents

* <<interface,Interface>>
 ** <<erc20_compatibility,ERC20 compatibility>>
* <<usage,Usage>>
* <<extensibility,Extensibility>>
* <<presets,Presets>>
 ** <<basic-erc20,Basic ERC20>>

== Interface

[,javascript]
----
#[starknet::interface]
trait IERC20<TState> {
    fn name(self: @TState) -> felt252;
    fn symbol(self: @TState) -> felt252;
    fn decimals(self: @TState) -> u8;
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(
        self: @TState,
        owner: ContractAddress,
        spender: ContractAddress
    ) -> u256;
    fn transfer(
        ref self: TState, 
        recipient: ContractAddress, 
        amount: u256
    ) -> bool;
    fn transfer_from(
        ref self: TState, 
        sender: ContractAddress, 
        recipient: ContractAddress, 
        amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
----

=== ERC20 compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC20 standard, in the following ways:

* It uses Cairo's `u256` instead of `felt252`.
* It makes use of Cairo's short strings to simulate `name` and `symbol`.

But some differences can still be found, such as:

* Function selectors are written in snake case as opposed to camel case in Solidity.
* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.

== Usage

Use cases go from medium of exchange currency to voting rights, staking, and more.

Coming soon!

== Extensibility

:components: https://community.starknet.io/t/cairo-1-contract-syntax-is-evolving/94794#extensibility-and-components-11[Components]

WARNING: This is currently unsafe, because storage members could clash among used contracts if not reviewed carefully. Extensibility will be revisited after {components} are introduced.

ERC20 contracts can be extended by utilizing the contract's `_unsafe_new_contract_state()`.
The unsafe contract state allows access to the `ERC20Impl`.
This enables `IERC20` methods to include additional behaviors.

[,javascript]
----
#[external(v0)]
fn transfer(self: @ContractState, recipient: ContractAddress, amount: u256) -> bool {
    let unsafe_state = ERC20::unsafe_new_contract_state();

    // Add custom logic here

    ERC20::ERC20Impl::transfer(@unsafe_state, recipient, amount)
}
----

The unsafe state also allows access to ERC20's `InternalImpl`.
Having access to ERC20's internal implementation permits contracts, for example, to expose the internal methods like `_mint`.

[,javascript]
----
#[external(v0)]
fn mint(self: @ContractState, to: ContractAddress, amount: u256) {
    let unsafe_state = ERC20::unsafe_new_contract_state();
    assert_only_owner();  // Ensure the mint function is protected!
    ERC20::InternalImpl::_mint(@unsafe_state, to, amount);
}
----

== Presets

The ERC20 contract itself includes a basic implementation preset and can be used as-is for quick prototyping and testing.
The basic preset mints an inital supply which is necessary because it does not expose a minting function.

More presets coming soon!

=== Basic ERC20 [[basic-erc20]]

*TODO: CHANGE LINK TO RELEASE COMMIT WHEN AVAILABLE*

The https://github.com/OpenZeppelin/cairo-contracts/blob/cairo-2/src/token/erc20/erc20.cairo[`ERC20`] preset offers a quick and easy setup for deploying a basic ERC20 token.
