= ERC20

:fungible-tokens: https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[fungible tokens]
:eip20: https://eips.ethereum.org/EIPS/eip-20[EIP-20]
:erc20-api: xref:/api/erc20.adoc[API Reference]

The ERC20 token standard is a specification for {fungible-tokens}, a type of token where all the units are exactly equal to each other.
The `token::erc20::ERC20` contract implements an approximation of {eip20} in Cairo for Starknet.

TIP: For detailed information on the usage and implementation check the {erc20-api} section.

== Table of Contents

* <<interface,Interface>>
 ** <<erc20_compatibility,ERC20 compatibility>>
* <<usage,Usage>>
* <<presets,Presets>>
 ** <<basic-erc20,Basic ERC20>>
* <<extensions,Extensions>>

== Interface

[,javascript]
----
trait IERC20 {
    fn name() -> felt252;
    fn symbol() -> felt252;
    fn decimals() -> u8;
    fn total_supply() -> u256;
    fn balance_of(account: ContractAddress) -> u256;
    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(spender: ContractAddress, amount: u256) -> bool;
}
----

=== ERC20 compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC20 standard, in the following ways:

* It makes use of Cairo's short strings to simulate `name` and `symbol`.

But some differences can still be found, such as:

* Function selectors are written in snake_case as opposed to camelCase in Solidity.
* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.

== Usage

:components: https://community.starknet.io/t/cairo-1-contract-syntax-is-evolving/94794#extensibility-and-components-11[Components]
:erc20-supply: xref:/guides/erc20-supply.adoc[Creating ERC20 Supply]

Using Contracts for Cairo, constructing an ERC20 contract requires setting up the constructor and exposing the ERC20 interface.
Here's what that looks like:

[,javascript]
----
#[starknet::contract]
mod MyToken {
    use starknet::ContractAddress;
    use openzeppelin::token::erc20::ERC20;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(
        self: @ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        let name = 'MyToken';
        let symbol = 'MTK';

        let mut unsafe_state = ERC20::unsafe_new_contract_state();
        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);
        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);
    }
}

    #[external(v0)]
    impl MyTokenImpl of IERC20<ContractState> {
        fn name(self: @ContractState) -> felt252 {
            let mut unsafe_state = ERC20::unsafe_new_contract_state();
            ERC20::ERC20Impl::name(ref unsafe_state, name, symbol); 
        }

        ...
    }
}
----

In order for `MyToken` contract to extend the ERC20 contract, it utilizes the `unsafe_new_contract_state`.
The unsafe contract state allows access to ERC20's implementations.
With this access, the constructor first calls the initializer to set the token name and symbol.
The constructor then calls `_mint` to create a fixed supply of tokens.

TIP: For a more complete guide to ERC20 token mechanisms, see {erc20-supply}.

In the external implementation, notice that `MyTokenImpl` is an implementation of `IERC20`.
This ensures that the external implementation will include all of the methods defined in the interface.

== Presets

=== Basic ERC20 [[basic-erc20]]

:erc20-basic: https://github.com/OpenZeppelin/cairo-contracts/blob/cairo-2/src/token/erc20/erc20.cairo[ERC20]

The {erc20-basic} preset offers a quick and easy setup for deploying a basic ERC20 token.
This preset mints an inital supply and it does not expose a minting function.

More presets coming soon!

== Extensions

Coming soon!
