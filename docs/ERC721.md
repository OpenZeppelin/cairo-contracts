# ERC721

The ERC721 token standard is a specification for [non-fungible tokens](https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens), or more colloquially: NFTs. The `ERC721.cairo` contract implements an approximation of [EIP-721](https://eips.ethereum.org/EIPS/eip-721) in Cairo for StarkNet.

## Table of Contents

- [IERC721](#ierc721)
- [ERC721 Compatibility](#erc721-compatibility)
- [Usage](#usage)
    *  [Token Transfers](#token-transfers)
    *  [ERC721Received](#erc721received)
        -  [IERC721_Receiver](#ierc721_receiver)
    *  [Supporting Interfaces](#supporting-interfaces)
    *  [Ready-to-Use Presets](#ready-to-use-presets)
- [Extensibility](#extensibility)
- [Presets](#presets)
    *  [ERC721_Mintable](#erc721_mintable)
    *  [ERC721_Pausable](#erc721_pausable)
    *  [ERC721_Metadata](#erc721_metadata)
        -  [IERC721_Metadata](#ierc721_metadata)
    *  [ERC721_Enumerable](#erc721_enumerable)
        -  [IERC721_Enumerable](#ierc721_enumerable)
- [Utilities](#utilities)
  *  [ERC721_Holder](#erc721_holder)
- [API Specification](#api-specification)
  * [`IERC721`](#ierc721-api)
    - [`balanceOf`](#-balanceOf-)
    - [`ownerOf`](#-ownerOf-)
    - [`safeTransferFrom`](#-safeTransferFrom-)
    - [`transferFrom`](#-transferFrom-)
    - [`approve`](#-approve-)
    - [`setApprovalForAll`](#-setApprovalForAll-)
    - [`getApproved`](#-getApproved-)
    - [`isApprovedForAll`](#-isApprovedForAll-)
  * [`IERC721_Metadata`](#ierc721_metadata)
    - [`name`](#-name-)
    - [`symbol`](#-symbol-)
    - [`tokenURI`](#-tokenURI-)
  * [`IERC721_Enumerable`](#ierc721_enumerable)
    - [`totalSupply`](#-supportsInterface-)
    - [`tokenByIndex`](#-supportsInterface-)
    - [`ownerOfTokenByIndex`](#-supportsInterface-)
  * [`IERC721_Receiver`](#ierc721_receiver)
    - [`onERC721Received`](#-supportsInterface-)

- [ERC165](#erc165)
  * [IERC165](#ierc165)
  * [ERC165 API Specification](#erc165-api-specification)
    - [`IERC165`](#ierc165)
      - [`supportsInterface`](#-supportsInterface-)


## IERC721

```jsx
@contract_interface
namespace IERC721:
    func balanceOf(owner: felt) -> (balance: Uint256):
    end

    func ownerOf(tokenId: Uint256) -> (owner: felt):
    end

    func safeTransferFrom(
        _from: felt, 
        to: felt, 
        tokenId: Uint256, 
        data_len: felt,
        data: felt*
    ):

    func transferFrom(_from: felt, to: felt, tokenId: Uint256):
    end

    func approve(approved: felt, tokenId: Uint256):
    end

    func setApprovalForAll(operator: felt, approved: felt):
    end

    func getApproved(tokenId: Uint256) -> (approved: felt):
    end

    func isApprovedForAll(owner: felt, operator: felt) -> (isApproved: felt):
    end

    --------------- IERC165 ---------------

    func supportsInterface(interfaceId: felt) -> (success: felt):
    end
end
```

### ERC721 Compatibility

Although StarkNet is not EVM compatible, this implementation aims to be as close as possible to the ERC721 standard in the following ways:

- it uses Cairo's `uint256` instead of `felt`
- it returns `1` as true/success to imitate a `bool`
- it makes use of Cairo's short strings to simulate `name` and `symbol`
- it will emit events once they're implemented on StarkNet

But some differences can still be found, such as:

- `tokenURI` returns a felt representation of the queried token's URI. The EIP721 standard, however, states that the return value should be of type string. If a token's URI is not set, the returned value is `0`
- `interface_id`s are hardcoded and initialized by the constructor. The hardcoded values derive from Solidity's selector calculations. See [Supporting Interfaces](#supporting-interfaces)
- `safeTransferFrom` can only be expressed as a single function in Cairo as opposed to the two functions declared in EIP721. The difference between both functions consists of accepting `data` as an argument. Because function overloading is currently not possible in Cairo, `safeTransferFrom` by default accepts the `data` argument. If `data` is not used, simply insert `0`.
- `safeTransferFrom` is specified such that the optional `data` argument should be of type bytes. In Solidity, this means a dynamically-sized array. To be as close as possible to the standard, it accepts a dynamic array of felts. In Cairo, arrays are expressed with the array length preceding the actual array; hence, the method accepts `data_len` and `data` respectively as types `felt` and `felt*`
- `ERC165_register_interface` allows contracts to set and communicate which interfaces they support. This follows OpenZeppelin's [ERC165Storage](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Storage.sol)
- `IERC721_Receiver` compliant contracts (`ERC721_Holder`) return a hardcoded selector id according to EVM selectors, since selectors are calculated differently in Cairo. This is in line with the ERC165 interfaces design choice towards EVM compatibility
- `IERC721_Receiver` includes the additional method `is_account` in order to determine if the recipient contract is an account contract. The Solidity implementation differs in that externally owned accounts (EOAs) could easily be distinguished from smart contracts. StarkNet currently does not have a differentiator between accounts and non-accounts; therefore, contracts that support safe ERC721 transfers must return `0` from `is_account` in order to communicate that the recipient contract is not an account but does support ERC721 transfers
- `ERC721_Enumerable` tracks the total number of tokens with the `all_tokens` and `all_tokens_len` storage variables mimicking the array of the Solidity implementation.

## Usage

Use cases go from artwork, digital collectibles, physical property, and many more.

To show a standard use case, we'll use the `ERC721_Mintable` preset which allows for only the owner to `mint` and `burn` tokens. To create a token you need to first deploy both Account and ERC721 contracts respectively. As most StarkNet contracts, ERC721 expects to be called by another contract and it identifies it through `get_caller_address` (analogous to Solidity's `this.address`). This is why we need an Account contract to interact with it.

Considering that the ERC721 constructor method looks like this:

```python
func constructor(
    name: felt,          # Token name as Cairo short string
    symbol: felt,        # Token symbol as Cairo short string
    owner: felt          # Address designated as the contract owner
):
```

Deployment of both contracts looks like this:

```python
account = await starknet.deploy(
    "contracts/Account.cairo",
    constructor_calldata=[signer.public_key]
)

erc721 = await starknet.deploy(
    "contracts/token/ERC721_Mintable.cairo",
    constructor_calldata=[
        str_to_felt("Token"),                       # name
        str_to_felt("TKN"),                         # symbol
        account.contract_address                    # owner
    ]
)
```

To mint a non-fungible token, send a transaction like this:

```python
signer = Signer(PRIVATE_KEY)
tokenId = uint(1)

await signer.send_transaction(
    account, erc721.contract_address, 'mint', [
        recipient_address, 
        *tokenId
    ]
)
```

### Token Transfers

EIP721 discourages the use of `transferFrom` and favors `safeTransferFrom` in regard to token transfers. The safe function adds the following conditional logic:
1. if the calling address is an account contract, the token transfer will behave as if `transferFrom` was called
2. if the calling address is not an account contract, the safe function will check that the contract supports ERC721 tokens

The current implementation of `safeTansferFrom` checks for `onERC721Received` and requires that the recipient contract includes `is_account` to return `0`. See [ERC721Receiverd](#erc721received)

Please be aware that transferring tokens with `transferFrom` to a contract that does not support ERC721 can result in lost tokens forever. 

### ERC721Received

In order to be sure a contract can safely accept ERC721 tokens, said contract must implement the `ERC721_Receiver` interface (as expressed in the EIP721 specification). Methods such as `safeTransferFrom` and `safeMint` call the recipient contract's `onERC721Received` method. If the contract fails to return the correct magic value, the transaction fails. 

StarkNet contracts that support safe transfers, however, must also include `is_account`. `safeTransferFrom` requires a means of differentiating between account and non-account contracts. Currently, StarkNet does not support error handling from the contract level; therefore, the current ERC721 implementation requires that all contracts that support safe ERC721 transfers (both accounts and non-accounts) include the `is_account` method. This method should return `0` since it's NOT an account. 

As Cairo/StarkNet matures and more features are added, new strategies will be examined to perhaps omit the `is_account` method from contracts that support safe ERC721 transfers.

#### IERC721_Receiver

Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.

```jsx
@contract_interface
namespace IERC721_Receiver:
    func onERC721Received(
        operator: felt,
        _from: felt,
        tokenId: Uint256,
        data_len: felt
        data: felt*
    ) -> (selector: felt):
    end

    func is_account() -> (res: felt):
    end
end
```

### Supporting Interfaces 

In order to ensure EVM/StarkNet compatibility, this ERC721 implementation does not calculate interface identifiers. Instead, the interface IDs are hardcoded from their EVM calculations. On the EVM, the interface ID is calculated from the selector's first four bytes of the hash of the function's signature while Cairo selectors are 252 bytes long. Due to this difference, hardcoding EVM's already-calculated interface IDs is the most consistent approach to both follow the EIP165 standard and EVM compatibility.

Further, this implementation stores supported interfaces in a mapping (similar to OpenZeppelin's [ERC165Storage](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Storage.sol)).

### Ready-to-Use Presets 

ERC721 presets have been created to allow for quick deployments as-is. This is a great option for testing and prototyping. See [Presets](#presets).

## Extensibility

Following the [contracts extensibility pattern](https://community.starknet.io/t/contract-extensibility-pattern/210), this implementation is set up to include all ERC721 storage and function logic within the base contract `ERC721_base.cairo`. Base contract methods with the prefix `ERC721_` must be imported to the frontend contract and inserted into an `external` method with the requisite name. This is already done in `ERC721.cairo`; however, additional functionality can be added. For instance, you could:
- Implement a pausing mechanism
- Add roles such as owner or minter
- Modify the `transferFrom` function to mimic the [`_beforeTokenTransfer` and `_afterTokenTransfer` hooks](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L335)

Just be sure that the exposed `external` methods invoke their imported function logic a la `approve` invokes `ERC721_approve`. As an example, see below.

```python
from contracts.token.ERC721_base import ERC721_approve

@external
func approve{
        pedersen_ptr: HashBuiltin*, 
        syscall_ptr: felt*, 
        range_check_ptr
    }(to: felt, tokenId: Uint256):
    ERC721_approve(to, tokenId)
    return()
end

```

## Presets

The following contract presets are ready to deploy and can be used as-is for quick prototyping and testing. Each preset includes a contract owner, which is set in the `constructor`, to offer simple access control on sensitive methods such as `mint` and `burn`.

### ERC721_Mintable

The ERC721_Mintable preset offers a quick and easy setup for creating NFTs. The contract owner can create and destroy tokens with the `mint` and `burn` methods. 

### ERC721_Pausable

The ERC721_Pausable preset creates a contract with pausable token transfers, minting, and burning. This preset proves useful for scenarios such as preventing trades until the end of an evaluation period and having an emergency switch for freezing all token transfers in the event of a large bug. In this preset, only the owner can pause/unpause the contract.

### ERC721_Metadata

The ERC721_Metadata extension allows your smart contract to be interrogated for its name and for details about the assets which your NFTs represent.

We follow OpenZeppelin's Solidity approach of integrating the Metadata methods `name`, `symbol`, and `tokenURI` into all ERC721 implementations. If preferred, a frontend contract can be created that imports from the ERC721_base directly (and does NOT include the Metadata extension). 

#### IERC721_Metadata

```jsx
@contract_interface
namespace IERC721_Metadata:
    func name() -> (name: felt):
    end

    func symbol() -> (symbol: felt):
    end

    func tokenURI(tokenId: Uint256) -> (tokenURI: felt):
    end
end
```

### ERC721_Enumerable

The Enumerable extension adds enumerability of all the token ids in the contract as well as all token ids owned by each account. This allows contracts to publish its full list of NFTs and make them discoverable. 

In regard to implementation, frontend contracts should import the following view methods:
-  `ERC721_Enumerable_totalSupply`
-  `ERC721_Enumerable_tokenByIndex`
-  `ERC721_Enumerable_tokenOfOwnerByIndex`

In order for the tokens to be correctly indexed, the frontend contract should also import the following methods (which supercede some of the ERC721_base methods):
-  `ERC721_Enumerable_transferFrom`
-  `ERC721_Enumerable_safeTransferFrom`
-  `ERC721_Enumerable_mint`
-  `ERC721_Enumerable_burn`

#### IERC721_Enumerable

```jsx
@contract_interface
namespace IERC721_Enumerable:
    func totalSupply() -> (totalSupply: Uint256):
    end

    func tokenByIndex(index: Uint256) -> (tokenId: Uint256):
    end

    func tokenOfOwnerByIndex(owner: felt, index: Uint256) -> (tokenId: Uint256):
    end
end
```

## Utilities

### ERC721_Holder

Implementation of the `IERC721Receiver` interface.

Accepts all token transfers. Make sure the contract is able to use its token with `IERC721.safeTransferFrom`, `IERC721.approve` or `IERC721.setApprovalForAll`.

Also utilizes `is_account` to determine if the contract is an account. See [ERC721Received](#erc721received)

## API Specification

### IERC721 API

```jsx
func balanceOf(owner: felt) -> (balance: Uint256):
end

func ownerOf(tokenId: Uint256) -> (owner: felt):
end

func safeTransferFrom(
        _from: felt, 
        to: felt, 
        tokenId: Uint256, 
        data_len: felt,
        data: felt*
    ):
end

func transferFrom(_from: felt, to: felt, tokenId: Uint256):
    end

func approve(approved: felt, tokenId: Uint256):
end

func setApprovalForAll(operator: felt, approved: felt):
end

func getApproved(tokenId: Uint256) -> (approved: felt):
end

func isApprovedForAll(owner: felt, operator: felt) -> (isApproved: felt):
end

```

#### `balanceOf`

Returns the number of tokens in `owner`'s account.

Parameters:

```jsx
owner: felt
```

Returns:

```jsx
balance: Uint256
```

#### `ownerOf`

Returns the owner of the `tokenId` token.

Parameters:

```jsx
tokenId: Uint256
```

Returns:

```jsx
owner: felt
```

#### `safeTransferFrom`

Safely transfers `tokenId` token from `_from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. For information regarding how contracts communicate their awareness of the ERC721 protocol, see [ERC721Received](#erc721received).

Parameters:

```jsx
_from: felt
to: felt
tokenId: Uint256
data_len: felt
data: felt*
```

Returns:

None.

#### `transferFrom`

Transfers `tokenId` token from `_from` to `to`.

> Note that this function should be used instead of `safeTransferFrom` to transfer tokens. Exercise caution as tokens sent to a contract that does not support ERC721 can be lost forever.

Parameters:

```jsx
_from: felt
to: felt
tokenId: Uint256
```

Returns:

None.

#### `approve`

Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred.

Parameters:

```jsx
to: felt
tokenId: Uint256
```

Returns:

None.

#### `getApproved`

Returns the account approved for `tokenId` token.

Parameters:

```jsx
tokenId: Uint256
```

Returns:

```jsx
operator: felt
```

#### `setApprovalForAll`

Approve or remove `operator` as an operator for the caller. Operators can call `transferFrom` or `safeTransferFrom` for any token owned by the caller.

Parameters:

```jsx
operator: felt
```

Returns:

None.

#### `isApprovedForAll`

Returns if the `operator` is allowed to manage all of the assets of `owner`.

Parameters:

```jsx
owner: felt
operator: felt
```

Returns:

```jsx
isApproved: felt
```

---

### IERC721_Metadata API
```jsx
func name() -> (name: felt):
end

func symbol() -> (symbol: felt):
end

func tokenURI(tokenId: Uint256) -> (tokenURI: felt):
end
```

#### `name`

Returns the token collection name.

Parameters:

None.

Returns:

```jsx
name: felt
```

#### `symbol`

Returns the token collection symbol.

Parameters: 

None.

Returns:

```jsx
symbol: felt
```

#### `tokenURI`

Returns the Uniform Resource Identifier (URI) for `tokenID` token. If the tokenURI is not set for the `tokenId`, the return value will be `0`.

Parameters:

```jsx
tokenId: Uint256
```

Returns:

```jsx
tokenURI: felt
```

---

### IERC721_Enumerable API
```jsx

func totalSupply() -> (totalSupply: Uint256):
end

func tokenByIndex(index: Uint256) -> (tokenId: Uint256):
end

func tokenOfOwnerByIndex(owner: felt, index: Uint256) -> (tokenId: Uint256):
end
```

#### `totalSupply`

Returns the total amount of tokens stored by the contract.

Parameters: None

Returns:

```jsx
totalSupply: Uint256
```

#### `tokenByIndex`

Returns a token ID owned by `owner` at a given `index` of its token list. Use along with [balanceOf](#balanceOf) to enumerate all of `owner`'s tokens.

Parameters:

```jsx
index: Uint256
```

Returns:

```jsx
tokenId: Uint256
```

#### `tokenOfOwnerByIndex`

Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with [totalSupply](#totalSupply) to enumerate all tokens.

Parameters:

```jsx
owner: felt
index: Uint256
```

Returns:

```jsx
tokenId: Uint256
```

---

### IERC721_Receiver API
```jsx
func onERC721Received(
        operator: felt, 
        _from: felt, 
        tokenId: Uint256, 
        data_len: felt
        data: felt*
    ) -> (selector: felt):
end

func is_account() -> (res: felt):
end
```

#### `onERC721Received`

Whenever an IERC721 `tokenId` token is transferred to this non-account contract via `safeTransferFrom` by `operator` from `_from`, this function is called.


Parameters:

```jsx
operator: felt
_from: felt
tokenId: Uint256
data_len: felt
data: felt*
```

Returns:

```jsx
selector: felt
```

#### `is_account`

This function is necessary to determine whether the recipient of `safeTransferFrom` is an account contract. If the recipient is not an account contract, the return value should be `0` and `onERC721Received` is called thereafter to ensure the recipient supports safe ERC721 transfers.

Parameters: None

Returns:

```jsx
res: felt
```
## ERC165

The ERC165 standard allows smart contracts to exercise [type introspection](https://en.wikipedia.org/wiki/Type_introspection) on other contracts, that is, examining which functions can be called on them. This is usually referred to as a contractâ€™s interface.

Cairo contracts, like Ethereum contracts, have no native concept of an interface, so applications must usually simply trust they are not making an incorrect call. For trusted setups this is a non-issue, but often unknown and untrusted third-party addresses need to be interacted with. There may even not be any direct calls to them! (e.g. ERC20 tokens may be sent to a contract that lacks a way to transfer them out of it, locking them forever). In these cases, a contract declaring its interface can be very helpful in preventing errors.

### IERC165
```jsx
@contract_interface
namespace IERC165:
    func supportsInterface(interfaceId: felt) -> (success: felt):
    end
end
```

### ERC165 API Specification
```jsx
func supportsInterface(interfaceId: felt) -> (success: felt):
end
```

#### `supportsInterface`

Returns true if this contract implements the interface defined by `interfaceId`.

Parameters:

```jsx
interfaceId: felt
```

Returns:

```jsx
success: felt
```