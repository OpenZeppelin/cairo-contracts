:eip165: https://eips.ethereum.org/EIPS/eip-165[EIP165]
:src5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md[SRC5]
:src5-rs: https://github.com/ericnordelo/src5-rs[src5-rs]

= Introspection

In the Ethereum ecosystem, smart contracts often need to exercise https://en.wikipedia.org/wiki/Type_introspection[type introspection]
on other contracts, for interoperability purposes. The {eip165} standard supports this allowing contracts to declare
their support for a given interface, and for other contracts to query this support.

Starknet is not an exception to this rule, having to exercise type introspection among smart contracts as well. From the
differences between Starknet and Ethereum, instead of trying to replicate the EVM's interface ID calculation, the community
has defined {src5} which is a Starknet-specific standard for type introspection:

== SRC5

Similar to the Ethereum counterpart, the {src5} standard requires the contract to implement a `supports_interface` function,
which can be used to query the contract's support for a given interface:

[,javascript]
----
trait ISRC5 {
    /// Query if a contract implements an interface.
    /// Receives the interface identifier as specified in SRC-5.
    /// Returns `true` if the contract implements `interface_id`, `false` otherwise.
    fn supports_interface(interface_id: felt252) -> bool;
}
----

=== Computing the interface ID

The interface ID, as specified in the standard, is the https://en.wikipedia.org/wiki/Exclusive_or[XOR] of all the
https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md#extended-function-selector[Extended Function Selectors]
of the interface. We strongly advice to read the SNIP for getting into the specifics of obtaining these
Extended Function Selectors, but there are tools that can help with this process, such as {src5-rs}.

=== Registering interfaces

For a contract to declare its support for a given interface, the contract should import the SRC5 module and
register its support. It's recommended to register interface support upon contract deployment through a constructor
either directly or indirectly (as an initializer) like this:

[,javascript]
----
#[starknet::contract]
mod Contract {
    use openzeppelin::account::interface;
    use openzeppelin::introspection::src5::SRC5;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(ref self: ContractState) {
        let mut unsafe_state = SRC5::unsafe_new_contract_state();
        SRC5::InternalImpl::register_interface(ref unsafe_state, interface::ISRC6_ID);
    }

    (...)
}
----

=== Querying interfaces

Use the `supports_interface` function to query a contract's support for a given interface.

TIP: If you are unsure whether the contract implements SRC5 or not, you can follow the process described in
https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md#how-to-detect-if-a-contract-implements-src-5[here].
