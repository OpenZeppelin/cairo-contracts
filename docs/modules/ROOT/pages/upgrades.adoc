:contract_classes: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-classes/[Contract Classes]
:class_hash: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash/[class hash]
:replace_class_syscall: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#replace_class[replace_class]
:upgradeable: https://github.com/OpenZeppelin/cairo-contracts/blob/cairo-2/src/upgrades/upgradeable.cairo[Upgradeable]
:ownable: xref:access.adoc#ownership_and_ownable[Ownable]
:library_calls: https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#library_call[library calls]

= Upgradeability

Smart contracts are immutable by design, by default preventing any update after the contract is deployed.
This supports decentralization and trustlessness, but in certain cases can be an drawback for example
by removing the ability to fix bugs or vulnerabilities.

Multiple patterns have been developed for making a contract upgradeable including the widely adopted proxy pattern.

Starknet has native upgradeability through a syscall that updates the contract source code, removing the need for proxies.

== Replacing contract classes

To better comprehend how upgradeability works in Starknet, it's important to understand the difference between a contract and its contract class.

{contract_classes} represent the source code of a program. All contracts are associated to a class, and many contracts can be instances of the same one. Classes are usually represented by a hash also known as "{class_hash}", and before a contract of a certain class can be deployed the hash needs to be declared.

=== `replace_class_syscall`

As mentioned, this class hash determines the contract source code, which is designed to be immutable.
However, since sometimes it is necessary to update the contract source code, the `{replace_class_syscall}` syscall
was introduced. This syscall allows developers to replace the class hash of an already deployed contract.


[,javascript]
----
/// Upgrades the contract source code to the new contract class.
fn _upgrade(new_class_hash: ClassHash) {
    assert(!new_class_hash.is_zero(), 'Class hash cannot be zero');
    starknet::replace_class_syscall(new_class_hash).unwrap();
}
----

NOTE: If a contract is deployed without this mechanism, its class hash can still be replaced through {library_calls}.

== `Upgradeable` module

OpenZeppelin Contracts for Cairo provides {upgradeable} to add upgradeability support to your contracts.

=== Usage

Upgrades are often very sensitive operations, and some form of access control is usually required to
avoid unauthorized upgrades. The {ownable} module is used in this example.

[,javascript]
----
#[starknet::contract]
mod UpgradeableContract {
    use openzeppelin::access::ownable::Ownable;
    use openzeppelin::upgrades::Upgradeable;
    use openzeppelin::upgrades::interface::IUpgradeable;
    use starknet::ClassHash;
    use starknet::ContractAddress;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(self: @ContractState, owner: ContractAddress) {
        let mut unsafe_state = Ownable::unsafe_new_contract_state();
        Ownable::InternalImpl::initializer(ref unsafe_state, owner);
    }

    #[external(v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            // This function can only be called by the owner
            let ownable_state = Ownable::unsafe_new_contract_state();
            Ownable::InternalImpl::assert_only_owner(@ownable_state);

            // Replace the class hash upgrading the contract
            let mut upgradeable_state = Upgradeable::unsafe_new_contract_state();
            Upgradeable::InternalImpl::_upgrade(ref upgradeable_state, new_class_hash);
        }
    }

    (...)
}
----

=== Interface


[,javascript]
----
trait IUpgradeable {
    fn upgrade(new_class_hash: ClassHash);
}
----

== Proxies and Starknet

Proxies allow for different patterns such as upgrades as well as deploying multiple clones of the same contract. But Starknet achieves these two things in different ways.

In the case of contract upgrades, it is achieved by simply changing the contract's class hash. As of clones, contracts already are like clones of the class they implement.

Implementing a proxy pattern in Starknet has an important limitation: there is no fallback mechanism to be used
for redirecting every potential function call to the implementation. This means that a generic proxy contract
can't be implemented. Instead, a proxy contract must be implemented with each specific function that is going to be redirected.
This can still be useful for example with upgrading the logic of some functions.
